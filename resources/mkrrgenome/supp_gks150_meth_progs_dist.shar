echo c - meth_progs_dist
mkdir -p meth_progs_dist > /dev/null 2>&1
echo c - meth_progs_dist/include
mkdir -p meth_progs_dist/include > /dev/null 2>&1
echo x - meth_progs_dist/include/bas_fns.h
sed 's/^X//' >meth_progs_dist/include/bas_fns.h << 'END-of-meth_progs_dist/include/bas_fns.h'
X/* bas_fns.h: headers for basic library functions in c */
X
X#ifdef MALLOCDBG
X
Xtypedef struct Malchk     /* for checking mallocs */
X  {
X  void *ptr;
X  struct Malchk *nextmelt;
X  struct Malchk *prvmelt;
X  }
XMALCHK;
X
XMALCHK *scan4free(void *pt);
X  /* return ptr to structure containing address pt, NULL if not found */
X
X#endif
X
Xvoid bas_initmalfl(char *nm);
X/* initialise mf to write to nm for tracing purposes */
X
Xchar *getmemory(int nbytes,
X                char *msg);
X/* malloc nbytes, and return address: die with msg if problem */
X
Xchar *bas_strdup(char *str);
X  /* local strdup, intended to be trackable if needed */
X
Xvoid memfree(void *pt);
X  /* free malloced pt, tell malfl if appropriate */
X
Xvoid bas_tellunfreed();
X  /* report presently unfreed memory - write to malfl if appropriate */
X
Xvoid bas_rptchrout(FILE *fl,
X                   int cc,
X                   char c);
X/* put cc repetitions of c to fl */
X
Xchar *bas_int2strmnth(int imnth,
X                      int shrtfm);
X/* return a pointer to an array of month names, 3 letter form for shrtfm */
X
Xvoid bas_scatprintf(char *buf,
X                    int blen,
X                    char *fmt,
X                    ...);
X/* varags method of appending (concatenating more material to
Xbuf */
X
Xvoid bas_appdate2str(char *dbuf,
X                     char **bp,
X                     int blen);
X/* append system date & time to dbuf if room at *bp, update *bp
X   - code nicked from man strftime pages */
X
Xvoid sqfl_date2file(FILE *sfl);
X  /* write system date & time to sfl */
X
Xint imin(int i,
X         int j);
X/* return the minimum of i,j */
X
Xint imax(int i,
X         int j);
X/* return the larger of i,j */
X
Xvoid bas_skipeol(FILE *fl,
X                 int *lno);
X/* skip past next \n char, increment lno if non-null */
X
Xchar *bas_fgets(char *buf,
X                int blen,
X                FILE *fl,
X                int *lcnt);
X/* perform fgets of fl, remove \n from string */
X
Xint bas_chr2ubuf(char *lbuf,
X                 char **bp,
X                 char nc,
X                 int blen);
X/* append nc to lbuf at *bp.  return 1 if room */
X
Xvoid bas_appchr(char *lbuf,
X                char **bp,
X                char nc,
X                int blen);
X/* append nc to lbuf at *bp, if *bp does not exceed blen chars in total */
X
Xvoid bas_catchr(char *lbuf,
X                char nc,
X                int blen);
X/* append nc to lbuf end of current string, check won't exceed blen chars in 
Xtotal */
X
Xint bas_str2ubuf(char *lbuf,
X                 char **bp,
X                 char *str,
X                 int blen);
X/* append str to lbuf at *bp, if room.  return no of chars inserted */
X
Xvoid bas_appstr(char *lbuf,
X                char **bp,
X                char *str,
X                int blen);
X/* append str to lbuf at *bp, if *bp does not exceed blen chars in total */
X
Xint bas_int2ubuf(char *lbuf,
X                char **bp,
X                int ival,
X                char *fmt,
X                int blen);
X/* append ival to lbuf at *bp, return 1 if there was sufficient room */
X
Xint bas_fgetatm_ufn(FILE *fl,
X                    char *lbuf,
X                    int blen,
X                    char *brkchrs,
X                    int (*ufgetc)(FILE *f));
X/* read characters from fl using ufgetc, skipping any in brkchrs.
X  write to lbuf, if not overlength, stopping at EOF or next 
Xoccurrence of brkchrs.  Return number of chrs read. 
XNULL terminate string if underlength */
X
Xint bas_fgetatm(FILE *fl,
X                char *lbuf,
X                int blen,
X                char *brkchrs);
X/* read characters from fl, skipping any in brkchrs.  write to lbuf, if
Xnot overlength, stopping at EOF or next occurrence of brkchrs.  Return
Xnumber of chrs read. NULL terminate string if underlength */
X
Xint bas_fgetlin(FILE *fl,
X                char *lbuf,
X                int blen,
X                int *lcnt);
X/* read characters from fl to next eoln or EOF.  Return
Xnumber of chrs read, even if 0. NULL terminate string if underlength
Xreturn -1 for EOF */
X
Xint bas_ptrgetatm(char *sbuf,
X                  char **sp,
X                  char *lbuf,
X                  int blen,
X                  char *brkchrs);
X/* scan characters from sbuf, starting at *bp, skipping any in brkchrs.  
X update *bp to final position.  write to lbuf, if
Xnot overlength, stopping at '\0' or next occurrence of brkchrs.  Return
Xnumber of chrs written. NULL terminate string if underlength */
X
Xint bas_sgetatm(char *sbuf,
X                char *lbuf,
X                int blen,
X                char *brkchrs);
X/* scan characters from sbuf, skipping any in brkchrs.  write to lbuf, if
Xnot overlength, stopping at '\0' or next occurrence of brkchrs.  Return
Xnumber of chrs written. NULL terminate string if underlength */
X
Xint bas_digitsin(int nmb);
X  /* return the number of decimal digits to represent nmb */
X
Xchar *bas_strcpyskip(char *lin,
X                     int smax,
X                     char *dst,
X                     int dmax,
X                     char *skipset);
X/* copy lin up to smax chars to dst, up to dmax chars.  skip leading chars
Xin skipset, stop on first skipset char.  Return pointer to remainder of string
X - NULL if nothing was found */
X
Xchar *bas_modstrng(char *str,
X                   int (*chrmod)(int nc));
X/* replace each character of str by chrmod()ed equivalent.  return str */
X
Xint bas_null4nl(int nc);
X  /* return nc, unless it is a nl, in which case return '\0' */
X
Xchar *bas_sharchrs(char *s1,
X                   char *s2);
X/* return a pointer to any part of s1 that appears in s2, NULL if none */
X
Xint bas_cntfputs(char *str,
X                 FILE *fl);
X/* return the length of this string, and put to fl */
X
Xint bas_coutputchr(FILE *fl,
X                   char c);
X/* write c to fl, in "approved form. return no of chars to do this */
X
Xint bas_putochr(FILE *fl,
X                char c);
X/* write c to fl, in octal form. return no of chars to do this */
X
Xint bas_coutputstr(FILE *fl,
X                   char *str,
X                   char dlmt,
X                   int ccnt,
X                   int (*coutfun)(FILE *xfl,
X                                  char c));
X/* put out ccnt characters from str, irrespective of their value.  Return
Xactual no of char positions consumed */
X
Xint bas_strncmp(char *s1,
X                char *s2,
X                int n);
X/* compare s1 & s2 byte by byte up to n bytes or till either differ.
X  return 0 if same, -1 if s1 precedes s2 in collating order, +1 if succeeds.
XDiffers from library strncmp() in that this will continue beyond null chars */
X
Xint bas_cmatcasdep(char c1,
X                   char c2);
X/* return 1 if c1 == c2, case dependent */
X
Xint bas_cmatnocas(char c1,
X                  char c2);
X/* return 1 if c1 == c2, case independent */
X
Xint bas_wldstrcmp(char *strng,
X                  char *patn,
X                  int (*chrcmpfn)(char c1,
X                                  char c2));
X/* simple minded string matching function which will match chars using 
X(*chrcmpfn)() (returns 1 for match, 0 otherwise), and '*'s.
X  return 1 for match 0 otherwise */
X
Xint bas_getustr(FILE *fl,
X                char *ubuf,
X                int ublen);
X/* get user input - read chars, don't overflow ubuf.
Xreturn length of string returned, -1 for EOF */
X
Xint bas_ugetstr(char *prmpt,
X                char *ubuf,
X                int ublen);
X/* prompt for user input with prmpt - read chars, don't overflow ubuf.
Xreturn length of string returned */
X
Xvoid bas_pause();
X  /* request user <CR> */
X
Xint bas_getuint(char *prmpt,
X                int min,
X                int max,
X                int def,
X                int *uval);
X/* prompt stdout/stdin for an integer value generating a prompt from prmpt
Xrange and default values.  return returned value in uval and 1 if decoded OK,
Xelse return 0 */
X
Xint bas_uconfirm(char *prmpt,
X                 char def);
X/* prompt for a yes/no response */
END-of-meth_progs_dist/include/bas_fns.h
echo x - meth_progs_dist/include/cod_fns.h
sed 's/^X//' >meth_progs_dist/include/cod_fns.h << 'END-of-meth_progs_dist/include/cod_fns.h'
X/* cod_fns.h: headers for codon-related functions in c */
X
X#define CF_NC_RARE 1.0e-6
X#define CF_NON_RESULT -999.99
X#define CF_NC_CUTOFF 100
X#define CF_NC_MAX 61.0
X#define CF_RSCUATOM 24
X#define CF_MAXSRCLEN 80
X
Xtypedef enum CF_rscuptype     /* parsing RSCU files */
X  {
X  CF_rscu_res = 0,
X  CF_rscu_cdn,
X  CF_rscu_real
X  }
XCF_RSCUPTYPE;
X
X/* routine headers */
X
Xint cf_codno4cvptr(COD_VECT_STRCT *cvp);
X  /* iterate thru cvp list counting no of elements */
X
Xint cf_codno4res(COD_VECT_STRCT **cvlist,
X                 char aares);
X/* return the number of codons for this residue - by iterating thru linked
Xlist */
X
Xint cf_totimtrx(TRANS_MATRX ccnts);
X  /* return the sum of valid ccnts */
X
Xint cf_cnts4veclst(TRANS_MATRX cnts,
X                   COD_VECT_STRCT *cvec);
X/* return the total cnts entries for this cvec list */
X
Xint cf_totcnts4res(TRANS_MATRX cnts,
X                   COD_VECT_STRCT **cvs,
X                   char ares);
X/* sum up the total counts in cnts for residue ares */
X
Xchar *cf_gc3_ref();
X
Xdouble cf_cnts2gc3(TRANS_MATRX cnts,
X                   COD_VECT_STRCT **cvec);
X/* return the value of gc3 statistic on cnts.  gc3 = proportion of codons
Xwith c/g in 3rd position, discounting singleton codons and terms.
XIkemura (1985), Mol Biol Evol, 2, 13-34. */
X
Xdouble cf_hzygot(COD_VECT_STRCT *cvlst,
X                 TRANS_MATRX cnts);
X/* return homozygosity value for cvlst.  Return CF_NON_RESULT if "rare" aa
Xaccording to Wright's criterion */
X
Xchar *cf_nc_ref();
X
Xdouble cf_cnts2nc(TRANS_MATRX ccnts,
X                  COD_VECT_STRCT **cvecs);
X/* perform the calculation for "effective number" of codons used in a gene;
X  for ccounts.  Wright (1990), Gene, 87, 23-29 */
X
Xint cf_chkrscutbl(FILE *lfl,
X                  TRANS_MATRX rscu,
X                  COD_VECT_STRCT **cvecs,
X                  float prec);
X/* check that values in rscu table conform to requirement that they should
Xall add to n for each aa where n is the no of codons.  Allow prec*n deviation.
Xlog errors if lfl is non-NULL */
X
Xint cf_rscuexfile(FILE *fl,
X                  TRANS_MATRX tm);
X/* attempt to read a rscu matrix from fl - assume "fish_term" std format:
X     ================================================
X     F TTT 1.143 S TCT 1.467 Y TAT 0.500 C TGT 2.000
X     F TTC 0.857 S TCC 2.133 Y TAC 1.500 C TGC 0.000
X     L TTA 0.067 S TCA 0.000 * TAA 0.000 * TGA 0.000
X     L TTG 0.400 S TCG 0.133 * TAG 0.000 W TGG 1.000
X     ================================================
X     L CTT 0.000 P CCT 2.483 H CAT 0.872 R CGT 0.000
X...
X
X& drop lines starting with '#'
X
XReturn 1 for successful read */
X
Xvoid cf_rscu2reladpt(TRANS_MATRX rscu,
X                     COD_VECT_STRCT **cvecs,
X                     TRANS_MATRX rad);
X/* relative adaptiveness is ration of given rscu to the max for that residue.
X*/
X
Xchar *cf_cai_ref();
X
Xdouble cf_cnts2cai(TRANS_MATRX cnts,
X                   COD_VECT_STRCT **cvec,
X                   TRANS_MATRX rscu);
X/* use the rscu table and cvec to calculate the Codon Adaptive Index
Xfor cnts.  Sharp & Li, (1987), NAR, 15, 1281). */
X
Xvoid cf_veccnts2rscutbl(COD_VECT_STRCT **cvs,
X                        TRANS_MATRX cnts,
X                        TRANS_MATRX rscu);
X/* use codon vector set cvs to calculate rscu table for cnts */
X
Xvoid cf_cnts2rscutbl(TRANS_MATRX tmat,
X                     TRANS_MATRX cnts,
X                     TRANS_MATRX rscu);
X/* make a codon vector set from tmat, then use this to calculate RSCU table */
END-of-meth_progs_dist/include/cod_fns.h
echo x - meth_progs_dist/include/fsm_ops.h
sed 's/^X//' >meth_progs_dist/include/fsm_ops.h << 'END-of-meth_progs_dist/include/fsm_ops.h'
X/* fsm_ops.h: type definitions for general FSM operations */
X
Xtypedef struct FS_reselt  /* a result element - part of l-list of actions */
X  {
X  void *action;           /* what to return when this result is attained */
X  struct FS_sttelt *nxtstate;  /* next stt state - actually *FS_STTELT */
X  int locatd;             /* true when this result is found */
X  struct FS_reselt *nxtreselt;  /* forward link */
X  struct FS_reselt *prvreselt;  /* back link (needed?) */
X  }
XFS_RESELT;
X
Xtypedef struct FS_sttelt  /* element in stt table */
X  {
X  int eltno;                 /* number of this element */
X  FS_RESELT *reslts;      /* pointer to malloced array of result elements */
X  char *s_cis;                 /* Current Interesting Sequence */
X  int achk;                     /* for access checking */
X  struct FS_sttelt *nxtsttelt;  /* forward list of these for housekeeping */
X#ifdef U_TRACK
X  int axcnt;                    /* count the frequency of access */
X#endif
X  }
XFS_STTELT;
X
Xtypedef struct FS_datprelt       /* for linked list of data elements */
X  {
X  char *dstrng;                  /* data string */
X  int ldstr;                     /* length of dstrng */
X  void *stxt;                    /* accompanying text/etc. */
X  int mallced;                   /* set if stxt can be free()ed */
X  int plocat;                    /* 0 if not located */
X  struct FS_datprelt *nxtpelt;   /* forward link */ 
X  struct FS_datprelt *prvpelt;   /* back link */
X  }
XFS_DATPRELT;
X
Xtypedef enum FS_oninvld   /* options for invalid input characters */
X  {
X  FS_inv_reset = 0,       /* reset fsm to init state */
X  FS_inv_ressay,          /* ditto, report error to stderr */
X  FS_inv_ignor,           /* ignore */
X  FS_inv_ignsay           /* ignore, but mention to stderr */
X  }
XFS_ONINVLD;
X
Xtypedef struct FS_fsmstrct       /* fundamental info */
X  {
X  WRD_LUSTRCT *cis;
X  WRD_LUSTRCT *instrngs;
X  FS_STTELT *firststt;             /* state transition table */
X  FS_STTELT *laststt;              /* max current state */
X  FS_STTELT *currstt;              /* set to current state */
X  int nstats;                      /* No states for input */
X  int dosubs;                      /* 1=complete substrings, 0=don't */
X  void *null_reslt;                /* what to return for noscore */
X  char *cisbuf;                    /* buffer malloc()ed for cis */
X  int strmax;                      /* longest string in input set */
X  int sttcnt;                      /* current no of stt elements */
X  FS_DATPRELT *prlst;              /* start of paired element list */
X  FS_DATPRELT *lstpr;              /* last pair element */
X  FS_ONINVLD invact;               /* define behavior for invalid in chars */
X  int dbgbld;                      /* trace behaviour, defaults to 0=don't */
X  }
XFS_FSMSTRCT;
X
Xtypedef enum FS_bldstatus          /* values when fsm is under construction */
X  {
X  FS_bldnoint = 0,      /* no interest */
X  FS_bldmatcis,         /* matches existing stt cis */
X  FS_bldmatinpt,        /* matches an input string */
X  FS_bldintrst          /* matches head of input string */
X  }
XFS_BLDSTATUS;
X
X/* function headers */
X
XWRD_LU_REC *fs_shed2lurec(FS_FSMSTRCT *fss,
X                          char *cstrng,
X                          size_t lcstr);
X/* return a pointer to the lu_rec for which cstrng matches the head.
XNULL if non-existent */
X
Xvoid fs_initfsmstrct(FS_FSMSTRCT *fs,
X                     int nstates,
X                     int dsubs,
X                     FS_ONINVLD inv);
X/* assign initial (NULL largely) values to fs components.  dsubs determines if
Xfsm will completely handle substrings - The method of Smith (1988) CABIOS, 4,
X459 does not correctly handle substrings.  It is made optional here in order
Xto allow some uses to work properly.  dsubs=1 - build fsm for substrings,
Xdsubs=0 - build fsm as in Smith, 1988 */
X
XFS_FSMSTRCT *fs_initnewfsm(int nstates,
X                           int dsubs,
X                           FS_ONINVLD inv);
X/* malloc() storage for a new fsm & assign initial (NULL largely) values to
Xfs components, return address. dsubs is described in fs_initfsmstrct() */
X
XFS_RESELT *fs_appndreselt(FS_RESELT **rlst,
X                          void *rsp);
X/* append a new value to *rlst, return address of new element */
X
Xvoid fs_clrreslst(FS_RESELT **rlst);
X  /* Chain through *rlst, freeing all malloc()ed memory */
X
XFS_STTELT *fs_appndsttelt(FS_STTELT **lstrt,
X                          int nstats);
X/* append a new element to *lstrt, and making nstats result slots for it.
X  return address of new element */
X
Xvoid fs_initreselt(FS_RESELT *rep);
X  /* put NULL values into rep */
X
Xvoid fs_initfsmbld(FS_FSMSTRCT *fsm,
X                   int casedep);
X/* init data structures prior to building fsm */
X
Xvoid fs_clrprlst(FS_DATPRELT **rlst);
X  /* Chain through *rlst, freeing all malloc()ed memory */
X
Xint fs_cntdatprs(FS_DATPRELT *pp);
X  /* return the number of datalist items in *pp */
X
Xvoid fs_adddatprs(FS_FSMSTRCT *fss,
X                  char *sstrng,
X                  void *lval);
X/* put a data pair (sstrng associated with lval) into fss. */
X
Xvoid fs_addstrprs(FS_FSMSTRCT *fss,
X                  char *sstrng,
X                  char *stxt);
X/* put a data pair (sstrng associated with stxt) into fss, stxt is
Xstrdup()ed locally. */
X
Xint fs_lstcstr(FILE *fl,
X               char *str);
X/* display characters of str to fl, converting non-printable chars to standard
XC representation, return no chars actually written */
X
Xvoid fs_showpval(FILE *fl,
X                 void *p);
X/* let p be an arbitrary pointer, print it */
X
Xint fs_inprcnt(FS_DATPRELT *plst,
X               FS_DATPRELT *pp);
X/* count pair elements in plst till pp, 0 for none */
X
Xvoid fs_lststrpr(FILE *fl,
X                 FS_DATPRELT *pp,
X                 int cnt,
X                 void (*slstfn)(FILE *bfl,
X                                void *p),
X                 void (*newlnfn)(FILE *afl));
X/* recursively list *pp */
X
Xint fs_dprs2wlu(FS_FSMSTRCT *fss,
X                int casedep);
X  /* malloc()s storage for instrng wlu table, inits and loads data pairs
Xinto it.  Return count of included values */
X
Xvoid fs_lstwluprs(FILE *fl,
X                  WRD_LUSTRCT *wlus);
X/* list the contents of wlus at fl */
X
Xint fs_chkinpstr(FS_FSMSTRCT *fss,
X                 FS_STTELT *sttp,
X                 int ap,
X                 char *acis);
X/* check if acis matches any input strings & if so, note them as outputs.
XEffectively implements Rule 3, return count of matching strings */
X
XWRD_LU_REC *shed2lureclin(FS_FSMSTRCT *fss,
X                          char *cstrng,
X                          size_t lcstr);
X/* return a pointer to the lu_rec for which cstrng matches the head.
XNULL if non-existent */
X
Xint fs_bldstt4prs(FS_FSMSTRCT *fss,
X                  char (* int2chrfn)(int ci),
X                  int (*chkinpstrfn)(FS_FSMSTRCT *xfss,
X                                     FS_STTELT *xsttp,
X                                     int xap,
X                                     char *xacis),
X                  WRD_LU_REC *(*shed2lurecfn)(FS_FSMSTRCT *zfss,
X                                              char *zcstrng,
X                                              size_t zlcstr));
X/* go thru logic for building stt for loaded data, return no of states
Xrequired.  (*int2chrfn)() is used to convert an alpha pointer to a char */
X
Xvoid fs_purgecis(FS_FSMSTRCT *fss);
X  /* remove cis storage from fss */
X
Xvoid fs_purgelustrct(FS_FSMSTRCT *fss);
X  /* remove lookup structures and cis buffer from fss */
X
Xvoid fs_purgefsm(FS_FSMSTRCT *fss);
X  /* remove unnecessary storage from fss */
X
Xvoid fs_clrfsm(FS_FSMSTRCT *fss);
X  /* clear storage from fss, leave basic fss structure, but denude it of 
Xany malloc()ed stuff */
X
Xvoid fs_killfsm(FS_FSMSTRCT **fss);
X  /* completely free() *fss storage, base fss structure included */
X
Xint fs_chkfsm(FS_FSMSTRCT *fss,
X              int erprt,
X              char (*int2chr)(int ic));
X/* check fss to ensure:
X  1: all states are valid & exist
X  2: all data pairs are located
X  3: anything else I think of
Xreturn 1 if OK.  erprt controls error reporting: 0 means say nothing, 1
Xmention each error */
X
Xint fs_bldfsm(FS_FSMSTRCT *fss,
X              int casedep,
X              int errpt,
X              int purge,
X              char (*int2chr)(int ic),
X              int (*chkinpstrfn)(FS_FSMSTRCT *xfss,
X                                 FS_STTELT *xsttp,
X                                 int xap,
X                                 char *xacis),
X              WRD_LU_REC *(*shed2lurecfn)(FS_FSMSTRCT *zfss,
X                                          char *zcstrng,
X                                          size_t zlcstr));
X/* combine a series of fsm building steps, return no of states if checks OK,
Xelse -1 */
X
Xvoid fs_initrun(FS_FSMSTRCT *fss);
X/* initialise the fsm for running */
X
XFS_RESELT *fs_procchr(FS_FSMSTRCT *fss,
X                      char nc,
X                      int (*chr2int)(char c));
X/* feed nc into fsm and return any result list.  if nc is invalid, behavior
Xis determined by fss->invact. The returned value is the heading to a linked 
Xlist of results */
X
Xint fs_rmdupstts(FS_FSMSTRCT *ffst);
X  /* scan stts, looking for duplicates which have no actions: combine into
Xfirst occurrence, and delete the duplicate.  Return number of dups so
Xremoved */
X
Xvoid fs_lststtelt(FILE *fl,
X                  FS_FSMSTRCT *fss,
X                  FS_STTELT *stp);
X/* tell fl about stp */
X
Xvoid fs_lststttbl(FILE *fl,
X                  FS_FSMSTRCT *fss);
X/* list info in fss */
X
Xvoid fs_tellusage(FILE *fl,
X                  FS_FSMSTRCT *fss);
X/* tell fl about the usage of each state of fss */
END-of-meth_progs_dist/include/fsm_ops.h
echo x - meth_progs_dist/include/sqfl_fns.h
sed 's/^X//' >meth_progs_dist/include/sqfl_fns.h << 'END-of-meth_progs_dist/include/sqfl_fns.h'
X/* sqfl_fns.h: datatype and routine definitions for c sequence file functions
X */
X
Xtypedef enum SFMT_type        /* seq file format types */
X  {
X  SFMT_undefined = 0,
X  SFMT_staden,
X  SFMT_molgen,
X  SFMT_nbrf,
X  SFMT_fasta,
X  SFMT_gcg,
X  SFMT_raw
X  }
XSFMT_TYPE;
X
X  /* max chars in header buffer */
X#define HDRBUF_MAX 512
X
Xtypedef enum sqfl_sqtopol  /* sequence topology */
X  {
X  SQTP_unknown = 0,
X  SQTP_linear,
X  SQTP_circular
X  }
XSQFL_SQTOPOL;
X
Xtypedef enum sqfl_sqtos    /* type of sequence */
X  {
X  SQFL_tosunknown = 0,
X  SQFL_dna,
X  SQFL_rna,
X  SQFL_peptide
X  }
XSQFL_SQTOS;
X
Xtypedef enum SQ_restype    /* enumerated set of sequence residues */
X  {
X  RES_x = 0, /* unknown,unspecified */
X  RES_a,     /* A or Ala */
X  RES_c,     /* C or Cys */
X  RES_g,     /* G or Gly */
X  RES_t,     /* T,U or Thr */
X  RES_b,     /* Asx */
X  RES_d,     /* Asp */
X  RES_e,     /* Glu */
X  RES_f,     /* Phe */
X  RES_h,     /* His */
X  RES_i,     /* Ile */
X  RES_k,     /* Lys */
X  RES_l,     /* Leu */
X  RES_m,     /* Met */
X  RES_n,     /* Asn */
X  RES_p,     /* Pro */
X  RES_q,     /* Gln */
X  RES_r,     /* Arg */
X  RES_s,     /* Ser */
X  RES_v,     /* Val */
X  RES_w,     /* Trp */
X  RES_y,     /* Tyr */
X  RES_z,     /* Glx */
X  RES_blk    /* null character */
X  }
XSQ_RESTYPE;
X
X#define MAXSQCHRVAL 128    /* max byte value for any valid seq character */
X
Xtypedef struct sqfl_strct  /* information relevant to sequence files */
X  {
X  SFMT_TYPE flfmt;
X  FILE *sfl;               /* stream for sequence file */
X  char *filnam;            /* sequence file name */
X  char *seqnam;            /* sequence name */
X  SQFL_SQTOPOL stopol;     
X  SQFL_SQTOS sqtos;
X  int slength;             /* length of sequence */
X  int gcgchksum;           /* checksum for gcg output */
X  int scnt;                /* count of written residues */
X  char lstinchr;           /* cache the last char read */
X  char *gnam;              /* name of auxfile for gcg temp storage */
X  FILE *gfl;               /* aux file for gcg temporary storage */
X  int lnlen;               /* length of output lines */
X  char *annot;             /* annotation - use def if NULL */
X  int abuflen;             /* length of allocated buffer */
X  char *thisuse;           /* "r" or "w": fopen usage strings */
X  int validlut[MAXSQCHRVAL]; /* lut for valid residues */
X  }
XSQFL_STRCT;
X
X  /* chars in sequence name */
X/* #define SQNAMEMAXLEN 12 */
X#define SQNAMEMAXLEN 80
X
X/* allow longer names to avoid downstream problems: Jan-2005 */
X
X/* GCG uses this value to calculate checksum positions */
X
X#define SQFL_GCGCHK 57
X
Xtypedef enum sqfl_gcgwrds  /* useful header words for gcg files */
X  {
X  SQFL_gcgunknown = 0,
X  SQFL_gcglength,
X  SQFL_gcgtype,
X  SQFL_gcgdots            /* .. data indicator */
X  }
XSQFL_GCGWRDS;
X
X/* function headers */
X
XSFMT_TYPE sqfl_chr2fmttp(char fchr);
X  /* convert the letters s,q,f,n,u to corresponding file format type.
X  currently case independent */
X
XSFMT_TYPE sqfl_getdeffmt();
X  /* use env variable SEQDEFFILEFMT to establish default file type */
X
Xchar *sqfl_fmttp2strng(SFMT_TYPE sfmt);
X  /* return the pointer to a string defining sfmt */
X
Xchar sqfl_fmttp2chr(SFMT_TYPE sfmt);
X  /* return a character sfmt */
X
Xchar sqfl_restype2chr(SQ_RESTYPE rt);
X  /* return the character corresponding to rt */
X
Xchar *sqfl_restype2str(SQ_RESTYPE rt);
X  /* return the address of a string corresponding to rt */
X
XSQ_RESTYPE sqfl_chr2restype(char res);
X  /* return an internal restype for this character */
X
XSQ_RESTYPE sqfl_chr2narestype(char rs);
X  /* return RES_x..RES_t only */
X
XSQ_RESTYPE sqfl_chr2aarestype(char r);
X  /* return the corresponding restype for r, assuming it is a valid AA code,
Xelse return RES_x */
X
XSQFL_SQTOS sqfl_chr2tos(SFMT_TYPE sfmt,
X                        char tc);
X/* return the tos for tc - case independent */
X
Xint sqfl_linelength(SFMT_TYPE sfmt);
X  /* return normal linelength used by this format */
X
Xint sqfl_gcgchkinc(int sp,
X                   char res);
X/* return the incremental addition for the GCG check algorithm for res at
X  position sp, (1..n) */
X
Xint sqfl_gcgsqchksum(char *sq,
X                     int sqlen);
X/* return gcg checksum for (1..sqlen) chars of sq.  Stop at '\0'
Xif encountered ealier */
X
XSQFL_SQTOS sqfl_scantos(char *sqbuf,
X                        int sqln);
X/* scan sqbuf, looking for evidence of NA or peptide.
X  Algorithm looks for the letters E,F,I,O,X,Z: none of which should occur in
X  DNA sequences, even using IUB or LDNA redundant base codes.  A proportion
X  1% of strangers is allowed */
X
XSQFL_SQTOS sqfl_scanfltos(SQFL_STRCT *src);
X  /* scan contents of previously opened src, looking for evidence of 
XNA or peptide.  Rewind source file on completion.
X  Algorithm looks for the letters E,F,I,O,X,Z: none of which should occur in
X  DNA sequences, even using IUB or LDNA redundant base codes.  A proportion
X  1% of strangers is allowed */
X
Xchar sqfl_tos2chr(SFMT_TYPE sfmt,
X                  SQFL_SQTOS st);
X  /* return the character for sequence st - default to D */
X
Xchar sqfl_topol2chr(SFMT_TYPE sfmt,
X                    SQFL_SQTOPOL st);
X/* return a character corresponding to st for sfmt */
X
Xvoid sqfl_setsqdetails(SQFL_STRCT *st,
X                       char *sqbuf,
X                       int sqlen);
X/* set as many as possible of st details by examination of sqbuf */
X
Xvoid sqfl_headsfstr(SQFL_STRCT *sst,
X                    char *sqname,
X                    char *ann);
X/* write sequence header info to previously opened sst->sfl, using string ann
X */
X
Xvoid sqfl_headsfstrct(SQFL_STRCT *sst,
X                      char *sqname,
X                      char *maker,
X                      char *origin);
X/* write sequence header info to previously opened sst->sfl */
X
Xvoid sqfl_headsfstrctann(SQFL_STRCT *sst,
X                         char *sqname);
X/* write sequence header info to previously opened sst->sfl. use annotation
X  if set */
X
Xvoid sqfl_newlnstart(FILE *sfl,
X                     SFMT_TYPE sfmt,
X                     int sp);
X/* if necessary, write this number as a line start */
X
Xvoid sqfl_putchr(SQFL_STRCT *sqs,
X                 char chr,
X                 int rp,
X                 int *lcnt);
X/* put chr out to file, ignoring validity. observe line count etc */
X
Xvoid sqfl_putres(SQFL_STRCT *sqs,
X                 char res,
X                 int rp,
X                 int *lcnt);
X/* put res out to file, keeping track of valid bases, line count etc */
X
Xvoid sqfl_termsqfl(SQFL_STRCT *sqs,
X                   char *pname,
X                   int *lcnt);
X/* finish off sequence if necessary */
X
Xint sqfl_lookforchr(FILE *sfl,
X                    char ec);
X/* scan sfl, looking for ec.  stop and return 1.  Return 0 if EOF encountered
X  before hand */
X
Xint sqfl_look4chrs(FILE *sfl,
X                   char *ecs);
X/* scan sfl, looking for anything in ecs.  stop and return that char.
X  Return EOF if not encountered by EOF */
X
Xvoid sqfl_skipeol(SQFL_STRCT *sqs);
X  /* try to skip to end of current line - check if just seen eol already */
X
Xvoid sqfl_forceeol(SQFL_STRCT *sqs);
X  /* force skip to eol irrespective of what has been seen todate */
X
Xint sqfl_cpy2eol(SQFL_STRCT *sqs,
X                 char *buf,
X                 int bufmax,
X                 int (*ufgetc)(FILE *fl));
X/* copy to next line end to buf, up to bufmax, using ufgetc,
X  return no of chars written */
X
Xint sqfl_skipsqflhdr(SQFL_STRCT *sqs);
X  /* skip file header, getting to start of sequence.  Eventually this routine
Xshould be able to extract data from the header.  Return 1 if nothing untoward
Xoccured */
X
Xchar *sqfl_valid4fmt(SFMT_TYPE fmt);
X  /* return pointer to string of valid residues for fmt type of file.
X  This is written as case-independent - uppercase only being shown */
X
Xchar sqfl_normfillc(SFMT_TYPE sf);
X  /* return the normal fill char used for this format */
X
Xchar sqfl_getnxtres(SQFL_STRCT *sqs);
X  /* return the next valid residue from sqs.  EOF or non-alphanumeric
X   return NULL.  invalid chars are skipped */
X
Xint loadsrcrng(SQFL_STRCT *sqs,
X               char *seqbuf,
X               int fstrt,
X               int fstop);
X/* read successive chars from sfl, write valid bases in fstrt..fstop into
X  seqbuf if it is not NULL.  fstrt&fstop are sequence positions (1..n)
X  Don't put in terminal null char.
X  return no of chars that would be inserted (whether stored or not) */
X
Xint loadsrcsq(SQFL_STRCT *sqs,
X              char *seqbuf);
X/* read successive chars from sfl, write valid bases into seqbuf if it is 
X  not NULL.  Don't put in terminal null char.
X  return highest position read (whether stored or not) */
X
XSQFL_STRCT *sqfl_creatsqstrctann(FILE *ufl,
X                                 char *fnam,
X                                 SFMT_TYPE sfmt,
X                                 char *myuse,
X                                 char *annotat);
X/* use an open sequence file fnam, returning pointer to a new structure
X  if successful.  NULL if not.
X  annotat is pointer to annotation string (most useful for output files) to
X  be used if non-NULL.  myuse is as for fopen */
X
XSQFL_STRCT *sqfl_opnsqstrctann(char *fnam,
X                               SFMT_TYPE sfmt,
X                               char *myuse,
X                               char *annotat);
X/* attempt to open a sequence file fnam, returning pointer to a new structure
X  if successful.  NULL if not.  myuse is a normal parameter to fopen, though
X  it is likely that "r" and "w" are the most useful of them,
X  annotat is pointer to annotation string (most useful for output files) to
X  be used if non-NULL */
X
XSQFL_STRCT *sqfl_opnsqstrct(char *fnam,
X                            SFMT_TYPE sfmt,
X                            char *myuse);
X/* attempt to open a sequence file fnam, returning pointer to a new structure
X  if successful.  NULL if not.  myuse is a normal parameter to fopen, though
X  it is likely that "r" and "w" are the most useful of them */
X
XSQFL_STRCT *sqfl_opntoread(char *fnam,
X                           SFMT_TYPE sfmt);
X/* attempt to open a sequence file fnam for reading, returning pointer to a 
X  new structure if successful, NULL if not.  Perform header skipping, so
X  seq can be read directly */
X
Xvoid sqfl_rewind(SQFL_STRCT *sqs);
X
Xvoid sqfl_clssqstrct(SQFL_STRCT *sqs);
X  /* close this sequence data structure, freeing the allocated memory */
X
Xvoid sqfl_clsstrctfil(SQFL_STRCT *sqs);
X  /* close the file component of *sqs, retaining other information */
X
Xint readsrcsq(SQFL_STRCT *sqs,
X              char *seqbuf);
X/* read successive chars from sqs, write valid bases into seqbuf if it is 
X  not NULL.
X  return highest position read (whether stored or not) */
X
Xchar *sqfl_tos2strng(SQFL_SQTOS st);
X  /* return pointer to character string defining st */
X
XSFMT_TYPE sqfl_prmpt4sfmt(SFMT_TYPE def,
X                          SFMT_TYPE rngex,
X                          SFMT_TYPE rngto);
X/* prompt for a sequence file format, offer default def, if defined */
X
Xchar *sqfl_defextnsns(SFMT_TYPE sf);
X  /* return a suggested extension for type sf */
X
Xvoid sqfl_sfmts2bf(char *ubuf,
X                   int blim);
X/* write sfmt details to ubuf */
X
Xint sqfl_wrtsq2fl(SQFL_STRCT *sfl,
X                  char *ubuf,
X                  int blen,
X                  int *lcnt);
X/* put blen chars of ubuf as sequence to sfl file.  Return res count */
X
Xint sqfl_wrtsqbuf2fl(SQFL_STRCT *sfl,
X                     char *sqnam,
X                     char *maker,
X                     char *origin,
X                     char *ubuf,
X                     int blen);
X/* write ubuf up to blen out to sfl, (previously opened).  Do headers & 
Xterminators.  Don't close sfl, leave to calling routine.  Return no res
Xwritten */
X
Xint sqfl_fgetc(FILE *fl);
X  /* return character (as int) from fl.  ignore '\r' chars totally */
END-of-meth_progs_dist/include/sqfl_fns.h
echo x - meth_progs_dist/include/sqmat_fns.h
sed 's/^X//' >meth_progs_dist/include/sqmat_fns.h << 'END-of-meth_progs_dist/include/sqmat_fns.h'
X/* sqmat_fns.h: headers for sequence matching functions */
X
Xtypedef enum Bas_MatMode    /* match strategies for bases */
X  {
X  BAS_exact = 0,
X  BAS_iub,
X  BAS_ldna
X  }
XBAS_MATMODE;
X
X/* routine headers */
X
Xchar case_mirror(char nc,
X                 char casepat);
X/* return nc in same case as casepat */
X
Xchar ssd_bascmplmnt(char bs,
X                    BAS_MATMODE mmod);
X/* return the complementary base to bs, depending on mmod */
X
Xchar same_residue(char bas,
X                  BAS_MATMODE dummy);
X/* return bas */
X
Xvoid reverse_seq(char *sq,
X                 int sqlen,
X                 char (* cmpfun)(char xres,
X                                 BAS_MATMODE xmod),
X                 BAS_MATMODE mmod);
X/* reverse sq character order, apply
Xcmpfun to each transfer */
X
Xvoid complmnt_seq(char *sq,
X                  int sqlen,
X                  BAS_MATMODE mmod);
X/* reverse&complement the contents of sq, depending on mmod */
X
Xint ssd_bas2bit(char bas);
X/* return a bit map representing bas with A=bit 1, C=2, G=3 & T=4,
X otherwise 0 */
X
Xint ssd_bits4basechr(char bas,
X                     BAS_MATMODE mmod);
X/* return a bit map representing bas with A=bit 1, C=2, G=3 & T=4 and
X  bits set for redundant specs, as for mmod */
X
Xint ssd_basmatch(char b1,
X                 char b2,
X                 BAS_MATMODE mmod);
X
Xchar *ssd_nxtbasmatch(char *seq,
X                      char bas,
X                      BAS_MATMODE mmod);
X/* return a pointer to the next occurrence of bas in seq.  NULL if none */
X
Xchar *ssd_prvbasmatch(char *seq,
X                      char *spos,
X                      char bas,
X                      BAS_MATMODE mmod);
X/* return a pointer to the previous occurrence of bas in seq, starting 
Xfrom spos.  NULL if none */
X
Xchar *ssd_nxtstrmatch(char *seq,
X                      char *pat,
X                      BAS_MATMODE mmod);
X/* return the position of the next match of pat in seq. NULL if not found */
X
Xchar *ssd_prvstrmatch(char *seq,
X                      int sqlen,
X                      int startpos,
X                      char *pat,
X                      BAS_MATMODE mmod);
X/* return the position of the next match of pat in seq. NULL if not found */
X
Xint ssd_nxtmatchpos(char *seq,
X                    int sqlen,
X                    int curpos,
X                    char *pat,
X                    BAS_MATMODE mmod,
X                    int srchfwd);
X/* return the sequence position of next match after curpos of pat in seq.
X  0 if not found */
X
Xint ssd_bitcnt4bas(char ares,
X                   BAS_MATMODE mmod);
X/* count up the bits set for ares (i.e. no bases it represents) */
END-of-meth_progs_dist/include/sqmat_fns.h
echo x - meth_progs_dist/include/sqtrans.h
sed 's/^X//' >meth_progs_dist/include/sqtrans.h << 'END-of-meth_progs_dist/include/sqtrans.h'
X/* sqtrans.h: headers for sequence translation routines */
X
X#define CODONLENGTH 3
X#define MAXBASINT 4
X#define MAXAAINT 21
X#define SQT_TERMCHR '*'
X#define MAX_CODON_NO 64
X
Xtypedef enum sqt_gencod    /* different genetic codes - genbank numbering */
X  {
X  GC_undefined = 0,
X  GC_universal,            /* standard */
X  GC_vertmito,             /* vertebrate mitochondrial */
X  GC_yeastmito,            /* yeast mitochondrial */
X  GC_mycomito,      /* mold, protozoan, coelent, mycoplasma mitochondrial */
X  GC_invertmito,           /* invertebrae mitochondrial */
X  GC_ciliate,              /* Ciliate Dasycladacean Hexamita Nuclear */
X  GC_echinmito = 9,        /* Echinoderm mitochondrial */
X  GC_euplotid,             /* Euplotid nuclear */
X  GC_bacterial,            /* Bacterial */
X  GC_yeastalt,             /* Alternative Yeast Nuclear */
X  GC_ascidmito,            /* Ascidian mitochondrial */
X  GC_flatwmito,            /* Flatworm mitochrondiral */
X  GC_blepharisma,          /* Blepharisma nuclear */
X  GC_userdefined
X  }
XSQT_GENCOD;
X
Xtypedef struct
X  {
X  char reschr;    /* character for translation */
X  int trinit;     /* initiator */
X  } TR_RESIDUE;
X
Xtypedef union
X  {
X  TR_RESIDUE trres;
X  int iresidue;
X  float xresidue;
X  } RESIDUEDATA;
X
Xtypedef enum sqtrn_datype  /* type of data stored in matrix */
X  {
X  SQTDT_undefined = -1,
X  SQTDT_char,
X  SQTDT_int,
X  SQTDT_float
X  }
XSQTRN_DATYPE;
X
Xtypedef struct
X  {
X  SQTRN_DATYPE dtype;
X  RESIDUEDATA resdata;
X  } TRN_MATELT;
X
Xtypedef TRN_MATELT TRANS_MATRX [MAXBASINT+1] [MAXBASINT+1] [MAXBASINT+1];
X
Xtypedef int CODN_VECTR [CODONLENGTH];  /* array of integers for a codon */
X
Xtypedef struct cod_vect_strct
X  {
X  CODN_VECTR codnvector;    /* vector for this codon */
X  struct cod_vect_strct *nextcvec; /* next such struct */
X  }
XCOD_VECT_STRCT;
X
X/* typedef COD_VECT_STRCT *CVEC_PTRS [MAXAAINT + 1]; */
X
X/* routine headers for sequence translation and genetic code 
X     manipulation */
X
Xchar int2nabas(int iv);
X/* return base corresponding to iv: ?=0 A=1 C=2 G=3 T=4 */
X
XSQT_GENCOD sqt_int2gbgencod(int iv);
X  /* return the corresponding symbolic name for this integer */
X
Xchar *sqt_gbgencd2strng(SQT_GENCOD gc);
X  /* return a string pointer for this gc value */
X
Xvoid sqt_saygbgencodtbls(FILE *fl,
X                         int from,
X                         int to);
X/* describe valid codes in range from..to at fl */
X
Xint sqt_nabas2int(char abase);
X  /* return integer corresponding to abase: 0=? 1=A 2=C 3=G 4=T/U */
X
Xchar sqt_int2nabas(int iv);
X  /* return base corresponding to iv: ?=0 A=1 C=2 G=3 T=4 */
X
Xint remapbasptr(int bp);
X  /* remap base pointers to return bases in order TCAG, as per conventional
X  genetic code display */
X
Xint aares2int(char aares);
X/* return an appropriate integer pointer for this residue */
X
Xchar *aachr2str3(char aares);
X/* return an appropriate 3 letter string for this residue */
X
Xint sqt_res2aaint(char ares);
X  /* return an integer for this residue - same as aares2int, except that
X     unknown = 0 and output is 0..MAXAAINT */
X
Xchar int2aares(int aaint);
X  /* return character for this integer pointer */
X
Xvoid fill_chr_trnarr(TRANS_MATRX trnsar,
X                     char fillch);
X/* fill trnsarr with fill character */
X
Xvoid fill_ini_trnarr(TRANS_MATRX trnsar,
X                     int fillini);
X/* fill trnsarr with fill character */
X
Xvoid fill_int_trnarr(TRANS_MATRX trnsar,
X                     int fillval);
X/* fill trnsarr with fill value */
X
Xvoid fill_flt_trnarr(TRANS_MATRX trnsar,
X                     float fillval);
X/* fill float trnsarr with fill value */
X
X
Xint set_chr_trnarr(TRANS_MATRX trnsar,
X                   char *cdn,
X                   char res);
X/* put char into relevent codon positions data struct. Wild card *
X  causes all nonzero values to be initialized */
X
Xint set_ini_trnarr(TRANS_MATRX trnsar,
X                   char *cdn,
X                   int rini);
X/* put rini into relevent codon positions data struct. Wild card *
X  causes all nonzero values to be initialized */
X
Xint set_int_trnarr(TRANS_MATRX trnsar,
X                   char *cdn,
X                   int ival);
X/* put ival into relevent codon positions data struct. Wild card *
X  causes all nonzero values to be initialized */
X
Xint set_flt_trnarr(TRANS_MATRX trnsar,
X                   char *cdn,
X                   float xval);
X/* put xval into relevent codon positions data struct. Wild card *
X  causes all nonzero values to be initialized */
X
XTRN_MATELT *sqt_vect2eltaddr(TRANS_MATRX tm,
X                             CODN_VECTR cv);
X/* return the address of the array element corresponding to cv */
X
Xint sqt_cdn2codvect(char *cdn,
X                    CODN_VECTR cv);
X/* convert cdn to cv. return 1 if all bases OK, else 0 */
X
Xint sqt_codvect2cdn(CODN_VECTR cv,
X                    char *cdn);
X/* convert cv to corresponding codon in cdn (presumed to be big enough)
X  return 1 if all of codon is valid, 0 otherwise */
X
Xint sqt_cdnno2cdn(int cno,
X                  char *cdnbuf);
X/* write to cdnbuf (assumed to be
XCODONLENGTH+1 chars or longer) he codon corresponding to
Xenumerated codon cno (0..63). return 1 if OK, else 0 */
X
XTRN_MATELT *sqt_cdnno2codvect(TRANS_MATRX tmat,
X                              int cno,
X                              char *ucdn);
X/* if cno is valid, return the vector pointer
Xfor it for translation table tmat.  NULL if
Xcan't.  If ucdn is non-NULL, write the codon
Xto it (assumes enough room) */
X
Xchar sqt_trnslate(TRANS_MATRX trnsar,
X                  char *cdn);
X/* translate cdn according to trnsar */
X
Xint sqt_get_int4tmatrix(TRANS_MATRX trnsar,
X                        char *cdn);
X/* return integer value for  cdn according to trnsar.
Xreturn 0 if not integer datum */
X
Xfloat sqt_get_flt4tmatrix(TRANS_MATRX trnsar,
X                          char *cdn);
X/* return the float value for translate cdn according to trnsar.
X0.0 if not float datum */
X
Xvoid sqt_inc_cdncnt(TRANS_MATRX trnsar,
X                    char *cdn);
X/* increment iresidue for cdn */
X
Xvoid init_univ(TRANS_MATRX trnsar);
X  /* fill trnsar with codes for universal genetic code */
X
Xvoid init_trnsar4gb(TRANS_MATRX trnsar,
X                    SQT_GENCOD gencod);
X/* initialize trnsar to any known genetic code - using Genbank trans-table
X  values */
X
Xchar init_trnsar4chr(TRANS_MATRX trnsar,
X                     char gencod);
X/* initialize trnsar to any known genetic code, according to following:
Xu = universal, m = mammalian mitochondrial, y = yeast mitochondrial,
Xa = aspergillus/Neurospora and Trypansoma mitochondrial,
Xd = drosophila mitochondrial
X
Xreturn character, if valid, else null. */
X
Xint uniquecdn(char *cdn);
X  /* return a unique nonzero numeric score for this codon.
X  only if all elements are A,C,G,T.  Else return 0 */
X
Xint validcdn(char *cdn);
X  /* return true if this codon is valid.  only if all elements
X   are A,C,G,T, or *. */
X
Xint sqt_getnxtcdn(char *src,
X                  int slen,
X                  int *sqpos,
X                  char *cdn);
X/* fill cdn from sqpos of src, return no of chars written.  
X Stop on null byte or when slen is reached.
X cdn should allow room for null byte.
X *sqpos is 0..n-1 */
X
Xint sqt_transbuffer(char *src,
X                    int slen,
X                    TRANS_MATRX gencod,
X                    char *dst);
X/* translate sequence in src to dst (which will be assumed to be long enough.
X  stop on encountering null or slen has been translated */
X
Xvoid sqt_inivectarr(COD_VECT_STRCT **cvs);
X  /* initialise all cvs aa vectors to null */
X
XCOD_VECT_STRCT *sqt_appnd_cvect(COD_VECT_STRCT **cvp,
X                                CODN_VECTR cv);
X/* append this vector to *cvp.  Return a pointer to the new component, NULL
X if problem */
X
XCOD_VECT_STRCT *sqt_appndcdn2vec(COD_VECT_STRCT **cvp,
X                                 char *cdn);
X/* append a vector for cdn to *cvp assuming it is a valid codon.
X  Return a pointer to the new component, NULL if problem */
X
Xint sqt_bldvects4matrx(TRANS_MATRX tmtx,
X                       COD_VECT_STRCT **cvecs);
X/* build a set of vectors in cvecs for the translation matrix tmtx.
Xreturn the number of vectors added */
X
Xvoid sqt_clrvectarr(COD_VECT_STRCT **cvarr);
X  /* clear all of vectors for all aas */
X
XCOD_VECT_STRCT *sqt_getvect4res(COD_VECT_STRCT **cvlist,
X                                char aares,
X                                COD_VECT_STRCT *cvp);
X/* if cvp = NULL, then return the first vector in the linked list for residue
Xaares.  if cvp is non-null, return the next codon vector in the linked list */
X
XCOD_VECT_STRCT *sqt_ptr4cvec(COD_VECT_STRCT *clst,
X                             CODN_VECTR cv);
X/* return a pointer to the element of clst which matches cv.  NULL if none */
X
Xint sqt_codnbas4res(COD_VECT_STRCT **cvlist,
X                    char aares,
X                    int cpos,
X                    char *cdn,
X                    char *cstrng);
X/* return a number of base choices for position cpos (1..3) of the
Xcodons for aares.  Return bases in cstrng if non-NULL, 
Xassumed to be large enough for the purpose.
XError returns: -2 = cpos ivalid, -1 = invalid aares.
XIf the codon seen so far is present as cdn, then this information is used in
Xrefining the output (Esp for Ser, etc in the standard genetic code */
X
XCOD_VECT_STRCT **sqt_getcvctarr(char *msg);
X  /* allocate storage for a MAXAAINT-long array of pointers */
X
Xvoid sqt_sumintmatrx(TRANS_MATRX m1,
X                     TRANS_MATRX m2,
X                     TRANS_MATRX sum);
X/* sum each element of m1 and m2 into sum */
X
Xint sqt_totvldicnts(TRANS_MATRX tmat);
X  /* for all valid positions in tmat, sum the integer counts */
X
Xint sqt_gcodexfl(FILE *fl,
X                 TRANS_MATRX tmat);
X/* read CODONS/RES from fl and load into tmat, return no of valid codons read.
Xfields starting with ';' are regarded as comments */
X
Xvoid say_intcdn(FILE *strm,
X                int p1,
X                int p2,
X                int p3);
X/* tell strm the character representation of the codon (p1,p2,p3) */
X
Xvoid sqt_gcod2fl(FILE *fl,
X                 char *desc,
X                 TRANS_MATRX tmat);
X/* write tmat contents to fl in approved form.  desc written as leading
Xcomment if non-NULL */
X
XCOD_VECT_STRCT *sqt_maxintval4cvec(TRANS_MATRX tm,
X                                   COD_VECT_STRCT *c1,
X                                   COD_VECT_STRCT *c2);
X/* compare integer value for tm values of c1,c2, returning
Xthe larger.  if c1 or c2 is NULL, return the other. NULL
Xif cockup */
X
XCOD_VECT_STRCT *sqt_minintval4cvec(TRANS_MATRX tm,
X                                   COD_VECT_STRCT *c1,
X                                   COD_VECT_STRCT *c2);
X/* compare integer value for tm values of c1,c2, returning
Xthe larger.  if c1 or c2 is NULL, return the other. NULL
Xif cockup */
X
XCOD_VECT_STRCT *sqt_scnveclst(COD_VECT_STRCT *clst,
X                              TRANS_MATRX tm,
X                              COD_VECT_STRCT *(*cmpfun)(TRANS_MATRX tx,
X                                                        COD_VECT_STRCT *c1,
X                                                        COD_VECT_STRCT *c2));
X/* Scan thru clst... using tm and cmpfun to decide on best
Xvector in list.  cmpfun will return which ever of c1,c2 is "better"
X*/
X
Xint sqt_vectrsequal(COD_VECT_STRCT *c1,
X                    COD_VECT_STRCT *c2);
X/* return 1 if c1 & c2 are the same */
X
Xint sqt_tmatival4cvecp(TRANS_MATRX tm,
X                       COD_VECT_STRCT *cvp,
X                       SQTRN_DATYPE *dtp);
X/* simply return the integer value for the
Xcvp postion of tm.  0 if not an integer value.
Xif dtp is non-NULL, then return the data type
Xto it */
END-of-meth_progs_dist/include/sqtrans.h
echo x - meth_progs_dist/include/wlu_fns.h
sed 's/^X//' >meth_progs_dist/include/wlu_fns.h << 'END-of-meth_progs_dist/include/wlu_fns.h'
X/* wlu_fns.h: headers for fast word lookup routines (for command processing )
X */
X
X#define WLU_CASEDEP 0
X#define WLU_CASEIND 1
X#define WLU_CASEWILD -1
X
Xtypedef struct Wrd_lu_rec
X  {    /* basic structure for looking up words quickly */
X  char *wrd;         /* this word */
X  void *retval;      /* value to be returned */
X  struct Wrd_lu_rec *nextiwrd;  /* next word same initial */
X  char *helpline;    /* line of help info: can be NULL */
X  }
XWRD_LU_REC;
X
Xtypedef struct Wrd_lustruct /* info for building word lookup */
X  {
X  int casedep;          /* 0 => case depend, 1 case independ, -1 wild card */
X  int failret;          /* value returned on failure */
X  WRD_LU_REC **firstlet; /* array of first occurence of init letters */
X  WRD_LU_REC **lastlet;  /* array of last occurrence of first letters */
X  }
XWRD_LUSTRCT;
X
X#define MAXASCIIVAL 127  /* max 7 bit ascii value */
X
Xtypedef int WLU_CHRLUTBL[MAXASCIIVAL+1]; 
X
X/* function headers */
X
Xint wlu_no_inits(int cased);
X  /* return the number of initials for
X  cased: 0 => case depend, 1 case independ, -1 wild card */
X
Xvoid wlu_initlustrct(WRD_LUSTRCT *wlus,
X                     int cased,
X                     int failval);
X/*  init wlus values prior to loading words
X  cased: 0 => case depend, 1 case independ, -1 wild card */
X
Xint wlu_init2offst(int cased,
X                   char initc);
X/* return a numerical offset for initc, depending on
X cased:  0 => case depend, 1 case independ, -1 wild card */
X
Xvoid wlu_addwrdptr(WRD_LUSTRCT *wlus,
X                   char *newwrd,
X                   void *newval,
X                   char *hlpline);
X/* add newwrd to lookup structure.  No check is performed for multiple
X  insertions */
X
Xvoid wlu_addwrd(WRD_LUSTRCT *wlus,
X                char *newwrd,
X                int newval,
X                char *hlpline);
X/* add newwrd to lookup structure.  No check is performed for multiple
X  insertions */
X
Xvoid wlu_addintgrs(WRD_LUSTRCT *wlus,
X                   int newint,
X                   int newval,
X                   char *hlpline);
X/* add newint as a string to lookup structure, returning newval.
X  No check is performed for multiple insertions */
X
Xvoid wlu_addintgr(WRD_LUSTRCT *wlus,
X                  int newval,
X                  char *hlpline);
X/* add newval as a string to lookup structure, returning newval.
X  No check is performed for multiple insertions */
X
Xint wlu_delwrd(WRD_LUSTRCT *wlus,
X               char *swrd);
X/* delete the first entry related to swrd from *wlus, return 1 if found &
Xdeleted */
X
Xint wlu_delint(WRD_LUSTRCT *wlus,
X               int di);
X/* delete the first entry related to int di from *wlus, return 1 if found &
Xdeleted */
X
Xint wlu_cntwldmats(WRD_LU_REC *wrpt,
X                   char *uwrd,
X                   int wlen);
X/* return count of words which match this one upto wlen chars in linked
X  list wrpt */
X
XWRD_LU_REC *wlu_lulst4wrd(WRD_LUSTRCT *wlus,
X                          char *uwrd);
X/* return the start of the list containing this word */
X
XWRD_LU_REC *wlu_lurec4wrd(WRD_LUSTRCT *wlus,
X                          WRD_LU_REC *wlst,
X                          char *uwrd);
X/* scan wlst for uwrd, return the first match found, NULL if not */
X
XWRD_LU_REC *wlu_wrd2lurec(WRD_LUSTRCT *wlus,
X                          char *uwrd);
X/* return the pointer to the lu_rec for uwrd, NULL if non-existent */
X
Xvoid *wlu_chkwrdptr(WRD_LUSTRCT *wlus,
X                    char *uwrd);
X/* check for uwrd in wlus word look up structure.  if not found return NULL
Xvalue else return the set parameter.  word comparisons are based on case
X  dependency setting */
X
Xint wlu_chkwrd(WRD_LUSTRCT *wlus,
X               char *uwrd);
X/* check for uwrd in wlus word look up structure.  if not found return failret
Xvalue else return the set parameter.  word comparisons are based on case
X  dependency setting */
X
Xint wlu_chkint(WRD_LUSTRCT *wlus,
X               int uvl);
X/* check for uvl in wlus word look up structure. */
X
Xvoid wlu_clrlustrct(WRD_LUSTRCT *wlu);
X  /* relinquish malloced memory for wlu lists */
X
Xvoid wlu_clralllustrct(WRD_LUSTRCT *wlu);
X  /* relinquish malloced memory for wlu lists and wlu itself */
X
Xvoid wlu_maktoklu(WLU_CHRLUTBL utbl,
X                  char *luchrs);
X  /* allocate and create a character look up table (7 bit ascii only),
X with chars in luchrs */
X
Xvoid wlu_makcmptoklu(WLU_CHRLUTBL utbl,
X                     char *luchrs);
X/* create a character look up table (7 bit ascii only),
Xfor chars NOT in luchrs */
X
Xint wlu_gettokensep(FILE *fl,
X                    char *ubuf,
X                    int blen,
X                    WLU_CHRLUTBL stbl,
X                    char *schr);
X/* pull next token from fl, write into ubuf, upto blen.  sbtl is a 
Xtable of ascii values of token separators. if *schr non-NULL, then set it
Xto the separating char */
X
Xint wlu_gettoken(FILE *fl,
X                 char *ubuf,
X                 int blen,
X                 WLU_CHRLUTBL stbl);
X/* pull next token from fl, write into ubuf, upto blen.  sbtl is a 
Xtable of ascii values of token separators */
X
Xint wlu_sgettokensep(char *src,
X                     int *sp,
X                     char *ubuf,
X                     int blen,
X                     WLU_CHRLUTBL stbl,
X                     char *schr);
X/* pull next token from src at *sp, write into ubuf, upto blen.  *sp is
Xincremented.  sbtl is a 
Xtable of ascii values of token separators. if *schr non-NULL, then set it
Xto the separating char */
X
Xint wlu_sgettoken(char *src,
X                  int *sp,
X                  char *ubuf,
X                  int blen,
X                  WLU_CHRLUTBL stbl);
X/* pull next token from src at *sp (incremented), write into ubuf, 
X  upto blen.  sbtl is a 
X  table of ascii values of token separators */
X
Xint wlu_newstrng(WRD_LUSTRCT *wlus,
X                 char *swrd,
X                 char *newlin);
X/* insert newlin in place of existing (if any) text line for swrd.  Return
X1 if OK, 0 if swrd is not in wlus */
X
Xint wlu_newstr4int(WRD_LUSTRCT *wlus,
X                   int sint,
X                   char *newlin);
X/* insert newlin in place of existing (if any) text line for sint.  Return
X1 if OK, 0 if swrd is not in wlus */
X
XWRD_LUSTRCT *wlu_getmnthwrds();
X  /* return a wlu table that will convert 3 letter month names into
Xcorresponding integers in case-independent manner */
X
Xvoid wlu_dsplymenu(FILE *fl,
X                   WRD_LUSTRCT *menu);
X/* display the existing contents of *menu */
X
Xvoid wlu_dbgwlustrct(FILE *fl,
X                     WRD_LUSTRCT *menu,
X                     char *msg);
X/* tell fl about contents of *menu for diagnostic purposes */
X
Xint wlu_maxwrdlen(WRD_LUSTRCT *wlus);
X  /* return the length of the longest string in wlus */
X
Xint wlu_initwrdscan(WRD_LUSTRCT *wls,
X                    int *ap,
X                    WRD_LU_REC **rp);
X/* set initial values of ap & *rp, return true if it worked */
X
XWRD_LU_REC *wlu_nxtwrd(WRD_LUSTRCT *wls,
X                       int *ap,
X                       WRD_LU_REC *rprv);
X/* given a pointer rprv, return the next element, if necessary, *ap is
Xincremented and the element taken from there.  NULL for no more */
END-of-meth_progs_dist/include/wlu_fns.h
echo x - meth_progs_dist/meth_progs_readme.txt
sed 's/^X//' >meth_progs_dist/meth_progs_readme.txt << 'END-of-meth_progs_dist/meth_progs_readme.txt'
X	  Programs and Scripts for Bisulphite Sequence Data
X
XPeter A. Stockwell
XDept of Biochemistry,
XUniversity of Otago,
XDunedin, New Zealand.
X
Xpeter.stockwell@otago.ac.nz
X
X----------------------------------------------------------------------
X
X
Xrmapbsbed2cpg
Xbin_cnts
Xscan_cpg_depth
Xmkrrgenome
Xcleanadaptors
X
Xillum2fasta.awk
Xmk4to1lines.awk
Xbismmethex2list.awk
Xtidyrrnams.awk
X
XThese programs have been written in the course of work on differential
XCpG methylation of the human genome and represent a series of tools
Xfor preparing, modifying and analysing these data.  The work has
Xparticularly focussed on reduced representation (RR) bisulphite
Xsequencing (RRBS) as in Meissner, et al., 2008, Nature, 454, 766-770,
XSmith, et al., 2009) Methods, 48, 226-232 and Gu, et al., 2011, Nature
XProtocols, 6, 468-481.  This software should, none-the-less, have
Xwider application than that.
X
XThis is research software so that it is not necessarily easy to use,
Xalthough it should work correctly as intended.  It works from a Unix
X(MacOS X) or Linux command line interface: the notes below describe the
Xfunctionality and format of intermediate files where appropriate.
XThis code has been generated and tested on a MacOS X system (10.6)
Xusing gcc v4.2.1 and on various Linux platforms (RedHat, Centos,
XFedora, Ubuntu) but is written to compile and run on any appropriate
XC compiler and environment.  The size of files and data required for
Xthis work will generally require a 64 bit environment.  Awk scripts
Xhave been developed for the Gnu AWK (gawk) distributed with MacOS X
Xbut, again, they should run in other comparable environments.
X
X----------------------------------------------------------------------
X		 Unpacking and building instructions:
X
XDistribution: source code is encorporated into a self-extracting
Xshell archive which can be run with /bin/sh, or equivalent, to
Xgenerate the complete sources and Makefile.  The distributed form is a
Xfile meth_progs_dist.shar which is unpacked by:
X
X/bin/sh meth_progs_dist.shar
X
Xgenerating a directory meth_progs_dist containing two directories:
Xinclude, containing some of the generic header files and src
Xcontaining the rest of the source code and Makefile.  The set can be
Xbuilt with the following commands:
X
Xcd meth_progs_dist/src
Xmake
X
Xor
X
Xmake CFLGS=-O3
X
Xto optimise the code.  Some warnings may appear but these can be
Xignored.  The executables will be in the src directory - no install
Xtargets are provided, the completed executables (rmapbsbed2cpg
Xbin_cnts scan_cpg_depth mkrrgenome cleanadaptors) should be manually
Xcopied to an appropriate directory (e.g. /usr/local/bin).  The awk
Xscripts are in the src directory and may similarly be copied somewhere
Xuseful.
X
XDocumentation for the set is present in the file progs_doc.txt which
Xresides in the top level of the directories.
END-of-meth_progs_dist/meth_progs_readme.txt
echo x - meth_progs_dist/progs_doc.txt
sed 's/^X//' >meth_progs_dist/progs_doc.txt << 'END-of-meth_progs_dist/progs_doc.txt'
X	  Programs and Scripts for Bisulphite Sequence Data
X
XPeter A. Stockwell
XDept of Biochemistry,
XUniversity of Otago,
XDunedin, New Zealand.
X
Xpeter.stockwell@otago.ac.nz
X
X16-Nov-2011
X----------------------------------------------------------------------
X
Xrmapbsbed2cpg
Xbin_cnts
Xscan_cpg_depth
Xmkrrgenome
Xcleanadaptors
X
Xillum2fasta.awk
Xmk4to1lines.awk
Xbismmethex2list.awk
Xtidyrrnams.awk
X
XThese programs have been written in the course of work on differential
XCpG methylation of the human genome and represent a series of tools
Xfor preparing, modifying and analysing these data.  The work has
Xparticularly focussed on reduced representation (RR) bisulphite
Xsequencing (RRBS) as in Meissner, et al., 2008, Nature, 454, 766-770,
XSmith, et al., 2009) Methods, 48, 226-232 and Gu, et al., 2011, Nature
XProtocols, 6, 468-481.  This software should, none-the-less, have
Xwider application than that.
X
XThis is research software so that it is not necessarily easy to use,
Xalthough it should work correctly as intended.  It works from a Unix
X(MacOS X) or Linux command line interface: the notes below describe the
Xfunctionality and format of intermediate files where appropriate.
XThis code has been generated and tested on a MacOS X system (10.6)
Xusing gcc v4.2.1 and on various Linux platforms (RedHat, Centos,
XFedora, Ubuntu) but is written to compile and run on any appropriate
XC compiler and environment.  The size of files and data required for
Xthis work will generally require a 64 bit environment.  Awk scripts
Xhave been developed for the Gnu AWK (gawk) distributed with MacOS X
Xbut, again, they should run in other comparable environments.
X
XDistribution: source code is encorporated into a self-extracting
Xshell archive which can be run with /bin/sh, or equivalent, to
Xgenerate the complete sources and Makefile.  The distributed form is a
Xfile meth_progs_dist.shar which is unpacked by:
X
X/bin/sh meth_progs_dist.shar
X
Xgenerating a directory meth_progs_dist containing two directories:
Xinclude, containing some of the generic header files and src
Xcontaining the rest of the source code and Makefile.  The set can be
Xbuilt with the following commands:
X
Xcd meth_progs_dist/src
Xmake
X
Xor
X
Xmake CFLGS=-O3
X
Xto optimise the code.  Some warnings may appear but these can be
Xignored.  The executables will be in the src directory - no install
Xtargets are provided, the completed executables (rmapbsbed2cpg
Xbin_cnts scan_cpg_depth mkrrgenome cleanadaptors) should be manually
Xcopied to an appropriate directory (e.g. /usr/local/bin).  The awk
Xscripts are in the src directory and may similarly be copied somewhere
Xuseful.
X
X----------------------------------------------------------------------
Xrmapbsbed2cpg
X
XConverts a rmapbs BED file or a bsmap output file to a tab-separated
Xlist of Chromosome Position Methylation_status where: 
X
XChromosome is one of 1,2,3..22,X,Y
XPosition is an integer
XMethylation_status is + or -
X
XThis form is suitable for reading into SeqMonk [Text (Generic) format]
Xor for other programs in this set (cnt_cpg_bins, scan_cpg_depth).
X
XFormat of the source files is as documented for the Rmap programs
X(Smith, et al. 2008, BMC Bioinformatics, 9, 128-135.).  The format for
Xbsmap 1.02 is approximately as documented in the README.txt
Xdistributed with that program (Xi & Li, 2009, BMC Bioinformatics, 10,
X232-240), although the actual output is not wholly consistent with
Xtheir notes.  Further, the output format has been changed at some
Xpoint, bsmap 1.2 output is now accepted.
X
Xrmapbsbed2cpg expects either a file of reads in FASTQ format or in
XFASTA format with a single entry for each read, and with no quality
Xinformation.  The included script illum2fasta.awk will generate such a
Xfile from the FASTQ original, noting that the header for each sequence
Xis shortened in the following way:
X
XHWI-EAS209_0006_FC706VJ:1:4:1135:18558#0/1
X
Xbecomes:
X
X>S1_4_1135_185558
X
Xor generally
X
X>S{LaneNo}_{TileNo}_{Xpixel}_{Ypixel}
X
Xso that each read can be related back to its original FASTQ form.
X
Xrmapbsbed2cpg will now correctly manage HiSeq flowcells with different
Xtile numbers from the original GAII flowcells.  Also V3 of the
Xchemistry is managed (see -v and -V) options.
X
XChromosome sequences are expected as FASTA files with a single entry
Xfor each chromosome in its own file (as for the GRCh37 build used by
XBismark/SeqMonk).  Each chromosome file name should end <n>.fa where
X<n> is 1,2,3..22,X,Y.  The program allows for the complete set to be
Xaddressed by an absolute or relative path (e.g. 
X/Volumes/SomeDiskName/HomoSapiens_genome/hs_ref_GRCh37/Homo_sapiens.GRCh37.59.dna.chromosome.
Xor ../../WhereIPutThem/Homo_sapiens.GRCh37.59.dna.chromosome. ).
X
XProgram Options:
X
Xrmapbsbed2cpg (v2.31): generate list of CpG positions from rmapbs BED file
XOptions:
X     -r <readfile> reads from Fasta fmt. <readfile>
X     -R <readfile> reads from fastq <readfile>
X     -v HiSeq V3 flowcell, V2 chemistry (def V2 GAII flowcell)
X     -V HiSeq V3 flowcell, V3 chemistry (def V2 GAII flowcell)
X     -b <bedfile> read match information from <bedfile> (rmapbs bed format)
X     -B <bsmapfile> read match information from <bsmapfile> (bsmap V1.02 output format)
X     -A <bsmapfile> read match information from <bsmapfile> (bsmap V1.2 output format)
X     -p <posfile> read RR sections (mkrrgenome -m output) from <posfile>, count hits/misses
X     -g <genomehead> dir and file string to locate genomic seq files by adding n.fa
X
X-v & -V interpret tile numbers as for HiSeq flowcells, versions 2 & 3
Xchemistry, respectively.  By default GAII flowcells are expected with
Xtile numbers 1..120.  When the other options are selected, the program
Xremaps the file numbers 1101..2308 to successive integer values in
Xorder to minimise internal array dimensions.
X
XOutput is to stdout.
X
XThe program works by loading the reads into a series of linked lists
Xby tile number.  Each chromosome is read into a long string in RAM,
Xpre-malloc()ed to contain an adequately long sequence.  The aligned
Xread information from the BED or bsmap files is read and the
Xpositional information is used to set start & stop locations for each
Xread in the tile-based linked list repository.  Difficulty was
Xencountered with bsmap runs where some run options will generate
Xshortened read alignments and for which out-by-one position errors
Xwere evident.  Shortened reads require that the original FASTA file
Xsequence read is replaced by the actual bsmap-returned alignment read
Xand appropriate position corrections made.
X
XThe program uses linked lists in order to prevent array-length limits
Xfrom restricting operation arbitrarily and between that and the need
Xto store the complete sequence of each chromosome poses large RAM
Xrequirements.  Linear scanning through linked lists also takes time
Xand while strategies could be devised to improve this performance, the
Xpresent execution time and RAM needs are acceptable.  Running some
X15e06 reads against the human genome on the development machine (Mac
XPro, Duo Quad Core 2.8GHz) takes several hours and requires some 8Gb
XRAM.  (The code is single threaded and does not, itself, benefit from
Xmultiple cores.)
X
XA typical run might look like
X
Xrmapbsbed2cpg -r myfastafmtreads.fa -b rmapbsoutput.bed -g
X/Volumes/VMWare/HomoSapiens_genome/hs_ref_GRCh37/Homo_sapiens.GRCh37.59.dna.chromosome. >
Xmyrmapbscpglist.txt
X
Xwhere the whole command is complete on one line.
X
X----------------------------------------------------------------------
Xbin_cnts:
X
XStill under significant development: to take CpG positions as
Xgenerated by rmapbsbed2cpg or the Bismark methylation_extractor
Xprograms and store the counts in a series of bins which are generated
Xin a series of different ways.  The program further aims to produce
Xfigures for differential methylation by the method of Li, et al.
X(2010, PLOSBiology,11,e1000533) and contains procedures to assist with
Xbin selection for that.  RRBS based bin selection is supported and the
Xprogram output allows either the contents of such bins to be listed
Xor, optionally, for the counts which miss such bins to be shown, in
Xorder to indicate when aligners are mapping reads outside expected RR
Xregions.  The program is also capable of generating pseudo feature
Xtable information for SeqMonk so that RR genomes can be annotated with
XRR fragment positions.
X
XThe source file(s) for -r & -R options are as generated by
Xrmapbsbed2cpg.
X
XChromosome source files (-g option) are specified as for
Xrmapbsbed2cpg.
X
XOptions:
X
Xbin_cnts: create binned counts for chromosomal positions
XOptions:
X     -r <posfile> read <posfile> as set of chr posit strand/meth
X     -R <posfile2> as -r but for 2nd position file
X     -b <binlength>: set bin length (def=1000)
X     -g <genomehead> dir and file string to locate genomic seq files by adding n.fa
X     -l/-L list bins (-L=>only nonzero bins)
X     -m scan for diff meth regions restricted rep (Li, et al. (2010) PLOSBiology,11,e1000533)
X     -M <j,k> scan for restricted rep fragment sizes between j & k residues. Make bins
X     -N as for -M but list bins to stdout
X     -k as for -M, but note reads which don't map into restricted rep bins
X     -K as for -k, but only print totals for meth & unmeth counts
X     -S <dirheader> write .dat files to <dirheader> for RR genome for SeqMonk
X     -c <n> restrict effort to Chromosome <n> (def = all chromosomes)
X     -C <n> restrict bins to those with <n> or more CpGs
X     -A attempt to amalgamate restr rep regions that might otherwise fail CpG criteria
X(     -x <excludefile> exclude regions (fmt: Chrno regionstart
Xregionend) 
X
XOutput is generally to stdout, excepting the -S option.
X
XThe -c option to restrict operation to a single selected chromosome is
Xreally only for developing the program in order to speed up checking
Xits operation.
X
XThe -M, -N, -k & -K options use the MspI recognition/cleavage site
XC^CGG and the j,k size range to select valid fragments.  If either j
Xor k is zero, then that limit is not applied (e.g. -M 0,220 will
Xinclude all MspI fragments from zero to 220 residues; -m 50,0 will
Xinclude all fragments over 50 residues).  Note that the program
Xapplies the limits precisely whereas fragment size selection on a gel
Xwill never be so exact.
X
XThe -x option to exclude some chromosomal regions has not been
Ximplemented yet.
X
XDifferential methylation (-m option) is yet to be implemented.
X
XLike rmapbsbed2cpg, bin_cnts used linked lists for internal data
Xstorage in order to avoid arbitrary limits.  The strategy for scanning
Xgenomic sequences for CCGG and CpG sites avoids the need to load
Xchromosome sequences into RAM.  The consequences are that bin_cnts has
Xa lesser memory footprint that rmapbsbed2cpg although moderate run
Xtimes can be expected.
X
XTypical use might be:
X
Xbin_cnts -r myrmapbscpglist.txt -g
X/Volumes/VMWare/HomoSapiens_genome/hs_ref_GRCh37/Homo_sapiens.GRCh37.59.dna.chromosome.
X-M 40,220 -L > mynonzero40_220bins.cnts
X
Xwill list the nonzero bins for 40 to 220 bp MspI fragments to a file
Xmynonzero40_220bins.cnts.
X
Xbin_cnts -r myrmapbscpglist.txt -g
X/Volumes/VMWare/HomoSapiens_genome/hs_ref_GRCh37/Homo_sapiens.GRCh37.59.dna.chromosome.
X-k 40,220 > missed40_220bins.cnts
X
Xwill list bins which contain counts that don't fit in the 40-220 RR
Xgenome bins.
X
Xbin_cnts -r myrmapbscpglist.txt -g
X/Volumes/VMWare/HomoSapiens_genome/hs_ref_GRCh37/Homo_sapiens.GRCh37.59.dna.chromosome.
X-K 40,220
X
Xwill return to stdout (terminal) methylated and unmethylated total counts
Xwhich miss the RR genome bins.
X
X----------------------------------------------------------------------
Xscan_cpg_depth:
X
XScans for the read depth of CpG positions on the genome.  Also will
Xlist reads which don't map to CpGs in order to track down problems.
XReturned information is a raw list of CpG positions with the counts,
Xstatistics (mean, median and mode and standard deviation of count
Xdistribution) or a histogram of count frequencies.
X
XThe source file (-r option) is as generated by rmapbsbed2cpg.
X
XChromosome source files (-g option) are specified as for
Xrmapbsbed2cpg.
X
Xscan_cpg_depth: scan for CpG read depth for all or selected chromosomes
XOptions:
X     -r <posfile> read <posfile> as set of chr posit strand/meth
X     -g <genomehead> dir and file string to locate genomic seq files by adding n.fa
X     -C <m> use cluster size of <m> for chromosome positions, Def=1000
X     -l list each CpG to stdout with counts
X     -c <n> restrict to Chromosome <n> 1..22,X,Y. Def=all
X     -p Permit out-by-one positions (e.g. Bismark complementary strand CpGs) def=don't
X     -S generate statistics (range, mean, std deviation, etc. for counts
X     -H generate histogram of counts
X     -m list missed CpG lines
X     -n list CpG hits (Nonmisses)
X     -z omit zero count from histogram
X
XOutput is to stdout.
X
XThe -C clustersize option is to control the scheme which allows rapid
Xlookups into the linked lists of chromosomal CpG positions to prevent
Xthe program from taking excessively long to execute.  The default
Xcluster size is 1000, decreasing it will increase the memory
Xrequirements, but decrease execution time.  Conversely...
X
XThe genome files are specified by the -g option, as above.
X
X-l will generate a very lengthy list of CpG positions and the + & -
Xcounts for each.
X
X-S generates statistics for the depth of hits at each CpG.  Note that
Xthis presently includes the 0 count bin which probably produces
Xmisleading values, since typical RR runs will not hit all CpGs.
X
X-H produces a printer-type histogram of count frequencies.  Since the
Xzero count bin will always contain unhitable CpGs, the -z option is
Xoffered to scale the histogram to the highest non-zero count.  Note
Xthat the statistics output (-S) is not altered by -z.
X
XFor diagnostic purposes, the -m and -n options are given to produce a
Xlist of the missed or hit positions respectively before other output
Xoptions are processed.
X
XFor reads pairing to the complementary sequence some aligners
X(e.g. Bismark v 0.2.3 methylation_extractor) produce alignment
Xpositions that are out-by-one.  The -p option will permit positions to
Xbe out by one residue in order to use all of the read data.
X
Xe.g.:
X
X----------------------------------------------------------------------
Xmkrrgenome:
X
XScans fasta files for MspI (C^CGG) cleavage positions and concatenates
Xthe fragments for each chromosome which fit into a specified size
Xrange into a single contiguous sequence in a fasta file.  Optionally
Xgenerates a list of those positions.
X
Xmkrrgenome (v1.00: generate reduced representation genome files for MspI digests)
XOptions:
X     -g <genomehead> dir and file string to locate genomic seq files by adding n.fa
X     -c <C_no> restrict activity to chromosome C_no (1..22,X,Y), def = all
X     -M <j,k> scan for restricted rep fragment sizes between j & k residues. (def=40..220)
X     -m <j,k>   ditto, produce tab delimited list of positions to stdout
X     -G <desthead> dir & file string for output genome files (-M), completed with n.fa
X
XInput files are specified with the -g option as previously.
X
XOutput is to a fasta file for each chromosome processed - the pathname
Xand initial file name for the whole series is specified by the -G
Xoption.
X
XDesired fragment size is specified for the -M option as two
Xcomma-separated values for the minimum and maximum values.  Giving a 0
Xas one of the values will disable that comparison so that, for
Xinstance, -M 0,150 will use all fragments up to 150 bp while -M 40,0
Xwill save all fragments over 40 bp.
X
XSimilar specifications apply to the -m listing of fragments to stdout.
X
Xmkrrgenome uses a finite-state-machine (FSM) method for the rapid
Xscanning of chromosomal sequences for CCGG sites and for quantifying
XCpGs.
X
Xe.g.: 
X
Xmkrrgenome -g \
X/Volumes/Human_genome/GRCh37/Homo_sapiens.GRCh37.59.dna.chromosome. \
X-M 20,240 -G myRR_20_240genome/rrChr
X
Xwill process each of the files
XHomo_sapiens.GRCh37.59.dna.chromosome.1.fa, etc. to a RR genome for
Xsize 10..240 MspI fragments saving each chromosome as rrChr1.fa,
Xetc. in the local directory myRR_20_240genome.  The fasta headers will
Xresemble:
X
X>1rr reduced repr 20..240 for MspI digest Chr1 7215473/249250621bp CpG: 413964
X
Xor e.g.:
X
Xmkrrgenome -g \
X/Volumes/Human_genome/GRCh37/Homo_sapiens.GRCh37.59.dna.chromosome. \
X-c 22 -m 20,240
X
Xwill generate a listing with a line for each MspI fragment in the size
Xrange 20..240 bp of chromosome 22 like:
X
X22	16054424..16054453 (30 bp) CpG: 3
X22	16060689..16060841 (153 bp) CpG: 2
X22	16075293..16075412 (120 bp) CpG: 3
X22	16075413..16075526 (114 bp) CpG: 2
X22	16075527..16075627 (101 bp) CpG: 5
X22	16085649..16085716 (68 bp) CpG: 4
X22	16086414..16086578 (165 bp) CpG: 3
X22	16086912..16086959 (48 bp) CpG: 2
X22	16094410..16094476 (67 bp) CpG: 3
X22	16096038..16096177 (140 bp) CpG: 7
X
X----------------------------------------------------------------------
Xcleanadaptors:
X
XCheck FASTQ or FASTA files for Illumina adaptor sequences and trim
Xthem if desired.  The use of short RR libraries can result in longer
XIllumina reads sequencing through into the adaptor sequence giving
Xreads that may fail to align even although the pre-adaptor section is
Xvalid.  Alternatively, if reads containing a significant length of
Xadaptor succeed in aligning then they are more likely to be
Xerroneously placed and will contribute unwanted bias to analyses.
X
Xcleanadaptors uses a finite-state-machine to
Xprovide a very efficient means of finding leading fragments of adaptor
Xsequences, then completes the checks by comparing the trailing
Xsequence with the whole adaptor to ensure that a reasonable degree of
Xsimilarity is achieved.  Since read qualities deterioriate at higher
Xcycle numbers, complete matching is not expected.
X
XOutput options include listing the source data with adaptor matches
Xindicated in the listing (-f), or to have the reads trimmed to remove
Xany adaptor sequences which achieve criteria for matching (-F).  In
Xorder to trace operation of the program, match listings can show only
Xreads which do match (-H).
X
Xcleanadaptors v1.04: scan Illumina reads for adaptor seqs: Trim FASTA/FASTQ files
XOptions:
X     -i <adaptorfile> file of adaptor seqs 1/line)
X         (def="AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGATC": 40bp of Universal adaptor)
X     -l max adaptor length (def=256)
X     -m min leading match for adaptor (def=6)
X     -M margin at read end for trimming (def=0)
X     -R readfile buffer length (def=256)
X     -s <skipres> skip <skipres> on each read before checking matches
X     -p <%> % match threshold with adaptor sequence for hit (def=75.0%)
X     -S enable single base mismatches (def=disallow)
X     -L print fsm to stdout
X     -F <readfile>: run scan on <readfile> FASTQ/FASTA fmt, trim matching ends
X     -z <readfile>: as -F but don't check length of trimmed reads
X     -x <lengthlimit>: only save trimmed reads exceeding length limit (def=1)
X     -t <3'trimlength>: take further 3'trimlength bases before adaptor match (def=0)
X     -N <readfile>: fill lines with 'N's rather than trimming
X     -f <readfile>: run scan on <readfile> FASTQ/FASTA fmt, show all reads, indicate matches
X     -H <readfile>: run scan on <readfile> FASTQ/FASTA fmt, indicate matches on hit reads only
X         if <readfile> is '-', then use stdin
X
X<adaptorfile> is a text file containing sequences, 1 per line.  If
Xthis option is not used, the program defaults to the first 40bp of the
XIllumina universal adaptor.
X
X-l: Only necessary if the length of any adaptor sequence exceeds 256
Xbp.
X
X-m sets the minimum length for an initial adaptor match.  The default
X(6) is a reasonable value.  Note that enabling single base mismatches
X(-S) will reduce the required match by 1 over this length.
X
X-M sets the 3' margin for matches before reads will be trimmed.  So, a
Xvalue of 10 would only trim if the adaptor match was in the last 10
Xresidues of the read.  The default is 0 which means don't apply this
Xcriterion.
X
X-R sets the read buffer length and is only necessary if reads or
Xheader lines exceed 256 characters.
X
X-s sets the number of residues skipped before adaptor matches will be
Xchecked.  Clearly if a reduced representation library of say 40-220 bp
Xhas been used, then there should be no need to check for adaptor
Xsequences before 40 bp of each read, hence setting -s 40 would achieve
Xthis, giving a marginal increase in performance.
X
X-p sets the % match of read vs entire adaptor sequence, from the point
Xwhere the match begins till the end of the read or the adaptor.
X75.0% is the default.  The performance of the program does not seem to
Xbe very sensitive to this value, increasing it from the default to 90%
Xonly makes a marginal change in the number of residues trimmed on real
Xdata.
X
X-S enables single base mismatches during the FSM scan operation and
Xmay help if there is a significant tendency for single residue read
Xerrors.  This option extensively lengthens the time taken to build the
XFSM, since it causes each base position to be expanded to A,C,G & T
Xfor all of the adaptor lengths from the minimum to the full length.
XGiven that the default scanning looks for a 6 bp match to the start of
Xthe adaptor sequence and then checks for 75.0% or greater match over
Xthe full adaptor length, this option is probably not really needed, so
Xthe default is for it to be disabled.
X
X-L lists the FSM to stdout: no read scanning is done.  This is really
Xfor checking the FSM-building process.
X
X-f lists the entire read file with adaptor matches and their quality
Xshown.  Each match is labelled with a string Ad_<n>_l<m> where <n> is
Xthe adaptor number (line No. in file) and <m> is the greatest matching
Xlength from the 5' end of the adaptor.  If the -S option is used, then
Xthe label is extended to Ad_<n>_l<m>_<Ba><k><Bs> where <Ba> is the
Xsubstituted adaptor residue, <k> its position and <Bs> the substituted
Xresidue (e.g. Ad_1_l8_G6C means an 8 residue match with adaptor
Xsequence 1 where the adaptor G at position 8 is substituted with a C).
X
X-H similar to -f, except that only reads which have matches meeting
Xthe criteria are shown.  For testing purposes mainly.
X
X-F,-z perform the trim operation, writing the trimmed data to stdout.
XResulting sequences shorter than the limit defined by -x and their
Xheaders are suppressed unless the -z option is used.  No labels are
Xgenerated, matching sequences reads are just truncated, along with the
Xquality line in FASTQ files.  Since cleanadaptors focusses on the
Xlongest match for each read, it may be appropriate to run through the
Xdata more than once.  Tests on read data here show that two passes
Xhave completely eliminated traces of adaptor sequence both by using
Xthe FastQC application
X(http://www.bioinformatics.bbsrc.ac.uk/projects/fastqc/) and by using
Xcleanadaptors to check for subsequent matches.  The -f, -H & -F
Xoptions will accept '-' as a file specification so that cleanadaptor
Xruns can be piped together with a command like:
X
Xcleanadaptors -F s_1_sequence.txt | cleanadaptors -F - | cleanadaptors -H -
X
Xwhich will read the original reads from s_1_sequence.txt, trim it
Xtwice with the default universal adaptor then display any remaining
Xmatches.  Any specifically modified 3' residues can further be trimmed
Xby using the -t option as well.
X
X-x sets the minimum length for a trimmed read to be saved, defaults to
X1.  The Bowtie aligner used by Bismark requires a minimum of 4 bp, so
Xthis option can be used to suppress the rejection of shorter trimmed
Xreads at the alignment stage.  Setting the limit to zero disables the
Xcheck (which is what -z does).  It is possible to exclude any trimmed
Xreads by using the -x option with the read length of the data.
X
X-t trims further back into the 3' end of the trimmed read in order to
Xensure that any residues modified in the library creation steps are
Xremoved.
X
X-N replaces trimmed sequence (and quality chars) with 'N's in order to
Xconserve the line length.  Rmapbs seems to require this.  The effects
Xof -x are as for trimmed lines.  In the unlikely event that it is
Xdesired to write out lines which have no untrimmed sequence, then -x 0
Xwill permit that.
X
Xcleanadaptors writes all output to stdout, so that saving the output
Xto a new file is performed with normal Unix/Linux redirection:
X
XE.g.:
X
Xcleanadaptors -i myilluminaadaptors.txt -F s_1_sequence.txt > s_1_trimmed.txt
X
Xwhich will trim any adaptors from the file myilluminaadaptors.txt,
Xsaving the output to s_1_trimmed.txt.
X
Xcleanadaptors -i myilluminaadaptors.txt -F s_1_sequence.txt -t 2 > s_1_tr_2.txt
X
Xwhich will trim a further 2 residues back into the 3' end of reads
Xwhich have an adaptor match.
X
X----------------------------------------------------------------------
Xillum2fasta.awk
X
Xa script which converts illumina fastq read files into fasta format.
XThe header lines are simplified in a way which reduces the read IDs
Xsignificantly in length but retains lane number, tile number and pixel
Xcoordinates so that it remains possible to trace back to the original
Xfastq reads.  For instance, the fastq lines
X
X@HWI-EAS209_0006_FC706VJ:1:1:1132:9986#0/1
XCGGGTTTGGGTGGAGATTTTTTTTTTATGAAATATCGTTTTTGCGTGGTGTTTGGTTTTGTTTTTTTTTTTGTGTTTTTTTTTTTTTGTTTTTTGTGTTT
X+HWI-EAS209_0006_FC706VJ:1:1:1132:9986#0/1
Xddbd_ccccc^ccR\L\Q]^caBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
X@HWI-EAS209_0006_FC706VJ:1:1:1134:20156#0/1
XCGGCGTTGTTTATGTTGGTTGGGTTTGGTATGTGATTTAGTATTTTGTTTTTTTGGGTTGGGTTGGGGGGGTTGGTTTTTTTTTGGTTTGTTGGGGTGTG
X+HWI-EAS209_0006_FC706VJ:1:1:1134:20156#0/1
XdddcddaddddRdddcddd`dd\dd`L`_LR\UZF`b`L^WTNa^BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
X
Xbecome:
X
X>s1_1_1132_9986
XCGGGTTTGGGTGGAGATTTTTTTTTTATGAAATATCGTTTTTGCGTGGTGTTTGGTTTTGTTTTTTTTTTTGTGTTTTTTTTTTTTTGTTTTTTGTGTTT
X>s1_1_1134_20156
XCGGCGTTGTTTATGTTGGTTGGGTTTGGTATGTGATTTAGTATTTTGTTTTTTTGGGTTGGGTTGGGGGGGTTGGTTTTTTTTTGGTTTGTTGGGGTGTG
X
XClearly the quality lines are eliminated, but the other information is
Xcoerced into a form which should be valid for FASTA file readers.
X
XUse: run with awk.  The output is to stdout, so normal redirection
Xwill work.
X
Xe.g.:
X
Xawk -f illum2fasta.awk s_1_sequence.txt > s_1_fasta.fa
X
XThe script is relatively rapid, processing 18x10^6 100bp reads took
Xabout 7 minutes on a Mac Pro with dual quad core Xeon 2.8 GHz CPUs
Xthough only a single core was employed.  Far too rapid to be bothered
Xwriting something more efficient.
X
X----------------------------------------------------------------------
Xmk4to1lines.awk
X
Xa script to write each group of 4 fast2 lines to a single line for the
Xpurposes of filtering bad tiles using Unix/Linux commands.  The
Xprocess is easily reversed using the tr command.  The new line
Xcharacters for each read are replaced with a default of ';'.
X
XFor instance in an experiment it is wished to eliminate tiles 1, 2, 3,
X40, 63, 119 & 120 due to airbubbles or inferior performance at flow
Xcell extremes.  So a series of lines matching the fastq header lines
Xfor that series of poor tiles, like:
X
XFC706VJ:1:1:
XFC706VJ:1:2:
XFC706VJ:1:3:
XFC706VJ:1:40:
XFC706VJ:1:63:
XFC706VJ:1:119:
XFC706VJ:1:120:
X
Xwould be written to a text file (kill_tiles.txt for example), then the
Xcomplete reads for those tiles could be deleted from the experiment by
Xthe following command:
X
Xawk -f mk4to1lines.awk s_1_sequence.txt | grep -v -f kill_tiles.txt | \
Xtr ";" "\n" > s_1_seq_filtered.txt
X
Xin which the grep command will pass all lines not matching any entries
Xin the kill_tiles.txt file and the tr command restores ';' line
Xseparators to Unix/Linux new lines.
X
XThe default line separator for this script can be altered by the
Xfollowing, in this case to a '!':
X
Xawk -f mk4to1lines.awk -v catchar='!' s_1_sequence.txt
X
XThe value of this script and these operations may be less important
Xfor HiSeq information, since the reduced number of tiles will cause
Xtoo much data to be discarded in comparison with the Illumina GAIIx
Xplatform.
X
X----------------------------------------------------------------------
Xbismmethex2list.awk
X
Xa script to generate simple tab-delimited lists of chromosome No,
Xposition, methylation status from the output of the BisMark
Xmethylation_extractor program.  This leaves the data in a form which
Xis amenable to further processing by scan_cpg_depth or bin_cnts.
X
XThe operation is very simple, the extractor produces lines ending in
X'Z' for methylated CpG and 'z' for unmethlated.  This script just
Xconverts these to +/-.
X
XChanges in header lines from CASAVA 1.8 have required a modification
Xsince more fields are now written to the output file.  The variable
Xzcol defines where the script expects the 'Z' & 'z' chars to be.  zcol
Xpresently defaults to 5 for GAII style headers, but should be defined
Xto 6 for HiSeq output.
X
XUse:
X
Xawk -f bismmethex2list.awk CpG_CTOT_s_1_sequence.txt_bismark.txt
X
Xor
X
Xawk -f bismmethex2list.awk zcol=6 CpG_CTOT_hiseq_casava1.8.txt_bismark.txt
X
Xwrites the converted lines to stdout where they can be captured by
Xcommandline redirection.
X
X----------------------------------------------------------------------
Xtidyrrnams.awk
X
XScript to correct chromosome names from mkgenomes.  In order to
Xdistinguish the names from the unmodified defaults (1,2..22,X,Y) they
Xhave rr appended to them, but this can complicate downstream
Xprocessing, hence this script which can flexibly remove rr suffixes.
XThis script replaces a number of earlier ones which had been tailored
Xto specific output file formats but, by writing this version in a
Xslightly more intelligent way, it manages variant formats, like .BED
Xfiles and bsmap output.  
X
XE.g. rmapbs output run on RR genome gives:
X
XXrr	529488	529538	HWI-EAS209_0006_FC706VJ:1:2:10354:4724#0/1	1	+
X15rr	241793	241843	HWI-EAS209_0006_FC706VJ:1:3:5446:13600#0/1	7	+
X16rr	2800644	2800694	HWI-EAS209_0006_FC706VJ:1:5:13647:7002#0/1	5	+
X[...]
X
Xwhere we need to modify field 1, so the command
X
Xawk -f <path>tidyrrnams.awk splitfield=1 <mybedfile>.bed > <modifiedfile>.bed
X
Xwill alter the chromsome ids to X,15,16... respectively for this
Xexample.  splitfield defaults to 1 so the parameter 'splitfield=1'
Xcould be omitted.
X
Xbsmap generates output like:
X
XHWI-EAS209_0006_FC706VJ:1:1:6899:15689#0/1	GGTAATTTTTTTTATTGTTTTTTGTAGTAGGTGTTGAGT	UM	Xrr	613451	-+	0	1:0:0:0:0	mC
XHWI-EAS209_0006_FC706VJ:1:1:6900:16423#0/1	GGGTTTTTGTTTTATAAAGTGGGTAGTGGTAAAGTGTTG	UM	2rr	1760913	-+	0	1:0:0:0:0	mC
XHWI-EAS209_0006_FC706VJ:1:1:6900:4193#0/1	GGAATAGTTTTTGGTATATAGTAGGTATTTAATAATTGT	UM	5rr	2861341	++	1	0:1:0:1:0	mC
X
Xonce unique matches are selected, with the chromosome id in the fourth
Xfield.  So the command:
X
Xawk -f <path>tidyrrnams.awk splitfield=4 <mybsmapoutfile> > <renamedbsmapfile>
X
Xwill work.
X
XBismark output writes the chromosome name to the 3rd field of output
Xreport files, so 'splitfield=3' is appropriate there.
X
X----------------------------------------------------------------------
END-of-meth_progs_dist/progs_doc.txt
echo c - meth_progs_dist/src
mkdir -p meth_progs_dist/src > /dev/null 2>&1
echo x - meth_progs_dist/src/bas_fns.c
sed 's/^X//' >meth_progs_dist/src/bas_fns.c << 'END-of-meth_progs_dist/src/bas_fns.c'
X/* bas_fns.c: basic library functions written in c */
X
X#include <stdlib.h>
X#include <time.h>
X#include <locale.h>
X#include <stdarg.h>
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X#include "bas_fns.h"
X
X#ifdef MALLOCDBG
X
XFILE *malfl = NULL;
X
XMALCHK *mfirst;
XMALCHK *mlast;
Xint mlccnt;
X
XMALCHK *scan4free(void *pt)
X  /* return ptr to structure containing address pt, NULL if not found */
X{
XMALCHK *lp;
X
Xlp = mfirst;
Xwhile (lp != NULL)
X  if (lp->ptr == pt)
X    return(lp);
X  else
X    lp = lp->nextmelt;
Xreturn(NULL);
X}
X
Xvoid bas_initmalfl(char *nm)
X/* initialise mf to write to nm for tracing purposes */
X{
Xif ((malfl = fopen(nm,"w")) == NULL)
X  {
X  fprintf(stderr,"Can't open malloc stream file %s\n",nm);
X  exit(1);
X  }
Xmfirst = mlast = NULL;
Xmlccnt = 0;
X}
X
Xvoid mchk_addpt(void *pt)
X  /* add pt to list of stored items */
X{
XMALCHK *newp;
X
Xif ((newp = (MALCHK *) malloc(sizeof(MALCHK))) == NULL)
X  {
X  fprintf(stderr,"check element malloc failed\n");
X  if (malfl)
X    fflush(malfl);
X  exit(1);
X  }
Xif (mlast != NULL)
X  {
X  mlast->nextmelt = newp;
X  newp->prvmelt = mlast;
X  }
Xelse
X  {
X  mfirst = newp;
X  newp->prvmelt = NULL;
X  }
Xnewp->ptr = pt;
Xnewp->nextmelt = NULL;
Xmlccnt++;
Xmlast = newp;
X}
X
X#else
X
Xvoid bas_initmalfl(char *nm)
X  /* dummy under these conditions */
X{
X}
X
X#endif
X
Xchar *getmemory(int nbytes,
X                char *msg)
X/* malloc nbytes, and return address: die with msg if problem */
X{
Xchar *pt;
X
Xif ((pt = malloc(nbytes)) == NULL)
X  {
X  fprintf(stderr,"Malloc failed for %d: %s\n",nbytes,msg);
X  exit(1);
X  }
X#ifdef MALLOCDBG
Xif (malfl)
X  {
X  fprintf(malfl,"%d @ %lx: %s\n",nbytes,(long) pt,msg);
X  fflush(malfl);
X  }
Xmchk_addpt(pt);
X#endif
Xreturn(pt);
X}
X
Xchar *bas_strdup(char *str)
X  /* local strdup, intended to be trackable if needed */
X{
X#ifdef MALLOCDBG
Xint slen;
Xchar *nmem;
X
Xif (str == NULL)
X  return(NULL);
Xelse
X  {
X  slen = strlen(str) + 1;
X  nmem = getmemory(slen,"bas_strdup");
X  bcopy(str,nmem,(size_t) slen);
X  return(nmem);
X  }
X#else
Xif (str == NULL)
X  return(NULL);
Xelse
X  return(strdup(str));
X#endif
X}
X
Xvoid memfree(void *pt)
X  /* free malloced pt, tell malfl if appropriate */
X{
X#ifdef MALLOCDBG
XMALCHK *pts;
XMALCHK *adjp;
X
Xif ((pts = scan4free(pt)) == NULL)
X  {
X  fprintf(stderr,"free nonalloced memory %lx\n",(long) pt);
X  fflush(stderr);
X  if (malfl)
X    {
X    fprintf(malfl,"Free nonalloced memory %lx\n",(long) pt);
X    fflush(malfl);
X    }
X/*  free((void *) -1); */  /* try to engineer a traceable dump */
X  exit(1);
X  }
Xelse
X  {
X  if ((adjp = pts->nextmelt) == NULL) /* last element */
X    {
X    mlast = pts->prvmelt;
X    if (mlast != NULL)
X      mlast->nextmelt = NULL;
X    }
X  else
X    adjp->prvmelt = pts->prvmelt;
X  if ((adjp = pts->prvmelt) == NULL) /* first element */
X    {
X    mfirst = pts->nextmelt;
X    if (mfirst != NULL)
X      mfirst->prvmelt = NULL;
X    }
X  else
X    adjp->nextmelt = pts->nextmelt;
X  free(pts);
X  mlccnt--;
X  if (malfl)
X    {
X    fprintf(malfl,"Free %lx\n",(long) pt);
X    fflush(malfl);
X    }
X  }
X
X#endif
X
Xfree(pt);
X}
X
Xvoid bas_tellunfreed()
X  /* report presently unfreed memory - write to malfl if appropriate */
X{
X#ifdef MALLOCDBG
XMALCHK *mp;
XFILE *fl;
X
Xmp = mfirst;
Xif (malfl != NULL)
X  fl = malfl;
Xelse
X  fl = stderr;
Xwhile (mp != NULL)
X  {
X  fprintf(fl,"Unfreed: %lx\n",(long) mp->ptr);
X  mp = mp->nextmelt;
X  }
X#else
X/* do nothing */
X#endif
X}
X
Xvoid bas_rptchrout(FILE *fl,
X                   int cc,
X                   char c)
X/* put cc repetitions of c to fl */
X{
Xwhile (cc-- > 0)
X  fputc(c,fl);
X}
X
Xchar *bas_int2strmnth(int imnth,
X                      int shrtfm)
X/* return a pointer to an array of month names, 3 letter form for shrtfm */
X{
Xif (shrtfm)
X  switch (imnth)
X    {
X    case 1:
X      return("Jan");
X      break;
X    case 2:
X      return("Feb");
X      break;
X    case 3:
X      return("Mar");
X      break;
X    case 4:
X      return("Apr");
X      break;
X    case 5:
X      return("May");
X      break;
X    case 6:
X      return("Jun");
X      break;
X    case 7:
X      return("Jul");
X      break;
X    case 8:
X      return("Aug");
X      break;
X    case 9:
X      return("Sep");
X      break;
X    case 10:
X      return("Oct");
X      break;
X    case 11:
X      return("Nov");
X      break;
X    case 12:
X      return("Dec");
X      break;
X    default:
X      return("?Mnth?");
X      break;
X    }
Xelse
X  switch (imnth)
X    {
X    case 1:
X      return("January");
X      break;
X    case 2:
X      return("February");
X      break;
X    case 3:
X      return("March");
X      break;
X    case 4:
X      return("April");
X      break;
X    case 5:
X      return("May");
X      break;
X    case 6:
X      return("June");
X      break;
X    case 7:
X      return("July");
X      break;
X    case 8:
X      return("August");
X      break;
X    case 9:
X      return("Sepember");
X      break;
X    case 10:
X      return("October");
X      break;
X    case 11:
X      return("November");
X      break;
X    case 12:
X      return("December");
X      break;
X    default:
X      return("?Month?");
X      break;
X    }
X}
X
Xvoid bas_scatprintf(char *buf,
X                    int blen,
X                    char *fmt,
X                    ...)
X/* varags method of appending (concatenating more material to
Xbuf */
X{
Xva_list args;
Xchar *fstrng;
X
Xva_start(args,fmt);
Xif (vasprintf(&fstrng,fmt,args) > 0)
X  {
X  (void) strncat(buf,fstrng,(size_t) (blen - strlen(buf)));
X  free(fstrng);
X  }
Xva_end(args);
X}
X
Xvoid bas_appdate2str(char *dbuf,
X                     char **bp,
X                     int blen)
X/* append system date & time to dbuf if room at *bp, update *bp
X   - code nicked from man strftime pages */
X{
Xchar dtstr[80];
Xtime_t dtbin;
Xstruct tm *dtstrct;
X
X(void) setlocale(LC_ALL, "");
Xif (time(&dtbin) == (time_t) -1)
X  bas_appstr(dbuf,bp,"time call failed",blen);
Xelse
X  {
X  dtstrct = localtime(&dtbin);
X  if (strftime(dtstr,80, "%a %e-%b-%Y %T",dtstrct) == (size_t) 0)
X    bas_appstr(dbuf,bp,"time call failed",blen);
X  else
X    bas_appstr(dbuf,bp,&dtstr[0],blen);
X  }
X} 
X
Xvoid sqfl_date2file(FILE *sfl)
X  /* write system date & time to sfl */
X{
Xchar dtstr[80];
Xchar *bp;
X
Xbp = &dtstr[0],
Xbas_appdate2str(&dtstr[0],&bp,79);
Xfprintf(sfl,"%s",&dtstr[0]);
X} 
X
Xint imin(int i,
X         int j)
X/* return the minimum of i,j */
X{
Xif (i <= j)
X  return(i);
Xelse
X  return(j);
X}
X
Xint imax(int i,
X         int j)
X/* return the larger of i,j */
X{
Xreturn(i>j ? i:j);
X}
X
Xvoid bas_skipeol(FILE *fl,
X                 int *lno)
X/* skip past next \n char or \r, increment lno if non-null */
X{
Xint nc;
X
Xwhile (((nc = fgetc(fl)) != EOF) && ((char) nc != '\n') &
X          ((char) nc != '\r'));
X  if (lno != NULL)
X    (*lno)++;
X}
X
Xchar *bas_fgets(char *buf,
X                int blen,
X                FILE *fl,
X                int *lcnt)
X/* perform fgets of fl, remove \n from string */
X{
Xchar *lp;
Xchar *slim;
Xchar *rslt;
X
Xrslt = fgets(buf,(blen+1),fl);
Xif (rslt != NULL)
X  {
X  lp = buf;
X  slim = buf + blen;
X  while ((lp <= slim) && (*lp != '\0'))
X    {
X    if (*lp == '\n')
X      {
X      (*lcnt)++;
X      *lp = '\0';
X      lp = slim;
X      }
X    lp++;
X    }
X  if (*buf == '\0') /* have read an empty line in effect, try again */
X    return(bas_fgets(buf,blen,fl,lcnt));
X  else
X    return(rslt);
X  }
Xelse
X  return(NULL);
X}
X
Xint bas_chr2ubuf(char *lbuf,
X                 char **bp,
X                 char nc,
X                 int blen)
X/* append nc to lbuf at *bp.  return 1 if room */
X{
Xif (*bp - lbuf <= blen)
X  {
X  **bp = nc;
X  (*bp)++;
X  if (*bp - lbuf <= blen)  /* try to ensure there is a terminal null chr */
X    **bp = '\0';
X  return(1);
X  }
Xelse
X  return(0);
X}
X
Xvoid bas_appchr(char *lbuf,
X                char **bp,
X                char nc,
X                int blen)
X/* append nc to lbuf at *bp, if *bp does not exceed blen chars in total */
X{
X(void) bas_chr2ubuf(lbuf,bp,nc,blen);
X}
X
Xvoid bas_catchr(char *lbuf,
X                char nc,
X                int blen)
X/* append nc to lbuf end of current string, check won't exceed blen chars in 
Xtotal */
X{
Xchar *bp;
X
Xbp = lbuf;
Xwhile (*bp != '\0')
X  bp++;
Xbas_appchr(lbuf,&bp,nc,blen);
X}
X
Xint bas_str2ubuf(char *lbuf,
X                 char **bp,
X                 char *str,
X                 int blen)
X/* append str to lbuf at *bp, if room.  return no of chars inserted */
X{
Xchar *sp;
Xint ccnt;
X
Xccnt = 0;
Xsp = str;
Xwhile ((sp != NULL) && (*sp != '\0'))
X  if (bas_chr2ubuf(lbuf,bp,*sp++,blen))
X    ccnt++;
Xreturn(ccnt);
X}
X
Xvoid bas_appstr(char *lbuf,
X                char **bp,
X                char *str,
X                int blen)
X/* append str to lbuf at *bp, if *bp does not exceed blen chars in total */
X{
X(void) bas_str2ubuf(lbuf,bp,str,blen);
X}
X
Xint bas_int2ubuf(char *lbuf,
X                 char **bp,
X                 int ival,
X                 char *fmt,
X                 int blen)
X/* append ival to lbuf at *bp, return 1 if there was sufficient room */
X{
Xchar ibuf[33];
Xint slen;
X
Xsprintf(&ibuf[0],fmt,ival);
Xslen = strlen(&ibuf[0]);
Xif ((*bp - lbuf) <= (blen - slen))
X  return(bas_str2ubuf(lbuf,bp,&ibuf[0],blen) > 0);
Xelse
X  return(0);
X}
X
Xint bas_fgetatm_ufn(FILE *fl,
X                    char *lbuf,
X                    int blen,
X                    char *brkchrs,
X                    int (*ufgetc)(FILE *f))
X/* read characters from fl using ufgetc, skipping any in brkchrs.
X  write to lbuf, if not overlength, stopping at EOF or next 
Xoccurrence of brkchrs.  Return number of chrs read. 
XNULL terminate string if underlength */
X{
Xint nc;
Xchar *bp;
Xint rv;
X
Xbp = lbuf;
Xwhile (((nc = (*ufgetc)(fl)) != EOF) && (index(brkchrs,(char)nc) != NULL));
Xif (nc == EOF)
X  return(-1);
Xelse
X  {
X  bas_appchr(lbuf,&bp,(char) nc,blen);
X  while (((nc = (*ufgetc)(fl)) != EOF) && (index(brkchrs,(char) nc) == NULL))
X    bas_appchr(lbuf,&bp,(char) nc,blen);
X  rv = (int) (bp - lbuf);
X  bas_appchr(lbuf,&bp,'\0',blen);
X  return(rv);
X  }
X}
X
Xint bas_fgetatm(FILE *fl,
X                char *lbuf,
X                int blen,
X                char *brkchrs)
X/* read characters from fl, skipping any in brkchrs.  write to lbuf, if
Xnot overlength, stopping at EOF or next occurrence of brkchrs.  Return
Xnumber of chrs read. NULL terminate string if underlength */
X{
Xreturn(bas_fgetatm_ufn(fl,lbuf,blen,brkchrs,fgetc));
X}
X
Xint bas_fgetlin(FILE *fl,
X                char *lbuf,
X                int blen,
X                int *lcnt)
X/* read characters from fl to next eoln, \r or EOF.  Return
Xnumber of chrs read, even if 0. NULL terminate string if underlength
Xreturn -1 for EOF */
X{
Xint nc;
Xchar *bp;
Xint rv;
X
Xbp = lbuf;
Xwhile (((nc = fgetc(fl)) != EOF) && ((char) nc != '\n') && ((char) nc != '\r'))
X  bas_appchr(lbuf,&bp,(char) nc,blen);
Xrv = (int)(bp - lbuf);
Xbas_appchr(lbuf,&bp,'\0',blen);
X(*lcnt)++;
Xif (nc == EOF)
X  return(-1);
Xelse
X  return(rv);
X}
X
Xint bas_ptrgetatm(char *sbuf,
X                  char **sp,
X                  char *lbuf,
X                  int blen,
X                  char *brkchrs)
X/* scan characters from sbuf, starting at *bp, skipping any in brkchrs.  
X update *bp to final position.  write to lbuf, if
Xnot overlength, stopping at '\0' or next occurrence of brkchrs.  Return
Xnumber of chrs written. NULL terminate string if underlength */
X{
Xchar nc;
Xchar *bp;
Xint rv;
X
Xbp = lbuf;
Xwhile (((nc = *(*sp)++) != '\0') && (index(brkchrs,nc) != NULL));
Xif (nc == '\0')
X  return(0);
Xelse
X  {
X  bas_appchr(lbuf,&bp,nc,blen);
X  while (((nc = *(*sp)++) != '\0') && (index(brkchrs,nc) == NULL))
X    bas_appchr(lbuf,&bp,nc,blen);
X  rv = (int) (bp - lbuf);
X  bas_appchr(lbuf,&bp,'\0',blen);
X  return(rv);
X  }
X}
X
Xint bas_sgetatm(char *sbuf,
X                char *lbuf,
X                int blen,
X                char *brkchrs)
X/* scan characters from sbuf, skipping any in brkchrs.  write to lbuf, if
Xnot overlength, stopping at '\0' or next occurrence of brkchrs.  Return
Xnumber of chrs written. NULL terminate string if underlength */
X{
Xchar *sp;
X
Xsp = sbuf;
Xreturn(bas_ptrgetatm(sbuf,&sp,lbuf,blen,brkchrs));
X}
X
Xint bas_digitsin(int nmb)
X  /* return the number of decimal digits to represent nmb */
X{
Xint cnt;
X
Xif (nmb == 0)
X  return(1);
Xelse
X  if (nmb < 0)
X    return(bas_digitsin(-nmb) + 1);
X  else
X    {
X    cnt = 0;
X    while (nmb > 0)
X      {
X      nmb = (int) nmb/10;
X      cnt++;
X      }
X    return(cnt);
X    }
X}
X
Xchar *bas_strcpyskip(char *lin,
X                     int smax,
X                     char *dst,
X                     int dmax,
X                     char *skipset)
X/* copy lin up to smax chars to dst, up to dmax chars.  skip leading chars
Xin skipset, stop on first skipset char.  Return pointer to remainder of string
X - NULL if nothing was found */
X{
Xchar *sp;
Xchar *dp;
Xint ocnt;
X
Xsp = lin;
Xwhile (index(skipset,*sp) != NULL)
X  {
X  sp++;
X  smax--;
X  }
Xdp = dst;
Xocnt = 0;
Xwhile ((smax-- > 0) && (*sp != '\0') && (dmax-- > 0) && 
X        (index(skipset,*sp) == NULL))
X  {
X  if (dp != NULL)
X    *dp++ = *sp++;
X  else
X    sp++;
X  ocnt++;
X  }
Xif ((dp != NULL) && (dmax > 0))
X  *dp = '\0';
Xif (ocnt > 0)
X  return(sp);
Xelse
X  return(NULL);
X}
X
Xchar *bas_modstrng(char *str,
X                   int (*chrmod)(int nc))
X/* replace each character of str by chrmod()ed equivalent.  return str */
X{
Xchar *sp;
X
Xsp = str;
Xwhile (*sp != '\0')
X  {
X  *sp = (char)(*chrmod)((int) *sp);
X  sp++;
X  }
Xreturn(str);
X}
X
Xint bas_null4nl(int nc)
X  /* return nc, unless it is a nl, in which case return '\0' */
X{
Xif (nc == '\n')
X  return('\0');
Xelse
X  return(nc);
X}
X
Xchar *bas_sharchrs(char *s1,
X                   char *s2)
X/* return a pointer to any part of s1 that appears in s2, NULL if none */
X{
Xchar *p1;
X
Xp1 = s1;
Xwhile (*p1 != '\0')
X  if (index(s2,*p1) != NULL)   /* have a match, exit here */
X    return(p1);
X  else
X    p1++;
Xreturn(NULL);                  /* fell off end, no match, return NULL */
X}
X
Xint bas_cntfputs(char *str,
X                 FILE *fl)
X/* return the length of this string, and put to fl */
X{
Xfputs(str,fl);
Xreturn(strlen(str));
X}
X
Xint bas_coutputchr(FILE *fl,
X                   char c)
X/* write c to fl, in "approved form. return no of chars to do this */
X{
Xswitch (c)
X  {
X  case '\0':
X    return(bas_cntfputs("\\0",fl));
X    break;
X  case '\n':
X    return(bas_cntfputs("\\n",fl));
X    break;
X  case '\r':
X    return(bas_cntfputs("\\r",fl));
X    break;
X  case '\t':
X    return(bas_cntfputs("\\t",fl));
X    break;
X  default:
X    if ((c >= ' ') && (c <= '~'))
X      {
X      fputc(c,fl);
X      return(1);
X      }
X    else
X      {
X      fprintf(fl,"\\%03o",(int) c);
X      return(4);
X      }
X    break;
X  }
X}
X
Xint bas_putochr(FILE *fl,
X                char c)
X/* write c to fl, in octal form. return no of chars to do this */
X{
Xfprintf(fl,"\\%03o",(int) 0xff&c);
Xreturn(4);
X}
X
Xint bas_coutputstr(FILE *fl,
X                   char *str,
X                   char dlmt,
X                   int ccnt,
X                   int (*coutfun)(FILE *xfl,
X                                  char c))
X/* put out ccnt characters from str, irrespective of their value.  Return
Xactual no of char positions consumed */
X{
Xchar *sp;
Xint cc;
X
Xcc = 0;
Xsp = str;
Xif (dlmt != '\0')
X  {
X  fputc(dlmt,fl);
X  cc++;
X  }
Xwhile (ccnt-- > 0)
X  cc += (*coutfun)(fl,*sp++);
Xif (dlmt != '\0')
X  {
X  fputc(dlmt,fl);
X  cc++;
X  }
Xreturn(cc);
X}
X
Xint bas_strncmp(char *s1,
X                char *s2,
X                int n)
X/* compare s1 & s2 byte by byte up to n bytes or till either differ.
X  return 0 if same, -1 if s1 precedes s2 in collating order, +1 if succeeds.
XDiffers from library strncmp() in that this will continue beyond null chars */
X{
Xchar *p1;
Xchar *p2;
X
Xp1 = s1;
Xp2 = s2;
Xwhile (n-- > 0)
X  {
X  if (*p1 != *p2)
X    if (*p1 > *p2)
X      return(1);
X    else
X      return(-1);
X  else
X    {
X    p1++;
X    p2++;
X    }
X  }
Xreturn(0);
X}
X
Xint bas_cmatcasdep(char c1,
X                   char c2)
X/* return 1 if c1 == c2, case dependent */
X{
Xreturn(c1 == c2);
X}
X
Xint bas_cmatnocas(char c1,
X                  char c2)
X/* return 1 if c1 == c2, case independent */
X{
Xreturn(toupper(c1) == toupper(c2));
X}
X
Xint bas_wldstrcmp(char *strng,
X                  char *patn,
X                  int (*chrcmpfn)(char c1,
X                                  char c2))
X/* simple minded string matching function which will match chars using 
X(*chrcmpfn)() (returns 1 for match, 0 otherwise), and '*'s.
X  return 1 for match 0 otherwise */
X{
Xchar *pp;
Xchar *sp;
Xchar *wp;
X
Xpp = patn;
Xsp = strng;
Xif (*pp == '\0')       /* at end of pattern - success if at end of string */
X  return(*sp == '\0');
Xelse
X  if (*pp != '*')
X    if ((*chrcmpfn)(*pp,*sp))
X      return(bas_wldstrcmp(++sp,++pp,chrcmpfn));
X    else
X      return(0);
X  else   /* on '*' in pattern */
X    {
X    while (*pp == '*')
X      wp = pp++;    /* skip ahead of '*' */
X    if (*pp == '\0')     /* we've won */
X      return(1);
X    else
X      {
X      while ((*sp != '\0') && (!(*chrcmpfn)(*sp,*pp)))
X        sp++;
X      if (*sp == '\0')
X        return(0);         /* next c doesn't match */
X      else
X        return(bas_wldstrcmp(++sp,++pp,chrcmpfn) ||
X                 bas_wldstrcmp(sp,wp,chrcmpfn));
X      }
X    }
X}
X
Xint bas_getustr(FILE *fl,
X                char *ubuf,
X                int ublen)
X/* get input from fl - read chars, don't overflow ubuf.
Xreturn length of string returned, -1 for EOF */
X{
Xchar *bp;
Xint nc;
X
Xbp = ubuf;
Xwhile (((nc = fgetc(fl)) != EOF) && ((char) nc != '\n'))
X  bas_appchr(ubuf,&bp,(char) nc,ublen);
Xif (nc == EOF)
X  return(-1);
Xelse
X  return((int) (bp - ubuf));
X}
X
Xint bas_ugetstr(char *prmpt,
X                char *ubuf,
X                int ublen)
X/* prompt for user input with prmpt - read chars, don't overflow ubuf.
Xreturn length of string returned */
X{
Xchar *bp;
Xint nc;
X
Xif (prmpt != NULL)
X  fputs(prmpt,stdout);
Xfflush(stdout);
Xbp = ubuf;
Xwhile (((nc = fgetc(stdin)) != EOF) && ((char) nc != '\n'))
X  bas_appchr(ubuf,&bp,(char) nc,ublen);
Xreturn((int)(bp - ubuf));
X}
X
Xvoid bas_pause()
X  /* request user <CR> */
X{
Xint nc;
X
Xfprintf(stdout,"  Press <Return> to continue:");
Xfflush(stdout);
Xwhile (((nc = fgetc(stdin)) != EOF) && ((char) nc != '\n'));
X}
X
Xint bas_getuint(char *prmpt,
X                int min,
X                int max,
X                int def,
X                int *uval)
X/* prompt stdout/stdin for an integer value generating a prompt from prmpt
Xrange and default values.  return returned value in uval and 1 if decoded OK,
Xelse return 0 */
X{
Xchar *pbuf;
Xchar *ubuf;
Xint iv;
Xchar *ep;
Xint rv;
X
Xpbuf = (char *) getmemory((strlen(prmpt)+40),"prompt buffer");
Xubuf = (char *) getmemory(129,"user buff");
Xsprintf(pbuf,prmpt,min,max,def);
Xif (bas_ugetstr(pbuf,ubuf,128) == 0)
X  iv = def;
Xelse
X  iv = (int) strtol(ubuf,&ep,10);
Xif ((iv >= min) && (iv <= max))
X  {
X  *uval = iv;
X  rv = 1;
X  }
Xelse
X  rv = 0;
Xmemfree(ubuf);
Xmemfree(pbuf);
Xreturn(rv);
X}
X
Xint bas_uconfirm(char *prmpt,
X                 char def)
X/* prompt for a yes/no response */
X{
Xchar *ubuf;
Xchar *pbuf;
Xint rv;
X
Xpbuf = (char *) getmemory((strlen(prmpt)+20),"prompt buff");
Xubuf = (char *) getmemory(129,"user buf");
Xsprintf(pbuf,"%s (Y/N) [%c] > ",prmpt,def);
Xdo
X  if (bas_ugetstr(pbuf,ubuf,128) == 0)
X    *ubuf = def;
Xwhile ((toupper(*ubuf) != 'Y') && (toupper(*ubuf) != 'N'));
Xrv = toupper(*ubuf) == 'Y';
Xmemfree(pbuf);
Xmemfree(ubuf);
Xreturn(rv);
X}
END-of-meth_progs_dist/src/bas_fns.c
echo x - meth_progs_dist/src/bin_cnts.c
sed 's/^X//' >meth_progs_dist/src/bin_cnts.c << 'END-of-meth_progs_dist/src/bin_cnts.c'
X/* bin_cnts: to take generate binned lists of counts from 
Xappropriately-formatted input files (chrno, position, strand/status
Xwhere strand/status = '+' or '-')
X
XProcess requires scanning human genome, chromosome by chromosome
Xto get lengths.  Linked lists of bins are used to manage
Xvariable Chr lengths & variable counts */
X
X#include <stdlib.h>
X#include <string.h>
X#include <stdarg.h>
X#include <stdio.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "sqfl_fns.h"
X#include "sqmat_fns.h"
X#include "rmapbsbed2cpg.h"
X#include "rbs_fns.h"
X#include "bin_cnts.h"
X#include "fsm_ops.h"
X
X/* global debug & out style variables, for simplicity of access */
XRBC_DBG debuglevel;
XBC_OUTMODE omode;
XRBC_SRC_STYLE srcstyle;
Xint glblreadlen;          /* global value for readlength */
X/* BC_CHR_BIN *chrbinlsts[ChrY]; */ /* bin lists for each chromosome */
X/* BC_CHR_BIN *chrbinsalt[ChrY]; */  /* alternate set of character bins */
X
Xint err_msg(char *fmt,
X            ...)
X/* write user error message.  Return 0 for err return status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xreturn(0);
X}
X
Xvoid err_msg_die(char *fmt,
X                 ...)
X/* write user error message then exit with error status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xexit(1);
X}
X
Xvoid say_usage(FILE *fl,
X               char *pnam)
X{
Xfprintf(fl,"%s: create binned counts for chromosomal positions\n",pnam);
Xfputs("Options:\n",fl);
Xfputs("     -r <posfile> read <posfile> as set of chr posit strand/meth\n",fl);
Xfputs("     -R <posfile2> as -r but for 2nd position file\n",fl);
Xfprintf(fl,"     -b <binlength>: set bin length (def=%d)\n",BC_DEF_BINLEN);
Xfputs("     -g <genomehead> dir and file string to locate genomic seq files by adding n.fa\n",fl);
Xfputs("     -l/-L list bins (-L=>only nonzero bins)\n",fl);
Xfputs(
X"     -m scan for diff meth regions restricted rep (Li, et al. (2010) PLOSBiology,11,e1000533)\n"
X,fl);
Xfputs("     -M <j,k> scan for restricted rep fragment sizes between j & k residues. Make bins\n",fl);
Xfputs("     -N as for -M but list bins to stdout\n",fl);
Xfputs("     -k as for -M, but note reads which don't map into restricted rep bins\n",fl);
Xfputs("     -K as for -k, but only print totals for meth & unmeth counts\n",fl);
Xfputs("     -S <dirheader> write .dat files to <dirheader> for RR genome for SeqMonk\n",fl);
Xfputs("     -c <n> restrict effort to Chromosome <n> (def = all chromosomes)\n",fl);
Xfputs("     -C <n> restrict bins to those with <n> or more CpGs\n",fl);
Xfputs("     -A attempt to amalgamate restr rep regions that might otherwise fail CpG criteria\n",fl);
Xfputs("     -x <excludefile> exclude regions (fmt: Chrno regionstart regionend)\n",fl);
X}
X
XBC_CHR_BIN *rbc_appndbin(BC_CHR_BIN **lstrt,
X                          int bstart,
X                          int len)
X/* create and append a new element to *lstrt,
Xinit count to 0.
X Return address of new element */
X{
XBC_CHR_BIN *prev, *end_ptr;
X
Xif (lstrt != NULL)
X  {
X/*  if (debuglevel > RBC_dbg_none)
X    fprintf(stdout,"Bin %d..%d, len=%d\n",bstart,bstart+len-1,len); */
X  prev = end_ptr = *lstrt;
X  while (end_ptr != NULL)
X    {
X    prev = end_ptr;
X    end_ptr = end_ptr->nxtbin;
X    }
X  end_ptr = (BC_CHR_BIN *) getmemory(sizeof(BC_CHR_BIN),"bin elt");
X  end_ptr->nxtbin = NULL;
X  end_ptr->spos = bstart;
X  end_ptr->binlen = len;
X  end_ptr->bcntrev = end_ptr->bcntfwd = end_ptr->cpgcnt = 0;
X  if (*lstrt == NULL)
X    {
X    *lstrt = end_ptr;
X    end_ptr->prvbin = NULL;
X    }
X  else
X    {
X    prev->nxtbin = end_ptr;
X    end_ptr->prvbin = prev;
X    }
X  return(end_ptr);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid rbc_delcntbin(BC_CHR_BIN *ep,
X                   BC_CHR_BIN **lstrt)
X/* delete ep from list *lstrt */
X{
XBC_CHR_BIN *pt;
X
Xif (ep != NULL)
X  {
X  if ((pt = ep->prvbin) == NULL)
X    *lstrt = ep->nxtbin;
X  else
X    pt->nxtbin = ep->nxtbin;
X  if ((pt = ep->nxtbin) != NULL)
X    pt->prvbin = ep->prvbin;
X  memfree(ep);
X  }
X}
X
Xvoid rbc_clrallcntbins(BC_CHR_BIN **lstrt)
X  /* iteratively delete all of lstrt */
X{
Xwhile (*lstrt != NULL)
X  rbc_delcntbin(*lstrt,lstrt);
X}
X
Xint bc_cntcntbins(BC_CHR_BIN *clst)
X  /* recursively read list elements */
X{
Xif (clst == NULL)
X  return(0);
Xelse
X  return(bc_cntcntbins(clst->nxtbin) + 1);
X}
X
Xint bc_sumcntfwdbins(BC_CHR_BIN *blst)
X  /* recursively sum the counts in blst */
X{
Xif (blst == NULL)
X  return(0);
Xelse
X  {
X  if (debuglevel > RBC_dbg_on)
X    fprintf(stdout,"%d %d %lx\n",blst->spos,blst->bcntfwd,(long int) blst->nxtbin);
X  return(blst->bcntfwd + bc_sumcntfwdbins(blst->nxtbin));
X  }
X}
X
Xint bc_itsumcntfwdbins(BC_CHR_BIN *blst)
X  /* iteratively sum counts in blst... */
X{
XBC_CHR_BIN *bp;
Xint cnt;
X
Xbp = blst;
Xcnt = 0;
Xwhile (bp != NULL)
X  {
X  cnt += bp->bcntfwd;
X  bp = bp->nxtbin;
X  }
Xreturn(cnt);
X}
X
Xint bc_itsumcntrevbins(BC_CHR_BIN *blst)
X  /* iteratively sum counts in blst... */
X{
XBC_CHR_BIN *bp;
Xint cnt;
X
Xbp = blst;
Xcnt = 0;
Xwhile (bp != NULL)
X  {
X  cnt += bp->bcntrev;
X  bp = bp->nxtbin;
X  }
Xreturn(cnt);
X}
X
XBC_CHR_BIN *cpg_lastcntbin(BC_CHR_BIN *clst)
X  /* iterate thru clst, returning
Xlast element, NULL if none */
X{
XBC_CHR_BIN *ep;
X
Xif ((ep = clst) == NULL)
X  return(NULL);
Xelse
X  {
X  while (ep->nxtbin != NULL)
X    ep = ep->nxtbin;
X  return(ep);
X  }
X}
X
Xint bc_sumbinlens(BC_CHR_BIN *blst)
X  /* recursively sum blst */
X{
Xif (blst == NULL)
X  return(0);
Xelse
X  return(bc_sumbinlens(blst->nxtbin) + blst->binlen);
X}
X
Xint int_in_rng(int b1,
X               int x,
X               int b2)
X/* return 1 if b1 <= x <= b2 or
Xb2 <= x <= b1 */
X{
Xif (b1 <= b2)
X  return((b1 <= x) && (x <= b2));
Xelse
X  return(int_in_rng(b2,x,b1));
X}
X
XBC_REGN_ELT *bc_appndrgnelt(BC_REGN_ELT **lstrt,
X                            int rgstart,
X                            int rgstop)
X/* create and append a new element to *lstrt,
X Return address of new element */
X{
XBC_REGN_ELT *prev, *end_ptr;
X
Xif (lstrt != NULL)
X  {
X  prev = end_ptr = *lstrt;
X  while (end_ptr != NULL)
X    {
X    prev = end_ptr;
X    end_ptr = end_ptr->nxtregn;
X    }
X  end_ptr = (BC_REGN_ELT *) getmemory(sizeof(BC_REGN_ELT),"region elt");
X  end_ptr->nxtregn = NULL;
X  end_ptr->rstart = rgstart;
X  end_ptr->rstop = rgstop;
X  if (*lstrt == NULL)
X    {
X    *lstrt = end_ptr;
X    end_ptr->prvregn = NULL;
X    }
X  else
X    {
X    prev->nxtregn = end_ptr;
X    end_ptr->prvregn = prev;
X    }
X  return(end_ptr);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid bc_delregnelt(BC_REGN_ELT *ep,
X                    BC_REGN_ELT **lstrt)
X/* delete ep from list *lstrt */
X{
XBC_REGN_ELT *pt;
X
Xif (ep != NULL)
X  {
X  if ((pt = ep->prvregn) == NULL)
X    *lstrt = ep->nxtregn;
X  else
X    pt->nxtregn = ep->nxtregn;
X  if ((pt = ep->nxtregn) != NULL)
X    pt->prvregn = ep->prvregn;
X  memfree(ep);
X  }
X}
X
Xvoid bc_clrallregnelts(BC_REGN_ELT **lstrt)
X  /* iteratively delete all of lstrt */
X{
Xwhile (*lstrt != NULL)
X  bc_delregnelt(*lstrt,lstrt);
X}
X
Xint bc_cntregnelts(BC_REGN_ELT *clst)
X  /* recursively count list elements */
X{
Xif (clst == NULL)
X  return(0);
Xelse
X  return(bc_cntregnelts(clst->nxtregn) + 1);
X}
X
XBC_REGN_ELT *bc_regnelt4pos(BC_REGN_ELT *rlst,
X                            int pos)
X/* return the region element corresponding to pos, if any */
X{
XBC_REGN_ELT *rp;
X
Xrp = rlst;
Xwhile (rp != NULL)
X  if (int_in_rng(rp->rstart,pos,rp->rstop))
X    return(rp);
X  else
X    rp = rp->nxtregn;
X/* fell off end, reurn NULL */
Xreturn(NULL);
X}
X
XBC_CHR_BIN *bc_cntbin4pos(BC_CHR_BIN *blst,
X                          int posn)
X/* return a pointer to the bin that contains posn.
XNULL if none */
X{
XBC_CHR_BIN *bp;
X
Xbp = blst;
Xwhile (bp != NULL)
X  if (int_in_rng(bp->spos,posn,(bp->spos + bp->binlen -1)))
X    return(bp);
X  else
X    bp = bp->nxtbin;
X/* fell off end, return NULL */
Xreturn(NULL);
X}
X
Xint bc_readsrcfl(BC_CHR_BIN *bnlsts[],
X                 FILE *sfl,
X                 RBC_CHRNO uchrno,
X                 BC_REGN_ELT *exclud[],
X                 RBC_CHRNO mxchr)
X/* use fscanf to read successive lines from sfl.
XIf uchrno is nonzero, then only do that chromosome */
X{
Xchar chrstr[5];
Xint sqpos;
Xchar sensestr[5];
Xint matcnt;
Xint chrno;
Xint scnt;
XBC_CHR_BIN *bp;
Xint prvchrno;
XBC_REGN_ELT *xcld;
X
Xmatcnt = 0;
X
X#ifdef LEGACY_MODE
X
Xwhile ((scnt = fscanf(sfl,"%s %d %s",&chrstr[0],&sqpos,&sensestr[0])) != EOF)
X  if ((scnt == 3) && ((chrno = rbc_str2chrno(&chrstr[0])) > Chr_unk) &&
X        (chrno <= mxchr) && ((uchrno == 0) || (chrno == uchrno)))
X    {
X    if (((xcld = bc_regnelt4pos(exclud[chrno-1],sqpos)) == NULL) &&
X         ((bp = bc_cntbin4pos(bnlsts[chrno-1],sqpos)) != NULL))
X      {   
X      if (sensestr[0] == '+')
X        bp->bcntfwd++;
X      else
X        bp->bcntrev++;
X      matcnt++;
X      }
X    }
X
X#else    /* LEGACY_MODE */
X
Xprvchrno = 0;
Xbp = NULL;
Xwhile ((scnt = fscanf(sfl,"%s %d %s",&chrstr[0],&sqpos,&sensestr[0])) != EOF)
X  if ((scnt == 3) && ((chrno = rbc_str2chrno(&chrstr[0])) > Chr_unk) &&
X        (chrno <= mxchr) && ((uchrno == 0) || (chrno == uchrno)))
X      {
X      if (prvchrno != chrno)
X        {
X        bp = NULL;
X        prvchrno = 0;
X        }
X      if ((bp != NULL) && !int_in_rng(bp->spos,sqpos,(bp->spos + bp->binlen -1)))
X        {
X        bp = NULL;
X        prvchrno = 0;
X        }
X      xcld = bc_regnelt4pos(exclud[chrno-1],sqpos);
X      if ((bp == NULL) && (xcld == NULL))
X        bp = bc_cntbin4pos(bnlsts[chrno-1],sqpos);
X      if ((bp != NULL) && (xcld == NULL))
X        {
X        if (sensestr[0] == '+')
X          bp->bcntfwd++;
X        else
X          bp->bcntrev++;
X        matcnt++;
X        prvchrno = chrno;
X        }
X      }
X
X#endif    /* LEGACY_MODE (else) */
X
Xreturn(matcnt);
X}
X
Xint bc_chknreadsrcfl(BC_CHR_BIN *bnlsts[],
X                     FILE *sfl,
X                     RBC_CHRNO uchrno,
X                     BC_REGN_ELT *exclud[],
X                     RBC_CHRNO mxchr)
X/* check sfl for openness, then call bc_readsrcfl, returning number
Xelements read */
X{
Xif (sfl == NULL) /* can't do anything */
X  return(0);
Xelse
X  return(bc_readsrcfl(bnlsts,sfl,uchrno,exclud,mxchr));
X}
X
Xint rbc_getgenomesizs(char *hdrstr,
X                      int seqlens[],
X                      int chrmax,
X                      RBC_CHRNO uchrno)
X/* use hdrstr to create a series of file names, one
Xfor each chromosome, open each as a Fasta sequence
Xfile and scan for the sequence length.  Return the
Xnumber of chromosomes processed. if uchrno is nonzero
Xthen restrict activity to that alone */
X{
Xchar *sqfnam;
Xint chno;
Xint nblen;
XSQFL_STRCT *chsqfl;
Xint rcnt;
X
Xrcnt = 0;
Xsqfnam = (char *) getmemory((nblen = strlen(hdrstr) + 16),"Sq file name buf");
Xfor (chno = 1; chno <= chrmax; chno++)
X  {
X  seqlens[chno-1] = 0;
X  if ((uchrno == 0) || (chno == uchrno))
X    {
X    snprintf(sqfnam,nblen-1,"%s%s.fa",hdrstr,rbc_chrno2str((RBC_CHRNO) chno,1));
X    if ((chsqfl = sqfl_opnsqstrct(sqfnam,SFMT_fasta,"r")) != NULL)
X      {
X      seqlens[chno-1] = readsrcsq(chsqfl,NULL);
X      if (debuglevel > RBC_dbg_on)
X        {
X        fprintf(stdout,"%s: %d res\n",sqfnam,seqlens[chno-1]);
X        fflush(stdout);
X        }
X      sqfl_clssqstrct(chsqfl);
X      rcnt++;
X      }
X    else
X      err_msg("Can't open chromosome file %s\n",sqfnam);
X    }
X  }
Xreturn(rcnt);
X}
X
Xint rbc_getgenomesqs(char *hdrstr,
X                     char *seqsarr[],
X                     int seqlens[],
X                     int chrmax,
X                     RBC_CHRNO uchrno)
X/* use hdrstr to create a series of file names, one
Xfor each chromosome, open each as a Fasta sequence
Xfile and create a buffer for each.  Return the
Xnumber of chromosomes processed */
X{
Xchar *sqfnam;
Xint chno;
Xint nblen;
XSQFL_STRCT *chsqfl;
Xint rcnt;
X
Xrcnt = 0;
Xsqfnam = (char *) getmemory((nblen = strlen(hdrstr) + 16),"Sq file name buf");
Xfor (chno = 1; chno <= chrmax; chno++)
X  if ((uchrno == 0) || (uchrno == chno))
X    {
X    snprintf(sqfnam,nblen-1,"%s%s.fa",hdrstr,rbc_chrno2str((RBC_CHRNO) chno,1));
X    if ((chsqfl = sqfl_opnsqstrct(sqfnam,SFMT_fasta,"r")) != NULL)
X      {
X      seqlens[chno-1] = readsrcsq(chsqfl,NULL);
X      if (debuglevel > RBC_dbg_on)
X        {
X        fprintf(stdout,"%s: %d res,",sqfnam,seqlens[chno-1]);
X        fflush(stdout);
X        }
X      seqsarr[chno-1] = (char *) getmemory(seqlens[chno-1]+1,"Chr Buff");
X      sqfl_rewind(chsqfl);
X      (void) readsrcsq(chsqfl,seqsarr[chno-1]);
X      sqfl_clssqstrct(chsqfl);
X      if (debuglevel > RBC_dbg_on)
X        {
X        fprintf(stdout,"'%.10s...'\n",seqsarr[chno-1]);
X        fflush(stdout);
X        }
X      rcnt++;
X      }
X    else
X      {
X      err_msg("Can't open chromosome file %s\n",sqfnam);
X      seqlens[chno-1] = 0;
X      }
X    }
X  else
X    {
X    seqlens[chno-1] = 0;
X    seqsarr[chno-1] = NULL;
X    }
Xreturn(rcnt);
X}
X
Xchar tr_int2nares(int iv)
X  /* return a nucleic acid residue for iv */
X{
Xswitch (iv)
X  {
X  case 0:
X    return('a');
X    break;
X  case 1:
X    return('c');
X    break;
X  case 2:
X    return('g');
X    break;
X  case 3:
X    return('t');
X    break;
X  default:
X    return('?');
X    break;
X  }
X}
X
Xint tr_nares2int(char res)
X  /* return an int value 0..3 for res, -1 for unknown */
X{
Xswitch (toupper(res))
X  {
X  case 'A':
X    return(0);
X    break;
X  case 'C':
X    return(1);
X    break;
X  case 'G':
X    return(2);
X    break;
X  case 'T':
X  case 'U':
X    return(3);
X    break;
X  default:
X    return(-1);
X    break;
X  }
X}
X
Xint rbc_scangenomesqs(char *hdrstr,
X                      int chrmax,
X                      RBC_CHRNO uchrno,
X                      FS_FSMSTRCT *cpgfsmp)
X/* use hdrstr to create a series of file names, one
Xfor each chromosome, open each as a Fasta sequence
Xfile and create a buffer for each.  Return the
Xnumber of chromosomes processed */
X{
Xchar *sqfnam;
Xint chno;
Xint nblen;
XSQFL_STRCT *chsqfl;
Xint rcnt;
Xchar nxtres;
Xint cpos;
XFS_RESELT *frp;
XFS_DATPRELT *dpep;
X
Xrcnt = 0;
Xsqfnam = (char *) getmemory((nblen = strlen(hdrstr) + 16),"Sq file name buf");
Xfor (chno = 1; chno <= chrmax; chno++)
X  if ((uchrno == 0) || (uchrno == chno))
X    {
X    snprintf(sqfnam,nblen-1,"%s%s.fa",hdrstr,rbc_chrno2str((RBC_CHRNO) chno,1));
X    if (((chsqfl = sqfl_opnsqstrct(sqfnam,SFMT_fasta,"r")) != NULL) &&
X            sqfl_skipsqflhdr(chsqfl))
X      {
X      fs_initrun(cpgfsmp);
X      cpos = 0;
X      while ((nxtres = sqfl_getnxtres(chsqfl)) != '\0')
X        {
X        cpos++;
X        if ((frp = fs_procchr(cpgfsmp,nxtres,tr_nares2int)) != NULL)
X          {
X          dpep = (FS_DATPRELT *) frp->action;
X          fprintf(stdout,"C%s: %d\n",rbc_chrno2str(chno,1),
X                    (cpos-dpep->ldstr+1));
X          }
X        }
X      rcnt++;
X      }
X    else
X      err_msg("Can't open chromosome file %s\n",sqfnam);
X    }
Xmemfree(sqfnam);
Xreturn(rcnt);
X}
X
XFILE *bc_opnsqmonkdatfl(char *dirhdr,
X                        RBC_CHRNO cno,
X                        char *ext)
X/* attempt to create a destination file for cno
Xwith dirhdr + ext and open for writing */
X{
XFILE *ofl;
Xchar *dfname;
X
Xif (asprintf(&dfname,"%s%s%s",((dirhdr!=NULL)?dirhdr:""),
X               rbc_chrno2str(cno,1),((ext!=NULL)?ext:".dat")) > 0)
X  {
X  ofl = fopen(dfname,"w");
X  free(dfname);
X  return(ofl);
X  }
Xelse
X  return(NULL);
X}
X
Xint bc_redrepgenomsqs(char *hdrstr,
X                      int chrmax,
X                      RBC_CHRNO uchrno,
X                      FS_FSMSTRCT *cpgfsmp,
X                      BC_CHR_BIN *chrbins[],
X                      char *seqsarr[],
X                      int seqlens[])
X/* use hdrstr to create a series of file names, one
Xfor each chromosome, open each as a Fasta sequence
Xfile.  Scan with cpgfsmp (CCGG) and create bins, giving
Xa count of CpG found with CG.  Return the
Xnumber of chromosomes processed.
Xif seqsarr[] & seqlens != NULL, then
Xstore seq therein and set final length */
X{
Xchar *sqfnam;
Xint chno;
Xint nblen;
XSQFL_STRCT *chsqfl;
Xint rcnt;
Xchar nxtres;
Xint cpos;
XFS_RESELT *frp;
XFS_DATPRELT *dpep;
Xint thismat;
Xint prvmat;
Xint thislen;
XBC_CHR_BIN *binsend;
Xint cpgs;
X
Xrcnt = 0;
Xsqfnam = (char *) getmemory((nblen = strlen(hdrstr) + 16),"Sq file name buf");
Xfor (chno = 1; chno <= chrmax; chno++)
X  if ((uchrno == 0) || (uchrno == chno))
X    {
X    snprintf(sqfnam,nblen-1,"%s%s.fa",hdrstr,rbc_chrno2str((RBC_CHRNO) chno,1));
X    if ((chsqfl = sqfl_opnsqstrct(sqfnam,SFMT_fasta,"r")) != NULL)
X      {
X      thislen = readsrcsq(chsqfl,NULL);
X      if (seqsarr != NULL)
X        seqsarr[chno-1] = (char *) getmemory(thislen+1,"SeqBuf");
X      if (seqlens != NULL)
X        seqlens[chno-1] = thislen;
X      sqfl_rewind(chsqfl);
X      (void) sqfl_skipsqflhdr(chsqfl);
X      fs_initrun(cpgfsmp);
X      cpos = 0;
X      prvmat = 1;
X      binsend = NULL;
X      cpgs = 0;
X      while ((nxtres = sqfl_getnxtres(chsqfl)) != '\0')
X        {
X        if (seqsarr != NULL)
X          {
X          *(seqsarr[chno-1] + cpos) = nxtres;
X          *(seqsarr[chno-1] + cpos + 1) = '\0';
X          }
X        cpos++;
X        if ((frp = fs_procchr(cpgfsmp,nxtres,tr_nares2int)) != NULL)
X          {
X          dpep = (FS_DATPRELT *) frp->action;
X/*          if (debuglevel > RBC_dbg_none)
X             fprintf(stdout,"Match: %s @ %d\n",dpep->dstrng,cpos); */
X          if (dpep->ldstr == 4)      /* MspI site */
X            {
X            thismat = cpos-dpep->ldstr+2;  /* MspI cuts C/CGG */
X            thislen = thismat - prvmat;
X/*            if (debuglevel > RBC_dbg_none)
X              fprintf(stdout,"saving: %d %d\n",prvmat,thislen); */
X            binsend = rbc_appndbin(&binsend,prvmat,thislen);
X            binsend->cpgcnt = cpgs;
X            cpgs = 0;
X            if (chrbins[chno-1] == NULL)
X              chrbins[chno-1] = binsend;
X            prvmat = thismat;
X            }
X          else
X            if (dpep->ldstr == 2)  /* CpG */
X              cpgs++;
X          }
X        }
X      rcnt++;
X      }
X    else
X      err_msg("Can't open chromosome file %s\n",sqfnam);
X    }
Xmemfree(sqfnam);
Xreturn(rcnt);
X}
X
Xvoid rbc_rptchrout(FILE *ofl,
X                   char c,
X                   int ccnt)
X/* put c out ccnt times to ofl */
X{
Xwhile (ccnt-- > 0)
X  fputc(c,ofl);
X}
X
Xdouble bin_coeff(int n,
X                 int k)
X/* return as double the binomial
Xcoefficient of n,k.  Multiplicative
Xformula */
X{
Xdouble prodct;
Xint i;
X
Xprodct = 1.0;
Xfor (i = 1; i <= k; i++)
X  prodct *= (double) (n - k + i)/((double) i);
Xreturn(prodct);
X}
X
Xdouble fishers_exact_t1(int a,
X                        int b,
X                        int c,
X                        int d)
X/* return a value for Fisher's exact
Xstatistic - one tailed */
X{
Xdouble rval;
Xint tot;
X
Xtot = a + b + c + d;
Xrval = (bin_coeff(a+b,a) / bin_coeff(tot,a+c)) * bin_coeff(c+d,c);
Xreturn(rval);
X}
X
Xint bc_getexcludregns(FILE *efl,
X                      BC_REGN_ELT *eregns[],
X                      RBC_CHRNO maxcno)
X/* read lines from efl (fmt: chrno regstart regstop\n)
Xand append to appropriate chromosome no list */
X{
XRBC_CHRNO cno;
Xint rgstart;
Xint rgstop;
Xint rdval;
Xchar cstr[32];
Xint rcnt;
X
Xrcnt = 0;
Xwhile ((rdval = fscanf(efl,"%s %d %d",&cstr[0],&rgstart,&rgstop)) != EOF)
X  if ((rdval == 3) && ((cno = rbc_str2chrno(&cstr[0])) >= Chr1) && (cno <= ChrY))
X    {
X    (void) bc_appndrgnelt(&eregns[cno-1],rgstart,rgstop);
X    rcnt++;
X    }
Xreturn(rcnt);
X}
X
Xvoid bc_commalst2ints(char *str,
X                      int *v1,
X                      int *v2)
X/* expect str to contain two base10 integers separated by a comma.
Xattempt to read these and return as v1 & v2.  zero return on
Xfailures */
X{
Xchar *ep;
Xchar *fp;
X
X*v1 = *v2 = 0;
X*v1 = (int) strtol(str,&ep,10);
Xif (ep != str)
X  *v2 = strtol(ep+1,&fp,10);
X}
X
Xint bc_fragsizeok(int fragmin,
X                  int fragmax,
X                  int fragsize)
X/* return if fragsize fragment is acceptable,
Xnoting that zero limits will always return true. */
X{
Xif ((fragmin != 0) && (fragmax != 0))
X  return(int_in_rng(fragmin,fragsize,fragmax));
Xelse
X  return(1);
X}
X
Xint bc_cpglmttest(int cpgmin,
X                  int cpgcnt)
X/* return 1 if cpgcnt passes cpgmin, noting
Xthat 0 cpgmin will always return true */
X{
Xif (cpgmin <= 0)
X  return(1);
Xelse
X  return(cpgcnt >= cpgmin);
X}
X
Xint bc_binundercpglmt(BC_CHR_BIN *bp,
X                      int cpgmin)
X/* apply minimum CpG count test to bin, noting
Xthat cgpmin <= 0 will always fail */
X{
Xif (bp != NULL)
X  return(!bc_cpglmttest(cpgmin,bp->cpgcnt));
Xelse
X  return(1);
X}
X
Xint bc_prunebins4len(BC_CHR_BIN *binlsts[],
X                     RBC_CHRNO maxchr,
X                     int minfrag,
X                     int maxfrag)
X/* scan all or selected chromosome bin lists, removing all
Xbins which don't conform to minfrag..maxfrag (inclusive).
XReturn count of deleted bins */
X{
XRBC_CHRNO chrno;
XBC_CHR_BIN *bp;
Xint delcnt;
XBC_CHR_BIN *nxt;
X
Xdelcnt = 0;
Xfor (chrno = Chr1; chrno <= maxchr; chrno++)
X  {
X  bp = binlsts[chrno-1];
X  while (bp != NULL)
X    {
X    nxt = bp->nxtbin;
X    if (!bc_fragsizeok(minfrag,maxfrag,bp->binlen))
X      {
X/*      if (debuglevel > RBC_dbg_none)
X        fprintf(stdout,"Del: %d..%d (%d), CpGs=%d\n",bp->spos,bp->spos + bp->binlen -1,bp->binlen,bp->cpgcnt); */
X      rbc_delcntbin(bp,&binlsts[chrno-1]);
X      delcnt++;
X      }
X    bp = nxt;
X    }
X  }
Xreturn(delcnt);
X}
X
Xint bc_prunebinslenok(BC_CHR_BIN *binlsts[],
X                      RBC_CHRNO maxchr,
X                      int minfrag,
X                      int maxfrag)
X/* scan all or selected chromosome bin lists, removing all
Xbins which do conform to minfrag..maxfrag (inclusive).
XReturn count of deleted bins */
X{
XRBC_CHRNO chrno;
XBC_CHR_BIN *bp;
Xint delcnt;
XBC_CHR_BIN *nxt;
X
Xdelcnt = 0;
Xfor (chrno = Chr1; chrno <= maxchr; chrno++)
X  {
X  bp = binlsts[chrno-1];
X  while (bp != NULL)
X    {
X    nxt = bp->nxtbin;
X    if (bc_fragsizeok(minfrag,maxfrag,bp->binlen))
X      {
X/*      if (debuglevel > RBC_dbg_none)
X        fprintf(stdout,"Del: %d..%d (%d), CpGs=%d\n",bp->spos,bp->spos + bp->binlen -1,bp->binlen,bp->cpgcnt); */
X      rbc_delcntbin(bp,&binlsts[chrno-1]);
X      delcnt++;
X      }
X    bp = nxt;
X    }
X  }
Xreturn(delcnt);
X}
X
Xint bc_prunebins4cpgmin(BC_CHR_BIN *binlsts[],
X                        RBC_CHRNO maxchr,
X                        int mincpg)
X/* scan all or selected chromosome bin lists, removing all
Xbins which don't meet mincpg criterion.
XReturn count of deleted bins */
X{
XRBC_CHRNO chrno;
XBC_CHR_BIN *bp;
Xint delcnt;
XBC_CHR_BIN *nxt;
X
Xdelcnt = 0;
Xfor (chrno = Chr1; chrno <= maxchr; chrno++)
X  {
X  bp = binlsts[chrno-1];
X  while (bp != NULL)
X    {
X    nxt = bp->nxtbin;
X
X    if (bc_binundercpglmt(bp,mincpg))
X      {
X/*      if (debuglevel > RBC_dbg_none)
X        fprintf(stdout,"Del: %d..%d (%d), CpGs=%d\n",bp->spos,bp->spos + bp->binlen -1,bp->binlen,bp->cpgcnt); */
X      rbc_delcntbin(bp,&binlsts[chrno-1]);
X      delcnt++;
X      }
X    bp = nxt;
X    }
X  }
Xreturn(delcnt);
X}
X
Xint bc_losefailedbins(BC_CHR_BIN *binlsts[],
X                      RBC_CHRNO maxchr,
X                      int minfrag,
X                      int maxfrag,
X                      int cpgmin)
X/* scan all or selected chromosome bin lists, removing all
Xbins which do conform to minfrag..maxfrag (inclusive) and
Xfail any cpgmin criterion.
XReturn count of deleted bins */
X{
Xreturn(bc_prunebins4len(binlsts,maxchr,minfrag,maxfrag) +
X         bc_prunebins4cpgmin(binlsts,maxchr,cpgmin));
X}
X
Xint bc_adjacentbins(BC_CHR_BIN *b1,
X                    BC_CHR_BIN *b2)
X/* return true if b1 & b2 are adjacent with
Xno intervening gap */
X{
Xif ((b1 == NULL) || (b2 == NULL))
X  return(0);
Xelse
X  if (b1->spos > b2->spos)
X    return(bc_adjacentbins(b2,b1));
X  else
X    return((b1->spos + b1->binlen) == b2->spos);
X}
X
Xint bc_amlgmatelocpgbins(BC_CHR_BIN *cbinlst[],
X                         RBC_CHRNO maxchr,
X                         int minfrag,
X                         int maxfrag,
X                         int cpgmin)
X/* scan cbinlst for bins which may fail a CpG count
Xbut which could be amalgamated with adjacent bins to
Xpass the CpG count criterion implied by cpgmin.
XAmalgamate valid bins.  Note that this may leave bins
Xthat exceed length criteriam but if these are
Xmade by joining valid adjacent bins, then the
Xsize selection during restricted representation library
Xpreparation should have left valid reads for those
Xregions.  Return number of bins pruned or amalgamated */
X{
Xint abincnt;
XRBC_CHRNO chrno;
XBC_CHR_BIN *bp;
XBC_CHR_BIN *nxt;
X
Xabincnt = bc_prunebins4len(cbinlst,maxchr,minfrag,maxfrag);
Xfor (chrno = Chr1; chrno <= maxchr; chrno++)
X  {
X  bp = cbinlst[chrno-1];
X  while (bp != NULL)
X    {
X    nxt = bp->nxtbin;
X    if (bc_adjacentbins(bp,nxt) &&
X          (bc_binundercpglmt(bp,cpgmin) || bc_binundercpglmt(nxt,cpgmin))
X             && bc_cpglmttest(cpgmin,(bp->cpgcnt + nxt->cpgcnt)))
X      {  /* checks that bins are adjacent, one or other fails cpg criterion & together they pass it */
X/*          if (debuglevel > RBC_dbg_none)
X            fprintf(stdout,"C%s amalgamating %d..%d (%d) & %d..%d (%d) with %d+%dCpGs\n",
X                      rbc_chrno2str(chrno,1),bp->spos,(bp->spos+bp->binlen-1),bp->binlen,
X                      nxt->spos,(nxt->spos+nxt->binlen-1),nxt->binlen,bp->cpgcnt,nxt->cpgcnt); */
X      bp->binlen += nxt->binlen;
X      bp->cpgcnt += nxt->cpgcnt;
X      bp->bcntfwd += nxt->bcntfwd;
X      bp->bcntrev += nxt->bcntrev;
X      rbc_delcntbin(nxt,&cbinlst[chrno-1]);
X      abincnt++;
X      }
X    bp = bp->nxtbin;
X    }
X/* now prune failed cpg bins */
X  abincnt += bc_prunebins4cpgmin(cbinlst,maxchr,cpgmin);
X  }
Xreturn(abincnt);
X}
X
XBC_CHR_BIN *bc_dupbinlst(BC_CHR_BIN *blstp)
X  /* for every bin in blstp generate a new bin, init the
Xcontents of each bin to those in blstp list */
X{
XBC_CHR_BIN *bp;
XBC_CHR_BIN *ep;
XBC_CHR_BIN *newlst;
X
Xbp = blstp;
Xep = newlst = NULL;
Xwhile (bp != NULL)
X  {
X  ep = rbc_appndbin(&ep,bp->spos,bp->binlen);
X  if (newlst == NULL)
X    newlst = ep;
X  ep->cpgcnt = bp->cpgcnt;
X  ep->bcntfwd = bp->bcntfwd;
X  ep->bcntrev = bp->bcntrev;
X  bp = bp->nxtbin;
X  }
Xreturn(newlst);
X}
X
XBC_CHR_BIN *bc_genlstforgaps(BC_CHR_BIN *blstp)
X  /* generate a bin for each gap in blstp..., return the
Xstart of the list */
X{
XBC_CHR_BIN *bp;
XBC_CHR_BIN *ep;
XBC_CHR_BIN *newlst;
XBC_CHR_BIN *nxt;
Xint newstrt;
Xint newlen;
X
Xbp = blstp;
Xnewlst = NULL;
Xep = NULL;
Xwhile (bp != NULL)
X  {
X  if ((nxt = bp->nxtbin) != NULL)
X    {
X    if (!bc_adjacentbins(bp,nxt))
X      {
X      newstrt = bp->spos + bp->binlen;
X      newlen = nxt->spos - newstrt;
X      ep = rbc_appndbin(&ep,newstrt,newlen);
X      if (newlst == NULL)
X        newlst = ep;
X      }  
X    bp = nxt;
X    }
X  else
X    bp = NULL;
X  }
Xreturn(newlst);
X}
X
Xint bc_hypometh(BC_CHR_BIN *bp)
X  /* return 1 if this is not hypomethylated:
XThe requirement is stated by Li, et al. (2010) PLOSBiology,11,e1000533,
Xbut is not actually defined by them.  Let's try some simple scheme
Xfor now */
X{
Xreturn(bp->bcntfwd <= 0);
X}
X
Xint bc_2foldmethdiff(BC_CHR_BIN *b1p,
X                     BC_CHR_BIN *b2p)
X/* test if the methylation difference between
Xb1p & b2p is >= 2 fold */
X{
Xfloat b1prop;
Xfloat b2prop;
Xfloat flddiff;
X
Xif ((b1p->bcntfwd > 0) && (b2p->bcntfwd > 0)
X     && (b1p->bcntrev > 0) && (b2p->bcntrev > 0)) 
X  {
X  b1prop = (float) b1p->bcntfwd/b1p->bcntrev;
X  b2prop = (float) b2p->bcntfwd/b2p->bcntrev;
X  flddiff = b1prop/b2prop;
X  return((flddiff >= 2.0) || (flddiff <= 0.5));
X  }
Xelse
X  return(0);
X}
X
Xvoid bc_scandiffmethbins(FILE *ofl,
X                         BC_CHR_BIN *bins1p[],
X                         BC_CHR_BIN *bins2p[],
X                         RBC_CHRNO maxchr)
X/* scan binsNp (N=1 & 2) which are expected to have
Xidentical partitions.  Perform tests of
XLi, et al. (2010) PLOSBiology,11,e1000533 for
Xdifferential methylation - print results to ofl */
X{
XBC_CHR_BIN *b1p;
XBC_CHR_BIN *b2p;
XRBC_CHRNO chrno;
X
Xfor (chrno = Chr1; chrno <= maxchr; chrno++)
X  {
X  b1p = bins1p[chrno-1];
X  b2p = bins2p[chrno-1];
X  while ((b1p != NULL) && (b2p != NULL))
X    {
X    if ((b1p->spos != b2p->spos) || (b1p->binlen != b2p->binlen))
X      fprintf(ofl,"Inconsistent Dmeth bins: Chr %s (%d..%d) vs (%d..%d)\n",
X                rbc_chrno2str(chrno,1),b1p->spos,(b1p->spos+b1p->binlen-1),
X                b2p->spos,(b2p->spos+b2p->binlen-1));
X    else
X      if ((b1p->cpgcnt >= 5) && !bc_hypometh(b1p) && !bc_hypometh(b2p) && bc_2foldmethdiff(b1p,b2p))
X        {
X        fprintf(ofl,"C%s\t%d..%d\t%d\t%d CpGs\t1: %d+ %d-\t2: %d+ %d-",
X                  rbc_chrno2str(chrno,1),b1p->spos,(b1p->spos+b1p->binlen-1),
X                  b1p->binlen,b1p->cpgcnt,b1p->bcntfwd,b1p->bcntrev,
X                  b2p->bcntfwd,b2p->bcntrev);
X        fprintf(ofl,"\tPr= %g",
X                  fishers_exact_t1(b1p->bcntfwd,b1p->bcntrev,b2p->bcntfwd,b2p->bcntrev));
X        fputc('\n',ofl);
X        }
X    b1p = b1p->nxtbin;
X    b2p = b2p->nxtbin;
X    }
X  }
X}
X
Xvoid bc_mksqmnkhdr(FILE *fl,
X                   char *gnamstr,
X                   RBC_CHRNO cno,
X                   int sqlen,
X                   int minfrag,
X                   int maxfrag)
X/* put a header section to fl in style of SeqMonk
X.dat files */
X{
Xfprintf(fl,"ID   C%sRR; RR 1; linear; genomic DNA; STD; PRO: %d BP.\n",
X          rbc_chrno2str(cno,1),sqlen);
Xfprintf(fl,"AC   chromosome:RedRep%d_%d:Chr%s:1:%d:1\n",minfrag,maxfrag,
X          rbc_chrno2str(cno,1),sqlen);
Xfprintf(fl,"DE   Reduced Representation (%d-%dbp) of %s Chr%s\n",
X          minfrag,maxfrag,((gnamstr==NULL)?"GRCh37":gnamstr),
X          rbc_chrno2str(cno,1));
Xfprintf(fl,"FH   Key             Location/Qualifiers\nFH\n");
X}
X
Xvoid bc_bascnt4regn(char *seq,
X                    int sqlen,
X                    int rstart,
X                    int rstop,
X                    int bascnt[])
X/* scan region rstart..rstop of seq, adding residues to
Xbascnt[] */
X{
Xint sp;
XSQ_RESTYPE rt;
X
Xsp = rstart;
Xrstop = imin(rstop,sqlen);
Xwhile (sp <= rstop)
X  {
X  rt = sqfl_chr2narestype(*(seq+sp));
X  bascnt[rt]++;
X  sp++;
X  }
X}
X
Xint main(int argc,
X         char *argv[])
X{
Xint ap;
Xchar op;
Xint ecnts;
XFILE *srcfl;
XBC_CHR_BIN *chrbinlsts[ChrY];  /* bin lists for each chromosome */
Xint chrlens[ChrY];       /* length each chromosome */
Xchar *genomsqhdrstr;         /* header string for genomic sequences */
Xint chrcnt;
XBC_CHR_BIN *bp;
XRBC_CHRNO chrno;
XBC_CHR_BIN *chrbinends[ChrY];  /* bin ends for faster processing */
Xint sqpos;
Xint ubinlen;
Xint plustot;
Xint minustot;
Xint uchrno;    /* user has specified a chromosome, 0=>all */
Xchar *fendp;
Xchar *chromseq[ChrY];  /*seqs of each chromosome */
Xchar *cp;
Xint cpgcnt;
Xint bstart;
XBC_REGN_ELT *exclud[ChrY];
XFILE *xcldfl;
XFS_FSMSTRCT *cpgfsmp;    /* ptr to CpG searching fsm */
Xint minfrag;
Xint maxfrag;
Xint totlen;
Xint binend;
Xint prvbinend;
XFILE *srcfl2;
Xint bincnt;
Xint cpgmin;
Xint amlgmate;
XBC_CHR_BIN *chrbinsalt[ChrY];  /* alternate set of character bins */
Xint sumplustot;
Xint summinustot;
Xchar *sqmonkhdrstr;
XFILE *dfile;
Xint fcnt;
Xint frgpos;
Xint bascnt[RES_t+1];
XSQ_RESTYPE resp;
X
Xdebuglevel = RBC_dbg_none;
Xomode = BC_out_none;
Xsrcstyle = RBC_src_rmapbs;
Xecnts = 0;
Xsrcfl = srcfl2 = NULL;
Xsqmonkhdrstr = genomsqhdrstr = NULL;
Xuchrno = 0;
Xubinlen = BC_DEF_BINLEN;
Xcpgfsmp = fs_initnewfsm(4,1,FS_inv_ignor);
Xminfrag = maxfrag = cpgcnt = cpgmin = 0;
Xamlgmate = 0;
Xdfile = NULL;
Xfor (chrno = Chr1; chrno <= ChrY; chrno++)
X  exclud[chrno] = NULL;
Xfor (ap = 1; ap < argc; ap++)
X  if (*argv[ap] == '-')   /* an option */
X    switch (op = *(argv[ap]+1))
X      {
X      case 'b':    /* bin length */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer\n",op);
X        else
X          {
X          ubinlen = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          else
X            if (ubinlen <= 0)
X              err_msg_die("Invalid bin length '%s'\n",argv[ap]);
X          }
X        break;
X      case 'r':
X        if (++ap > argc)
X          err_msg_die("-%c needs file name\n",op);
X        else
X          if ((srcfl = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open .BED file %s\n",argv[ap]);
X        break;
X      case 'R':
X        if (++ap > argc)
X          err_msg_die("-%c needs file name\n",op);
X        else
X          if ((srcfl2 = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open .BED file %s\n",argv[ap]);
X        break;
X      case 'g':
X        if (++ap > argc)
X          err_msg_die("-%c needs header string\n",op);
X        else
X          genomsqhdrstr = bas_strdup(argv[ap]);
X        break;
X      case 'd':   /* debug on */
X        debuglevel = RBC_dbg_on;
X        break;
X      case 'D':   /* debug^2 on */
X        debuglevel = RBC_dbg_serious;
X        break;
X      case 'c':   /* a chromosome */
X        if (++ap > argc)
X          err_msg_die("-%c needs a chromosome identifier (1..20,X,Y)\n",op);
X        else
X          if ((uchrno = rbc_str2chrno(argv[ap])) == Chr_unk)
X            err_msg_die("Can't determine Chromosome '%s'\n",argv[ap]);
X        break;
X      case 'l':         /* give listing */
X        omode = BC_out_list;
X        break;
X      case 'L':         /* list non zero bins */
X        omode = BC_out_listnz;
X        break;
X      case 'S':         /* generate SeqMonk .dat files */
X        if (++ap > argc)
X          err_msg_die("-%c needs dir header string for .dat files\n",op);
X        else
X          {
X          sqmonkhdrstr = bas_strdup(argv[ap]);
X          omode = BC_out_sqmonkdat;
X          }
X        break;
X      case 'm':         /* diff methylated regions */
X      case 'M':         /* make restricted representation bins */
X      case 'N':         /* ditto, but list them */
X      case 'n':         /* ditto, but include gaps */
X      case 'k':         /* ditto, but show reads which don't map to RR bins */
X      case 'K':         /* like -k but only show totals */
X        switch (op)
X          {
X          case 'm':
X            omode = BC_out_dmthrstrep;
X            break;
X          case 'N':
X            omode = BC_out_rstrreplst;
X            break;
X          case 'k':
X            omode = BC_out_rstrrepmiss;
X            break;
X          case 'K':
X            omode = BC_out_rrmisstots;
X            break;
X          case 'M':
X          default:
X            omode = BC_out_rstrrepbins;
X            break;
X          }
X        if (++ap < argc)
X          if (*argv[ap] != '-')
X            bc_commalst2ints(argv[ap],&minfrag,&maxfrag);
X          else
X            ap--;
X        fs_adddatprs(cpgfsmp,"CCGG","CCGG");
X        fs_adddatprs(cpgfsmp,"CG","CG");
X        (void) fs_bldfsm(cpgfsmp,WLU_CASEIND,0,0,tr_int2nares,fs_chkinpstr,fs_shed2lurec);
X        break;
X      case 'C':       /* -C set minimum CpG no for bins */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer value\n",op);
X        else
X          {
X          cpgmin = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          else
X            if (cpgmin < 0)
X              err_msg_die("Invalid CpG min No.'%s'\n",argv[ap]);
X          }
X        break;
X      case 'x':
X        if (++ap > argc)
X          err_msg_die("-%c needs file name\n",op);
X        else
X          if ((xcldfl = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open exlude file %s\n",argv[ap]);
X          else
X            (void) bc_getexcludregns(xcldfl,&exclud[0],ChrY);
X        break;
X      case 'A':
X        amlgmate = 1;
X        break;
X      case 'h':
X        say_usage(stdout,argv[0]);
X        exit(0);
X        break;
X      default:
X        err_msg("Unknown Option: '%s\n",argv[ap]);
X        say_usage(stderr,argv[0]);
X        exit(1);
X        break;
X      }
X/* should be ready to go now */
Xfor (chrno = Chr1; chrno <= ChrY; chrno++)
X  {
X  chrbinends[chrno-1] = chrbinlsts[chrno-1] = chrbinsalt[chrno-1] = NULL;
X  chrlens[chrno-1] = 0;
X  chromseq[chrno-1] = NULL;
X  }
Xif ((genomsqhdrstr != NULL) && (ubinlen > 0))
X  {
X  switch (omode)
X    {
X    case BC_out_dmthrstrep:
X      if ((srcfl == NULL) || (srcfl2 == NULL))
X        err_msg_die("-m needs 2 read files (-r & -R)\n");
X      else
X        {
X        chrcnt = bc_redrepgenomsqs(genomsqhdrstr,(int) ChrY,uchrno,cpgfsmp,
X                                        &chrbinlsts[0],NULL,NULL);
X        if (debuglevel > RBC_dbg_none)
X          fprintf(stdout,"%d chromosomes read\n",chrcnt);
X        if (amlgmate)
X          (void) bc_amlgmatelocpgbins(&chrbinlsts[0],ChrY,minfrag,maxfrag,cpgmin);
X        else
X          (void) bc_losefailedbins(&chrbinlsts[0],ChrY,minfrag,maxfrag,cpgmin);
X        for (chrno = Chr1; chrno <= ChrY; chrno++)
X          if (chrbinlsts[chrno-1] != NULL)
X            chrbinsalt[chrno-1] = bc_dupbinlst(chrbinlsts[chrno-1]);
X        if ((ecnts = bc_chknreadsrcfl(&chrbinlsts[0],srcfl,uchrno,&exclud[0],ChrY)) <= 0)
X          err_msg_die("Zero reads for -r source file\n");
X        else
X          {
X          fclose(srcfl);
X          if ((ecnts = bc_chknreadsrcfl(&chrbinsalt[0],srcfl2,uchrno,&exclud[0],ChrY)) <= 0)
X            err_msg_die("Zero reads for -R source file\n");
X          else
X            {
X            fclose(srcfl2);
X            bc_scandiffmethbins(stdout,&chrbinlsts[0],&chrbinsalt[0],ChrY);
X            }
X          }
X        }
X      break;
X    case BC_out_rstrreplst:
X      chrcnt = bc_redrepgenomsqs(genomsqhdrstr,(int) ChrY,uchrno,cpgfsmp,
X                                      &chrbinlsts[0],NULL,NULL);
X      if (amlgmate)
X        (void) bc_amlgmatelocpgbins(&chrbinlsts[0],ChrY,minfrag,maxfrag,cpgmin);
X      else
X        (void) bc_losefailedbins(&chrbinlsts[0],ChrY,minfrag,maxfrag,cpgmin);
X      for (chrno = Chr1; chrno <= ChrY; chrno++)
X        if ((bp = chrbinlsts[chrno-1]) != NULL)
X          {
X          prvbinend = 0;
X          totlen = 0;
X          while (bp != NULL)
X            {
X            binend = bp->spos + bp->binlen - 1;
X            fprintf(stdout,"C%s: %d..%d, %d res %d cpG\n",rbc_chrno2str(chrno,1),
X                      bp->spos,binend,bp->binlen,bp->cpgcnt);
X            totlen += bp->binlen;
X            bp = bp->nxtbin;
X            }
X          fprintf(stdout,"#C%s bin total=%d res in %d bins\n",rbc_chrno2str(chrno,1),totlen,
X                    bc_cntcntbins(chrbinlsts[chrno-1]));
X          }
X      break;
X    case BC_out_rstrrepbins:
X    case BC_out_rstrrepmiss:
X    case BC_out_rrmisstots:
X    case BC_out_sqmonkdat:
X      if (omode != BC_out_sqmonkdat)
X        chrcnt = bc_redrepgenomsqs(genomsqhdrstr,(int) ChrY,uchrno,cpgfsmp,
X                                     &chrbinlsts[0],NULL,NULL);
X      else
X        chrcnt = bc_redrepgenomsqs(genomsqhdrstr,(int) ChrY,uchrno,cpgfsmp,
X                                     &chrbinlsts[0],&chromseq[0],&chrlens[0]);
X      if (amlgmate)
X        (void) bc_amlgmatelocpgbins(&chrbinlsts[0],ChrY,minfrag,maxfrag,cpgmin);
X      else
X        (void) bc_losefailedbins(&chrbinlsts[0],ChrY,minfrag,maxfrag,cpgmin);
X      if ((omode == BC_out_rstrrepmiss) || (omode == BC_out_rrmisstots))
X        for (chrno = Chr1; chrno <= ChrY; chrno++)
X          {
X          chrbinsalt[chrno-1] = bc_genlstforgaps(chrbinlsts[chrno-1]);
X          rbc_clrallcntbins(&chrbinlsts[chrno-1]);
X          chrbinlsts[chrno-1] = chrbinsalt[chrno-1];
X          }
X      switch (omode)
X        {
X        case BC_out_sqmonkdat:
X          fcnt = 0;
X          for (chrno = Chr1; chrno <= ChrY; chrno++)
X            if ((bp = chrbinlsts[chrno-1]) != NULL)
X              {
X              if ((dfile = bc_opnsqmonkdatfl(sqmonkhdrstr,chrno,".dat")) == NULL)
X                err_msg_die("Can't open SeqMonk .dat file for Chr%s\n",rbc_chrno2str(chrno,1));
X              bc_mksqmnkhdr(dfile,"GRCh37",chrno,bc_sumbinlens(bp),minfrag,maxfrag);
X              frgpos = 1;
X              for (resp = RES_x; resp <= RES_t; resp++)
X                bascnt[resp] = 0;
X              while (bp != NULL)
X                {
X                fcnt++;
X                fprintf(dfile,"FT   RR_FRAG         %d..%d\n",frgpos,
X                          (frgpos + bp->binlen-1));
X                fprintf(dfile,"FT                   /name=\"C%s_RRfrag%d\"\n",
X                          rbc_chrno2str(chrno,1),fcnt);
X                fprintf(dfile,
X"FT                   /description=\"C%sFragment %d for %d..%d Red. Rep. genomic: %d..%d\"\n",
X                          rbc_chrno2str(chrno,1),fcnt,minfrag,maxfrag,bp->spos,
X                          (bp->spos+bp->binlen-1));
X                frgpos += bp->binlen;
X                bc_bascnt4regn(chromseq[chrno-1],chrlens[chrno-1],bp->spos,
X                                 (bp->spos+bp->binlen-1),&bascnt[RES_x]);
X                bp = bp->nxtbin;
X                }
X              fprintf(dfile,"SQ   Sequence %d BP;",frgpos-1);
X              for (resp = RES_a; resp <= RES_t; resp++)
X                fprintf(dfile,"  %d %c;",bascnt[resp],sqfl_restype2chr(resp));
X              fprintf(dfile,"  %d other;\n//\n",bascnt[RES_x]);
X              fclose(dfile);
X              dfile = NULL;
X              }
X          break;
X        case BC_out_rstrrepbins:
X        case BC_out_rstrrepmiss:
X        case BC_out_rrmisstots:
X        default:
X          if ((ecnts = bc_chknreadsrcfl(chrbinlsts,srcfl,uchrno,&exclud[0],ChrY)) > 0)
X            {
X            sumplustot = summinustot = 0;
X            for (chrno = Chr1; chrno <= ChrY; chrno++)
X             if ((bp = chrbinlsts[chrno-1]) != NULL)
X                {
X                totlen = bincnt = plustot = minustot = 0;
X                while (bp != NULL)
X                  {
X                  switch (omode)
X                    {
X                    case BC_out_rstrrepmiss:
X                      fprintf(stdout,"C%s: %d..%d (%d) %d meth, %d unmeth\n",rbc_chrno2str(chrno,1),
X                                bp->spos,(bp->spos+bp->binlen-1),bp->binlen,bp->bcntfwd,bp->bcntrev);
X                      break;
X                    case BC_out_rrmisstots:
X                      break;
X                    default:
X                      fprintf(stdout,"C%s: %d..%d (%d) %d meth, %d unmeth %d CpGs\n",rbc_chrno2str(chrno,1),
X                                bp->spos,(bp->spos+bp->binlen-1),bp->binlen,bp->bcntfwd,bp->bcntrev,
X                                bp->cpgcnt);
X                      break;
X                    }
X                  plustot += bp->bcntfwd;
X                  minustot += bp->bcntrev;
X                  totlen += bp->binlen;
X                  bincnt++;
X                  bp = bp->nxtbin;
X                  }
X                fprintf(stdout,"#C%s totals: %d bins covering %d res +=%d -=%d\n",rbc_chrno2str(chrno,1),
X                          bincnt,totlen,plustot,minustot);
X                sumplustot += plustot;
X                summinustot += minustot;
X                }
X            }
X          if (omode == BC_out_rrmisstots)
X            fprintf(stdout,"Totals missing reduced rep bins: +=%d -=%d both=%d\n",
X                             sumplustot,summinustot,(sumplustot+summinustot));
X          break;
X        }
X      break;
X    case BC_out_list:
X    case BC_out_listnz:
X    case BC_out_none:
X    default:
X      chrcnt = rbc_getgenomesizs(genomsqhdrstr,&chrlens[0],(int) ChrY,uchrno);
X      if (debuglevel > RBC_dbg_none)
X        fprintf(stdout,"%d chromosomes read\n",chrcnt);
X      for (chrno = Chr1; chrno <= ChrY; chrno++)
X        if ((uchrno == 0) || (chrno == uchrno))
X          {
X          sqpos = 1;
X          while (sqpos <= chrlens[chrno-1])
X            {
X            chrbinends[chrno-1] = rbc_appndbin(&chrbinends[chrno-1],sqpos,ubinlen);
X            if (chrbinlsts[chrno-1] == NULL)
X              chrbinlsts[chrno-1] = chrbinends[chrno-1];
X            sqpos += ubinlen;
X            }
X          }
X      switch (omode)
X        { 
X        case BC_out_list:
X        case BC_out_listnz:
X          if ((ecnts = bc_chknreadsrcfl(chrbinlsts,srcfl,uchrno,&exclud[0],ChrY)) > 0)
X            {
X            if (uchrno == 0)
X              chrno = Chr1;
X            else
X              chrno = uchrno;
X            while (chrno <= ChrY)
X              {
X              bp = chrbinlsts[chrno-1];
X              while (bp != NULL)
X                {
X                switch (omode)
X                  {
X                  case BC_out_listnz:
X                    if ((bp->bcntfwd > 0) || (bp->bcntrev > 0))
X                      fprintf(stdout,"%s: %d..%d: +=%d -=%d\n",rbc_chrno2str(chrno,0),
X                                bp->spos,(bp->spos+bp->binlen-1),bp->bcntfwd,bp->bcntrev);
X                    break;
X                  case BC_out_list:
X                  default:
X                    fprintf(stdout,"%s: %d..%d: +=%d -=%d\n",rbc_chrno2str(chrno,0),
X                              bp->spos,(bp->spos+bp->binlen-1),bp->bcntfwd,bp->bcntrev);
X                    break;
X                  }
X                bp = bp->nxtbin;
X                }
X              if (uchrno != 0)
X                chrno = ChrY;
X              chrno++;
X              }
X            }
X          break;
X        case BC_out_none:
X        default:
X          if (srcfl != NULL)
X            {
X            ecnts = bc_readsrcfl(chrbinlsts,srcfl,uchrno,&exclud[0],ChrY);
X            if (debuglevel > RBC_dbg_none)
X              {
X              fprintf(stdout,"stored %d counts\n",ecnts);
X              for (chrno = Chr1; chrno <= ChrY; chrno++)
X                fprintf(stdout,"Chr%s: %dbp %d +hits %d -hits in %d bins\n",
X                          rbc_chrno2str(chrno,1),chrlens[chrno-1],
X                          bc_itsumcntfwdbins(chrbinlsts[chrno-1]),
X                          bc_itsumcntrevbins(chrbinlsts[chrno-1]),
X                          bc_cntcntbins(chrbinlsts[chrno-1]));
X              if (ecnts > 0)
X                {
X                plustot = minustot = 0;
X                for (chrno = Chr1; chrno <= ChrY; chrno++)
X                  {
X                  plustot += bc_itsumcntfwdbins(chrbinlsts[chrno-1]);
X                  minustot += bc_itsumcntrevbins(chrbinlsts[chrno-1]);
X                  }
X                fprintf(stdout,"Totals: %d+ %d-\n",plustot,minustot);
X                }
X              }
X            }
X          break;
X        }
X      break;
X    }
X  }
Xexit(0);
X}
END-of-meth_progs_dist/src/bin_cnts.c
echo x - meth_progs_dist/src/bin_cnts.h
sed 's/^X//' >meth_progs_dist/src/bin_cnts.h << 'END-of-meth_progs_dist/src/bin_cnts.h'
X/* bin_cnts.h: defs for count-binning stuff */
X
X#define BC_DEF_BINLEN 1000
X
Xtypedef struct BC_chr_bin       /* bin for chromosomal position counts */
X  {
X  int spos;                      /* start position */
X  int binlen;                    /* length this bin */
X  int cpgcnt;                    /* count CpG's this bin */
X  int bcntfwd;                   /* fwd (meth) counts this bin */
X  int bcntrev;                   /* rev (non-meth) counts this bin */
X  struct BC_chr_bin *nxtbin;    /* forward/backward links */
X  struct BC_chr_bin *prvbin;
X  }
XBC_CHR_BIN;
X
Xtypedef enum BC_outmode         /* output mode */
X  {
X  BC_out_none = 0,           /* really to let debugging info be shown by self */
X  BC_out_list,               /* list of counts+/- */
X  BC_out_listnz,             /* list nonzero bins */
X  BC_out_dmthrstrep,         /* output for differentially methylated regions */
X  BC_out_rstrrepbins,        /* scan for CCGG and generate bins based on positions & size */
X  BC_out_rstrreplst,         /* ditto, but list bins to stdout */
X  BC_out_rstrrepmiss,        /* show reads which miss reduced rep bins */
X  BC_out_rrmisstots,         /* just show totals for reads which miss RR bins */
X  BC_out_sqmonkdat           /* generate a SeqMonk dat file for RR genome */
X  }
XBC_OUTMODE;
X
Xtypedef struct BC_regn_elt   /* for linked list of regions */
X  {
X  int rstart;                /* start this region */
X  int rstop;                 /* end this region (inclusive) */
X  struct BC_regn_elt *nxtregn; /* forward link */
X  struct BC_regn_elt *prvregn; /* back link */
X  }
XBC_REGN_ELT;
X
END-of-meth_progs_dist/src/bin_cnts.h
echo x - meth_progs_dist/src/bismmethex2list.awk
sed 's/^X//' >meth_progs_dist/src/bismmethex2list.awk << 'END-of-meth_progs_dist/src/bismmethex2list.awk'
X# bismmethex2list.awk - script to convert output from
X# BisMark methylation_extractor to simple list in form
X# Chr position +/-
X# where +=> methylated C & -=> unmeth.
X#
X# Peter Stockwell: 3-Feb-2011
X#
X# revised Nov-2011 for CASAVA 1.8 output
X#
X# zcol can be defined to fit the output
X# awk -f <path>bismmethex2list.awk zcol=6 <reads>_bismark.txt
X#
X# zcol defaults to 5
XBEGIN {zcol=5;}
X
X$zcol == "Z" { for (i=NF-2;i<NF;i++)printf("%s\t",$i); printf("+\n");}
X$zcol == "z" { for (i=NF-2;i<NF;i++)printf("%s\t",$i); printf("-\n");}
END-of-meth_progs_dist/src/bismmethex2list.awk
echo x - meth_progs_dist/src/cleanadaptors.c
sed 's/^X//' >meth_progs_dist/src/cleanadaptors.c << 'END-of-meth_progs_dist/src/cleanadaptors.c'
X/* cleanadaptors.c: attempt at writing something to scan for adaptor sequences
Xin Illumina reads.  PAS: May-2011 */
X
X#include <stdlib.h>
X#include <string.h>
X#include <stdarg.h>
X#include <stdio.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "sqfl_fns.h"
X#include "sqmat_fns.h"
X#include "rmapbsbed2cpg.h"
X#include "bin_cnts.h"
X#include "fsm_ops.h"
X
X/* local defines */
X/* #define PROG_VERSN 1.00 */
X/* first release: June 2011 */
X/* #define PROG_VERSN 1.01 */
X/* don't write 0 length seqs: Jul-2011 */
X/* #define PROG_VERSN 1.02 */
X/* further refine length exclusion: Jul-2011 */
X/* #define PROG_VERSN 1.03 */
X/* allow N-filling of trims: Jul-2011 */
X/* #define PROG_VERSN 1.04 */
X/* allow quality lines starting with '>' */
X#define PROG_VERSN 1.04
X/* allow trimming back before adaptor: Jan-2012 */
X
X#define MAX_ADAPTOR_LEN 256
X#define MIN_LEAD_TRAIL 6
X#define DEF_READBUFLEN 256
X#define DEF_3PMARGIN 0
X#define DEF_MATCHCRITERION 75.0
X
Xtypedef struct CA_adhit    /* information about an adaptor hit */
X  {
X  int pos;                 /* where in seq line */
X  FS_RESELT *resp;         /* result ptr */
X  struct CA_adhit *nxthit;
X  struct CA_adhit *prvhit;
X  }
XCA_ADHIT;   
X
Xtypedef struct CA_adaptor   /* linked list element of original adaptor seqs */
X  {
X  char *adaptstr;          /* the sequence */
X  int asqno;               /* its number */
X  struct CA_adaptor *nxtadaptor;
X  struct CA_adaptor *prvadaptor;
X  }
XCA_ADAPTOR;
X
Xtypedef struct ca_adinfo  /* structure to contain an adaptor name and a pointer */
X  {
X  char *adname;
X  CA_ADAPTOR *adptr;        /* pointer to the original full adaptor seq */
X  }
XCA_ADINFO;
X
Xtypedef enum CA_fastqlntype
X  {
X  CA_fqlt_hdrline = 0,
X  CA_fqlt_sqline,
X  CA_fqlt_qulhdr,
X  CA_fqlt_qualln,
X  CA_fqlt_unk
X  }
XCA_FASTQLNTYPE;
X
Xtypedef enum CA_outstyle
X  {
X  CA_out_fsmlist = 0,
X  CA_out_listreads,
X  CA_out_listhitreads,
X  CA_out_trimhits,
X  CA_out_nfill           /* put 'N's in trimmed region */
X  }
XCA_OUTSTYLE;
X
Xtypedef enum CA_srctype
X  {
X  CA_src_fastq = 0,
X  CA_src_fasta
X  }
XCA_SRCTYPE;
X
Xtypedef struct CA_runpars
X  {
X  int trimcnt;
X  CA_SRCTYPE srcstyle;
X  CA_OUTSTYLE ostyle;
X  int minleadtrail;
X  int readflbuflen;
X  int margn3p;
X  int maxadlen;
X  CA_ADAPTOR *adaptlst;
X  int mismatches;
X  int skipres;
X  float matcriterion;
X  int mintrimlen;     /* minimum length for output of trimmed seqs, 0=>no limit */
X  int trimback;
X  }
XCA_RUNPARS;
X
X/* local globals */
X
Xint debuglevel;
X/* int trimcnt; */
X
X/* code ... */
X
Xint err_msg(char *fmt,
X            ...)
X/* write user error message.  Return 0 for err return status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xreturn(0);
X}
X
Xvoid err_msg_die(char *fmt,
X                 ...)
X/* write user error message then exit with error status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xexit(1);
X}
X
Xvoid say_usage(FILE *fl,
X               char *pnam)
X{
Xfprintf(fl,"%s v%.2f: scan Illumina reads for adaptor seqs: Trim FASTA/FASTQ files\n",
X          pnam,PROG_VERSN);
Xfputs("Options:\n",fl);
Xfputs("     -i <adaptorfile> file of adaptor seqs 1/line)\n",fl);
Xfputs("         (def=\"AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGATC\": 40bp of Universal adaptor)\n",fl);
Xfprintf(fl,"     -l max adaptor length (def=%d)\n",MAX_ADAPTOR_LEN);
Xfprintf(fl,"     -m min leading match for adaptor (def=%d)\n",MIN_LEAD_TRAIL);
Xfprintf(fl,"     -M margin at read end for trimming (def=%d)\n",DEF_3PMARGIN);
Xfprintf(fl,"     -R readfile buffer length (def=%d)\n",DEF_READBUFLEN);
Xfputs("     -s <skipres> skip <skipres> on each read before checking matches\n",fl);
Xfprintf(fl,"     -p <%%> %% match threshold with adaptor sequence for hit (def=%.1f%%)\n",
X          DEF_MATCHCRITERION);
Xfputs("     -S enable single base mismatches (def=disallow)\n",fl);
Xfputs("     -L print fsm to stdout\n",fl);
Xfputs("     -F <readfile>: run scan on <readfile> FASTQ/FASTA fmt, trim matching ends\n",fl);
Xfputs("     -z <readfile>: as -F but don't check length of trimmed reads\n",fl);
Xfputs("     -x <lengthlimit>: only save trimmed reads exceeding length limit (def=1)\n",fl);
Xfputs("     -t <3'trimlength>: take further 3'trimlength bases before adaptor match (def=0)\n",fl);
Xfputs("     -N <readfile>: fill lines with 'N's rather than trimming\n",fl);
Xfputs("     -f <readfile>: run scan on <readfile> FASTQ/FASTA fmt, show all reads, indicate matches\n",fl);
Xfputs("     -H <readfile>: run scan on <readfile> FASTQ/FASTA fmt, indicate matches on hit reads only\n",fl);
Xfputs("         if <readfile> is '-', then use stdin\n",fl);
X}
X
Xchar tr_int2nares(int iv)
X  /* return a nucleic acid residue for iv */
X{
Xswitch (iv)
X  {
X  case 0:
X    return('a');
X    break;
X  case 1:
X    return('c');
X    break;
X  case 2:
X    return('g');
X    break;
X  case 3:
X    return('t');
X    break;
X  default:
X    return('?');
X    break;
X  }
X}
X
Xint tr_nares2int(char res)
X  /* return an int value 0..3 for res, -1 for unknown */
X{
Xswitch (toupper(res))
X  {
X  case 'A':
X    return(0);
X    break;
X  case 'C':
X    return(1);
X    break;
X  case 'G':
X    return(2);
X    break;
X  case 'T':
X  case 'U':
X    return(3);
X    break;
X  default:
X    return(-1);
X    break;
X  }
X}
X
XCA_ADAPTOR *ca_appndadaptor(CA_ADAPTOR **alst,
X                            char *astr,
X                            int asno)
X/* append a new string element to *alst.
Xstrdup astr in order that a conserved 
Xvalue is created.  Return address of new element
Xin case it is useful */
X{
XCA_ADAPTOR *prev, *end_ptr;
X
Xif (alst != NULL)
X  {
X  prev = end_ptr = *alst;
X  while (end_ptr != NULL)
X    {
X    prev = end_ptr;
X    end_ptr = end_ptr->nxtadaptor;
X    }
X  end_ptr = (CA_ADAPTOR *) getmemory(sizeof(CA_ADAPTOR),"Adaptor elt");
X  end_ptr->nxtadaptor = NULL;
X  end_ptr->adaptstr = bas_strdup(astr);
X  end_ptr->asqno = asno;
X  if (*alst == NULL)
X    {
X    *alst = end_ptr;
X    end_ptr->prvadaptor = NULL;
X    }
X  else
X    {
X    prev->nxtadaptor = end_ptr;
X    end_ptr->prvadaptor = prev;
X    }
X  return(end_ptr);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid ca_deladaptelt(CA_ADAPTOR *ep,
X                    CA_ADAPTOR **lstrt)
X/* delete ep from list *lstrt */
X{
XCA_ADAPTOR *pt;
X
Xif (ep != NULL)
X  {
X  if ((pt = ep->prvadaptor) == NULL)
X    *lstrt = ep->nxtadaptor;
X  else
X    pt->nxtadaptor = ep->nxtadaptor;
X  if ((pt = ep->nxtadaptor) != NULL)
X    pt->prvadaptor = ep->prvadaptor;
X  if (ep->adaptstr != NULL)
X    memfree(ep->adaptstr);
X  memfree(ep);
X  }
X}
X
Xvoid ca_clralladaptors(CA_ADAPTOR **lstrt)
X  /* iteratively delete all of lstrt */
X{
Xwhile (*lstrt != NULL)
X  ca_deladaptelt(*lstrt,lstrt);
X}
X
Xint ca_buildadaptorfsm(char *sqbuf,
X                       int sqno,
X                       CA_ADAPTOR *adpt,
X                       CA_RUNPARS *rpars,
X                       FS_FSMSTRCT *adfsm)
X/* scan seq sqbuf as an adaptor sequence, making
XFSM adfsm in accordance with parameters.
Xreturn No. of fsm entries */
X{
Xint sqlen;
Xchar *leadfragbuf;
Xint sqp;
Xchar *lablstr;
XSQ_RESTYPE sres;
Xint frgp;
Xchar cacheres;
Xchar subres;
Xint fsmcnt;
XCA_ADINFO *adinfo;
X
Xfsmcnt = 0;
Xif ((sqlen = strlen(sqbuf)) > 0)
X  {
X  leadfragbuf = (char *) getmemory(sqlen+1,"lead seq buf");
X  for (sqp = rpars->minleadtrail; sqp <= sqlen; sqp++)
X    {
X    (void) memcpy(leadfragbuf,sqbuf,sqp);
X    *(leadfragbuf + sqp) = '\0'; 
X    for (frgp = 0; frgp < sqp; frgp++)
X      if (rpars->mismatches)
X        {
X        cacheres = *(leadfragbuf+frgp);
X        for (sres = RES_a; sres <= RES_t; sres++)
X          {
X          *(leadfragbuf+frgp) = sqfl_restype2chr(sres);
X          asprintf(&lablstr,"Ad_%d_l%d_%c%d%c",sqno,sqp,cacheres,(frgp+1),
X                     sqfl_restype2chr(sres));
X          adinfo = (CA_ADINFO *) getmemory(sizeof(CA_ADINFO),"Ad info");
X          adinfo->adname = bas_strdup(lablstr);
X          adinfo->adptr = adpt;
X          fs_adddatprs(adfsm,leadfragbuf,adinfo);
X          fsmcnt++;
X          memfree(lablstr);
X          }
X        *(leadfragbuf+frgp) = cacheres;
X        }
X      else
X        {
X        asprintf(&lablstr,"Ad_%d_l%d",sqno,sqp);
X        adinfo = (CA_ADINFO *) getmemory(sizeof(CA_ADINFO),"Ad info");
X        adinfo->adname = bas_strdup(lablstr);
X        adinfo->adptr = adpt;
X        fs_adddatprs(adfsm,leadfragbuf,adinfo);
X        fsmcnt++;
X        memfree(lablstr);
X        }
X     }
X  }
Xmemfree(leadfragbuf);
Xreturn(fsmcnt);
X}
X
Xint ca_readadaptorfile(FILE *sfl,
X                       CA_RUNPARS *rpars,
X                       FS_FSMSTRCT *adfsm)
X/* scan sfl for adaptor sequences one seq/line.  Load
Xeach original seq and all partitions starting from
Xposition minleadtail up to minleadtail from end into
Xadfsm. return no of seqs read */
X{
Xint sqno;
Xint sqlen;
Xchar *sqbuf;
XCA_ADAPTOR *alstptr;
Xchar *sbp;
X
Xsqno = 0;
Xsqbuf = (char *) getmemory(rpars->maxadlen+1,"input seq buf");
Xwhile ((sbp = fgets(sqbuf,rpars->maxadlen,sfl)) != NULL)
X  {
X  while (*sbp != '\0')
X    {
X    if (*sbp == '\n')
X      *sbp = '\0';
X    sbp++;
X    }
X  if ((sqlen = strlen(sqbuf)) > 0)
X    {
X    sqno++;
X    alstptr = ca_appndadaptor(&rpars->adaptlst,sqbuf,sqno);
X    (void) ca_buildadaptorfsm(sqbuf,sqno,alstptr,rpars,adfsm);
X    }
X  }
Xmemfree(sqbuf);
Xreturn(sqno);
X}
X
Xvoid ca_nl(FILE *fl)
X{
Xfputc('\n',fl);
X}
X
Xvoid ca_prtctxt(FILE *fl,
X                void *p)
X{
X(void) fs_lstcstr(fl,p);
X}
X
Xint ca_inrankordr(CA_ADHIT *e1p,
X                  CA_ADHIT *e2p)
X/* if e1 preceeds e2 in rank order, then return 1. */
X{
Xif (e1p == NULL)
X  return(0);
Xelse
X  if (e2p == NULL)
X    return(1);
X  else
X    return((e1p->resp == e2p->resp) && (e1p->pos < e2p->pos));
X}
X
XCA_ADHIT *ca_insertnewhit(CA_ADHIT **alst,
X                          int lpos,
X                          FS_RESELT *rep,
X                          int (* preceeds_fn)(CA_ADHIT *e1p,
X                                              CA_ADHIT *e2p))
X/* scan through *alst, if exists, finding the first element
Xwhich is after lpos, insert a new element before it, returning
Xthe address of the new element.  If we fall off the end of the list,
Xthen append the new element there. */
X{
XCA_ADHIT *prvelt;
XCA_ADHIT *ep;
XCA_ADHIT *newp;
X
Xprvelt = NULL;
Xep = *alst;
Xnewp = (CA_ADHIT *) getmemory(sizeof(CA_ADHIT),"ADhitelt");
Xnewp->pos = lpos;
Xnewp->resp = rep;
Xwhile (ep != NULL)
X  if ((*preceeds_fn)(newp,ep))
X    {
X    newp->nxthit = ep;
X    if (ep->prvhit == NULL)
X      {
X      *alst = newp;
X      newp->prvhit = NULL;
X      }
X    else
X      {
X      ep->prvhit->nxthit = newp;
X      newp->prvhit = ep->prvhit;
X      }
X    ep->prvhit = newp;
X    return(newp);
X    }
X  else
X    {
X    prvelt = ep;
X    ep = ep->nxthit;
X    }
X/* haven't found it, stick on end */
Xnewp->nxthit = NULL;
Xnewp->prvhit = prvelt;
Xif (prvelt == NULL)
X  *alst = newp;
Xelse
X  prvelt->nxthit = newp;
Xreturn(newp);
X}
X
XCA_ADHIT *ca_hit4pos5p(CA_ADHIT *hlst,
X                       int hpos)
X/* return the first hit element on hlst which
Xmatches 5' hpos */
X{
XCA_ADHIT *hp;
X
Xhp = hlst;
Xwhile (hp != NULL)
X  if (hp->pos == hpos)
X    return(hp);
X  else
X    hp = hp->nxthit;
Xreturn(NULL);
X}
X
Xint ca_len4fs_reselt(FS_RESELT *rep)
X  /* return the data length for rep */
X{
XFS_DATPRELT *dpep;
X
Xif ((rep != NULL) && ((dpep = (FS_DATPRELT *) rep->action) != NULL))
X  return(dpep->ldstr);
Xelse
X  return(0);
X}
X
Xvoid ca_killhitelt(CA_ADHIT **alst,
X                   CA_ADHIT *hep)
X/* remove *hep from alst */
X{
Xif (hep != NULL)
X  {
X  if (hep->prvhit == NULL)
X    *alst = hep->nxthit;
X  else
X    hep->prvhit->nxthit = hep->nxthit;
X  if (hep->nxthit != NULL)
X    hep->nxthit->prvhit = hep->prvhit;
X  memfree(hep);
X  }
X}
X
Xvoid ca_killhitlst(CA_ADHIT **alst)
X  /* iteratively kill all of alst */
X{
Xwhile (*alst != NULL)
X  ca_killhitelt(alst,*alst);
X}
X
XCA_ADHIT *ca_hit4pos3p(CA_ADHIT *hlst,
X                       int pos3p)
X/* return the first hit element on hlst which
Xmatches 3' pos3p */
X{
XCA_ADHIT *hp;
Xint p3p;
X
Xhp = hlst;
Xwhile (hp != NULL)
X  {
X  p3p = hp->pos + ca_len4fs_reselt(hp->resp) - 1;
X  if (p3p == pos3p)
X    return(hp);
X  else
X    hp = hp->nxthit;
X  }
Xreturn(NULL);
X}
X
XCA_ADHIT *ca_hitat3pend(CA_ADHIT *hlst,
X                        int sqlen,
X                        int margin)
X/* if hlst contains any hits which lie within
Xmargin of end of seq line (sqlen long), then
Xreturn point to that hit element, else NULL */
X{
XCA_ADHIT *hp;
X
Xhp = hlst;
Xwhile (hp != NULL)
X  if ((hp->pos + ca_len4fs_reselt(hp->resp)) >= (sqlen-margin))
X    return(hp);
X  else
X    hp = hp->nxthit;
Xreturn(NULL);
X}
X
Xfloat ca_hitpercntmatch(char *sqread,
X                        CA_ADHIT *hitp,
X                        int *olapcnt,
X                        int *matcnt)
X/* scan this hit vs sqread, counting
Xnumber of matched residues.  Return
X% of matches by end of read or original
Xadaptor seq.  If olapcnt & matcnt are non-NULL
Xthen return appropriate counts to them.
Xreturn 0.0 for issues */
X{
Xint ocnt;
Xint mcnt;
Xchar *ap;
Xchar *sp;
XFS_DATPRELT *dpep;
XCA_ADINFO *adinfop;
X
Xif (hitp != NULL)
X  {
X  dpep = (FS_DATPRELT *) hitp->resp->action;
X  adinfop = (CA_ADINFO *) dpep->stxt;
X  ap = adinfop->adptr->adaptstr;
X  sp = sqread + hitp->pos - 1;
X  ocnt = mcnt = 0;
X  while ((*ap != '\0') && (*sp != '\0'))
X    {
X    if (toupper(*ap++) == toupper(*sp++))
X      mcnt++;
X    ocnt++;
X    }
X  if (olapcnt != NULL)
X    *olapcnt = ocnt;
X  if (matcnt != NULL)
X    *matcnt = mcnt;
X  if (ocnt > 0)
X    return((float) mcnt*100.0/ocnt);
X  else
X    return(0.0);
X  }
Xelse
X  return(0.0);
X}
X
Xint ca_hitmeetscriteria(char *sqread,
X                         CA_ADHIT *hitp,
X                         CA_RUNPARS *rpars)
X/* return 1 if this match meets criteria for a match */
X{
Xfloat mprcnt;
Xint p3gap;
XFS_DATPRELT *dpep;
XCA_ADINFO *adinfop;
X
Xmprcnt = ca_hitpercntmatch(sqread,hitp,NULL,NULL);
Xif ((hitp!= NULL) && (mprcnt >= rpars->matcriterion))
X  if (rpars->margn3p <= 0)
X    return(1);
X  else
X    {
X    dpep = (FS_DATPRELT *) hitp->resp->action;
X    adinfop = (CA_ADINFO *) dpep->stxt;
X    p3gap = hitp->pos + strlen(adinfop->adptr->adaptstr) - strlen(sqread);
X    return(p3gap <= rpars->margn3p);
X    }
Xreturn(0);
X}
Xint ca_ahitmeetscriteria(char *sqread,
X                         CA_ADHIT *hlst,
X                         CA_RUNPARS *rpars)
X/* check all elements of hitlst and return if any
Xmatches criteria for a match */
X{
Xif (hlst == NULL)
X  return(0);
Xelse
X  if (ca_hitmeetscriteria(sqread,hlst,rpars))
X    return(1);
X  else
X    return(ca_ahitmeetscriteria(sqread,hlst->nxthit,rpars));
X}
X
XCA_ADHIT *ca_5pmostvalidhit(CA_ADHIT *hlst,
X                            char *sqread,
X                            CA_RUNPARS *rpars)
X/* scan any hits in hlst, checking
Xfor validity.  Return the 5'-most such
Xhit, NULL if none */
X{
XCA_ADHIT *h5p;
XCA_ADHIT *hp;
X
Xh5p = NULL;
Xhp = hlst;
Xwhile (hp != NULL)
X  {
X  if (ca_hitmeetscriteria(sqread,hp,rpars))
X    if ((h5p == NULL) || (h5p->pos > hp->pos))
X      h5p = hp;
X  hp = hp->nxthit;
X  }
Xreturn(h5p);
X}
X
Xvoid ca_rptchrout(FILE *dfl,
X                  char outc,
X                  int ccnt)
X/* write ccnt outcX to dfl */
X{
Xint cc;
X
Xcc = ccnt;
Xwhile (cc > 0)
X  {
X  fputc(outc,dfl);
X  cc--;
X  }
X}
X
Xvoid ca_writedataout(FILE *dfile,
X                     char *linbuf[],
X                     CA_FASTQLNTYPE mxlt,
X                     CA_ADHIT *hitlst,
X                     CA_RUNPARS *rpars)
X/* logic to write out the data from
Xlinbuf[] according to requirements */
X{
XCA_ADHIT *hlp;
Xint bcnt;
XFS_DATPRELT *dpep;
XCA_FASTQLNTYPE fqlt;
Xint slen;
Xchar *sp;
XCA_ADINFO *adinfop;
Xchar *ap;
Xint olapcnt;
Xint matcnt;
Xfloat pcntmat;
Xint origlen;
X
Xif ((rpars->ostyle != CA_out_listhitreads) || 
X      ca_ahitmeetscriteria(linbuf[CA_fqlt_sqline],hitlst,rpars))
X  {
X  fqlt = CA_fqlt_hdrline;
X  origlen = slen = strlen(linbuf[CA_fqlt_sqline]);
X  if (((rpars->ostyle == CA_out_trimhits) || (rpars->ostyle == CA_out_nfill)) && 
X        ((hlp = ca_5pmostvalidhit(hitlst,linbuf[CA_fqlt_sqline],rpars)) != NULL))
X    {
X    if ((slen = hlp->pos - 1) > 0)
X      {
X      rpars->trimcnt++;
X      slen -= rpars->trimback;
X      }
X    }
X  if ((slen >= 0) &&
X        (((rpars->ostyle == CA_out_trimhits) || (rpars->ostyle == CA_out_nfill)) &&
X        ((slen >= rpars->mintrimlen) || (rpars->mintrimlen <= 0)))
X         || ((rpars->ostyle != CA_out_trimhits) && (rpars->ostyle != CA_out_nfill)))
X    {
X    while (fqlt <= mxlt)
X      {
X      switch (fqlt)
X        {
X        case CA_fqlt_hdrline:
X        case CA_fqlt_qulhdr:
X          fputs(linbuf[fqlt],dfile);
X          fputc('\n',dfile);
X          break;
X        case CA_fqlt_sqline:
X          bcnt = slen;
X          sp = linbuf[fqlt];
X          while (bcnt > 0)
X            {
X            fputc(*sp++,dfile);
X            bcnt--;
X            }
X          if (rpars->ostyle == CA_out_nfill)
X            ca_rptchrout(dfile,'N',(origlen - slen));
X          fputc('\n',dfile);
X/*        fprintf(dfile,"%*s\n",slen,linbuf[fqlt]); */
X          if ((rpars->ostyle != CA_out_trimhits) && (rpars->ostyle != CA_out_nfill))
X            {
X            hlp = hitlst;
X            while (hlp != NULL)
X              {
X              if (ca_hitmeetscriteria(linbuf[CA_fqlt_sqline],hlp,rpars))
X                {
X                bcnt = hlp->pos - 1;
X                while (bcnt-- > 0)
X                  fputc(' ',dfile);
X                bcnt = ca_len4fs_reselt(hlp->resp);
X                while (bcnt-- > 0)
X                  fputc('^',dfile);
X                fputc('\n',dfile);
X                dpep = (FS_DATPRELT *) hlp->resp->action;
X                adinfop = (CA_ADINFO *) dpep->stxt;
X                bcnt = hlp->pos - 1;
X                while (bcnt-- > 0)
X                  fputc(' ',dfile);
X                bcnt = ca_len4fs_reselt(hlp->resp);
X                ap = adinfop->adptr->adaptstr;
X                sp = linbuf[fqlt] + hlp->pos - 1;
X                while ((*ap != '\0') && (*sp != '\0'))
X                  {
X                  if (toupper(*ap) == toupper(*sp++))
X                    fputc(toupper(*ap),dfile);
X                  else
X                    fputc(tolower(*ap),dfile);
X                  ap++;
X                  }
X                pcntmat = ca_hitpercntmatch(linbuf[fqlt],hlp,&olapcnt,&matcnt);
X                fprintf(dfile," %d/%d match (%.1f%%) ",matcnt,olapcnt,pcntmat);
X                ca_prtctxt(dfile,adinfop->adname);
X                fputc('\n',dfile);
X                }
X              hlp = hlp->nxthit;
X              }
X            }
X          break;
X        case CA_fqlt_qualln:
X          bcnt = slen;
X          sp = linbuf[fqlt];
X          while (bcnt > 0)
X            {
X            fputc(*sp++,dfile);
X            bcnt--;
X            }
X          if (rpars->ostyle == CA_out_nfill)
X            ca_rptchrout(dfile,';',(origlen - slen));
X          fputc('\n',dfile);
X/*        fprintf(dfile,"%*s\n",slen,linbuf[fqlt]); */
X          break;
X        }
X      fqlt++;
X      }
X    }
X  }
X}
X
Xvoid ca_scanreads(FILE *rdfl,
X                  FS_FSMSTRCT *adfsm,
X                  CA_RUNPARS *rpars,
X                  FILE *dfile)
X/* scan thru rdfl as either fasta or fastq fmt, scanning
Xeach read from skipres.  Note any matches to adfsm and
Xeither tell dfile about it or trim reads to dfile */
X{
Xchar nc;
Xint lpos;
XFS_RESELT *frp;
Xint hpos;
XCA_ADHIT *hitlst;
XCA_FASTQLNTYPE fqlt;
Xchar *linbufs[CA_fqlt_unk];
Xchar *dstp;
XCA_FASTQLNTYPE mxlt;
XCA_ADHIT *hlp;
Xint lcnt;
X
Xfor (fqlt = CA_fqlt_hdrline; fqlt < CA_fqlt_unk; fqlt++)
X  {
X  linbufs[fqlt] = (char *) getmemory(rpars->readflbuflen+1,"ReadBuf");
X  *linbufs[fqlt] - '\0';
X  }
Xmxlt = CA_fqlt_hdrline;
Xfqlt = CA_fqlt_unk;
Xlpos = 1;
Xlcnt = 0;
Xhitlst = NULL;
Xwhile ((nc = fgetc(rdfl)) != EOF)
X  {
X  if (lpos == 1)
X    {
X    if (lcnt == 0)    /* classify file type at this point */
X      switch (nc)
X        {
X        case '>':
X          rpars->srcstyle = CA_src_fasta;
X          break;
X        case '@':
X        default:
X          rpars->srcstyle = CA_src_fastq;
X          break;
X        }
X    switch (nc)
X      {
X      case '>':       /* fasta hdr line */
X        if ((rpars->srcstyle == CA_src_fasta) && (lcnt%2 == 0))
X          { /* on fasta header, put out prev data */
X          if (lcnt > 0)
X            {
X            ca_writedataout(dfile,&linbufs[CA_fqlt_hdrline],mxlt,hitlst,rpars);
X            ca_killhitlst(&hitlst);
X            }
X          fqlt = CA_fqlt_hdrline;
X          fs_initrun(adfsm);
X          }
X        else  /* not header, so just process */
X          {
X          fqlt++;
X          if (fqlt > mxlt)
X            mxlt = fqlt;
X          }
X        break;
X      case '@':
X        if ((rpars->srcstyle == CA_src_fastq) && (lcnt%4==0))
X          {        /* fastq hdr line, need to put out prev data */
X          if (lcnt > 0)
X            {
X            ca_writedataout(dfile,&linbufs[CA_fqlt_hdrline],mxlt,hitlst,rpars);
X            ca_killhitlst(&hitlst);
X            }
X          fqlt = CA_fqlt_hdrline;
X          fs_initrun(adfsm);
X          }
X        else  /* not header, so just process */
X          {
X          fqlt++;
X          if (fqlt > mxlt)
X            mxlt = fqlt;
X          }
X        break;
X      case '+':       /* fastq qual hdr line */
X        fqlt = CA_fqlt_qulhdr;
X        break;
X      default:
X        fqlt++;
X        if (fqlt > mxlt)
X          mxlt = fqlt;
X        break;
X      }
X    dstp = linbufs[fqlt];
X    *dstp = '\0';
X    }
X  lpos++;
X  if (nc == '\n')   /* at end of line */
X    {
X    lcnt++;
X    lpos = 1;
X    }
X  else
X    switch (fqlt)
X      {
X      case CA_fqlt_sqline:
X        if (lpos > rpars->skipres)
X          if ((frp = fs_procchr(adfsm,nc,tr_nares2int)) != NULL)
X            {
X            hpos = lpos - ca_len4fs_reselt(frp);
X            if (((hlp = ca_hit4pos5p(hitlst,hpos)) != NULL) &&
X                (ca_len4fs_reselt(frp) > ca_len4fs_reselt(hlp->resp)))
X              hlp->resp = frp;   /* only want longest match this pos */
X            else
X              (void) ca_insertnewhit(&hitlst,hpos,frp,ca_inrankordr);
X            }
X      case CA_fqlt_hdrline:
X      case CA_fqlt_qulhdr:
X      case CA_fqlt_qualln:
X        *dstp = nc;
X        dstp++;
X        *dstp = '\0';
X        break;
X      default:
X        break;
X      }
X  }
Xca_writedataout(dfile,&linbufs[CA_fqlt_hdrline],mxlt,hitlst,rpars);
Xca_killhitlst(&hitlst);
Xfor (fqlt = CA_fqlt_hdrline; fqlt < CA_fqlt_unk; fqlt++)
X  memfree(linbufs[fqlt]);
X}
X
Xint main(int argc,
X         char *argv[])
X{
XFILE *adsrcfl;
XFS_FSMSTRCT *adfsm;
Xint adcnt;
Xint ap;
Xchar op;
Xchar *fendp;
XFILE *readfl;
Xint mismatches;
XCA_ADAPTOR *adaptlst;
XCA_RUNPARS runpars;
X
Xdebuglevel = 1;
Xadsrcfl = NULL;
Xadfsm = fs_initnewfsm(4,1,FS_inv_reset);
Xreadfl = stdin;
Xrunpars.readflbuflen = DEF_READBUFLEN;
Xrunpars.minleadtrail = MIN_LEAD_TRAIL;
Xrunpars.maxadlen = MAX_ADAPTOR_LEN;
Xrunpars.margn3p = DEF_3PMARGIN;
Xrunpars.mismatches = 0;
Xrunpars.adaptlst = NULL;
Xrunpars.trimcnt = 0;
Xrunpars.ostyle = CA_out_listreads;
Xrunpars.skipres = 0;
Xrunpars.matcriterion = DEF_MATCHCRITERION;
Xrunpars.mintrimlen = 1;
Xrunpars.trimback = 0;
Xrunpars.srcstyle = CA_src_fastq;
Xfor (ap = 1; ap < argc; ap++)
X  if (*argv[ap] == '-')   /* an option */
X    switch (op = *(argv[ap]+1))
X      {
X      case 'L':     /* print/list fsm */
X        runpars.ostyle = CA_out_fsmlist;
X        break;
X      case 'l':    /* adaptor max len */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer\n",op);
X        else
X          {
X          runpars.maxadlen = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          else
X            if (runpars.maxadlen <= 0)
X              err_msg_die("Invalid max adaptor length '%s'\n",argv[ap]);
X          }
X        break;
X      case 'm':    /* min lead/trail */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer\n",op);
X        else
X          {
X          runpars.minleadtrail = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          else
X            if (runpars.minleadtrail <= 0)
X              err_msg_die("Invalid min lead/trail length '%s'\n",argv[ap]);
X          }
X        break;
X      case 'M':    /* 3p margin for trim */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer\n",op);
X        else
X          {
X          runpars.margn3p = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          else
X            if (runpars.margn3p <= 0)
X              err_msg_die("Invalid 3' trim margin '%s'\n",argv[ap]);
X          }
X        break;
X      case 'R':    /* read buff length */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer\n",op);
X        else
X          {
X          runpars.readflbuflen = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          else
X            if (runpars.readflbuflen <= 0)
X              err_msg_die("Invalid read file buffer length '%s'\n",argv[ap]);
X          }
X        break;
X      case 'p':    /* match criterion percentage */
X        if (++ap > argc)
X          err_msg_die("-%c needs float\n",op);
X        else
X          {
X          runpars.matcriterion = strtof(argv[ap],&fendp);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert float '%s' for -%c\n",argv[ap],op);
X          else
X            if (runpars.matcriterion < 0.0)
X              err_msg_die("Invalid match criterion value '%s'\n",argv[ap]);
X          }
X        break;
X      case 's':    /* skip residues each read */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer\n",op);
X        else
X          {
X          runpars.skipres = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          else
X            if (runpars.skipres <= 0)
X              err_msg_die("Invalid read skip length '%s'\n",argv[ap]);
X          }
X        break;
X      case 'S':    /* disable single base mismatches */
X        runpars.mismatches = 1;
X        break;
X      case 'i':    /* user name for adaptor file */
X        if (++ap > argc)
X          err_msg_die("-%c needs adaptor seq file name\n",op);
X        else
X          if ((adsrcfl = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open adaptor seq file '%s'\n",argv[ap]);
X        break;
X      case 'H':    /* report hit matches only */
X      case 'F':    /* Trim reads in file */
X      case 'f':    /* Report all reads matches & other */
X      case 'z':    /* include 0 length trimmed reads */
X      case 'N':    /* N-fill lines */
X        switch (op)
X          {
X          case 'H':
X            runpars.ostyle = CA_out_listhitreads;
X            break;
X          case 'F':
X            runpars.ostyle = CA_out_trimhits;
X            break;
X          case 'z':
X            runpars.ostyle = CA_out_trimhits;
X            runpars.mintrimlen = 0;
X            break;
X          case 'N':
X            runpars.ostyle = CA_out_nfill;
X            break;
X          case 'f':
X          default:
X            runpars.ostyle = CA_out_listreads;
X            break;
X          }
X        if (++ap > argc)
X          err_msg_die("-%c needs read file name\n",op);
X        else
X          if (strcmp(argv[ap],"-") != 0)
X            if ((readfl = fopen(argv[ap],"r")) == NULL)
X              err_msg_die("Can't open read file '%s'\n",argv[ap]);
X        break;
X      case 'x':    /* set minimum trimmed seq length */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer\n",op);
X        else
X          {
X          runpars.mintrimlen = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          }
X        break;
X      case 't':    /* trimback */
X        if (++ap > argc)
X          err_msg_die("-%c needs integer\n",op);
X        else
X          {
X          runpars.trimback = (int) strtol(argv[ap],&fendp,10);
X          if (fendp == argv[ap])    /* failed to read */
X            err_msg_die("Can't convert integer '%s' for -%c\n",argv[ap],op);
X          }
X        break;
X      case 'd':   /* debug on */
X        debuglevel = 1;
X        break;
X      case 'D':   /* debug^2 on */
X        debuglevel = 2;
X        break;
X      case 'h':
X        say_usage(stdout,argv[0]);
X        exit(0);
X        break;
X      default:
X        err_msg("Unknown Option: '%s\n",argv[ap]);
X        say_usage(stderr,argv[0]);
X        exit(1);
X        break;
X      }
Xif (adsrcfl == NULL)
X  {
X  (void) ca_appndadaptor(&runpars.adaptlst,"AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGATC",1);
X  adcnt = ca_buildadaptorfsm(runpars.adaptlst->adaptstr,runpars.adaptlst->asqno,
X                               runpars.adaptlst,&runpars,adfsm);
X  }
Xelse
X  adcnt = ca_readadaptorfile(adsrcfl,&runpars,adfsm);
X(void) fs_bldfsm(adfsm,WLU_CASEIND,0,0,tr_int2nares,fs_chkinpstr,fs_shed2lurec);
Xif (runpars.ostyle == CA_out_fsmlist)
X  {
X  fs_lststttbl(stdout,adfsm);
X  fs_lststrpr(stdout,adfsm->prlst,1,ca_prtctxt,ca_nl);
X  }
Xelse
X  ca_scanreads(readfl,adfsm,&runpars,stdout);
Xexit(0);
X}
END-of-meth_progs_dist/src/cleanadaptors.c
echo x - meth_progs_dist/src/fsm_ops.c
sed 's/^X//' >meth_progs_dist/src/fsm_ops.c << 'END-of-meth_progs_dist/src/fsm_ops.c'
X/* fsm_ops.c: common routines for general FSM operations */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <strings.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "fsm_ops.h"
X
Xvoid fs_initfsmstrct(FS_FSMSTRCT *fs,
X                     int nstates,
X                     int dsubs,
X                     FS_ONINVLD inv)
X/* assign initial (NULL largely) values to fs components.  dsubs determines if
Xfsm will completely handle substrings - The method of Smith (1988) CABIOS, 4,
X459 does not correctly handle substrings.  It is made optional here in order
Xto allow some uses to work properly.  dsubs=1 - build fsm for substrings,
Xdsubs=0 - build fsm as in Smith, 1988 */
X{
Xfs->instrngs = fs->cis = NULL;
Xfs->firststt = fs->laststt = fs->currstt = NULL;
Xfs->nstats = nstates;
Xfs->null_reslt = NULL;
Xfs->cisbuf = NULL;
Xfs->strmax = 0;
Xfs->sttcnt = 0;
Xfs->prlst = fs->lstpr = NULL;
Xfs->invact = inv;
Xfs->dosubs = dsubs;
X}
X
XFS_FSMSTRCT *fs_initnewfsm(int nstates,
X                           int dsubs,
X                           FS_ONINVLD inv)
X/* malloc() storage for a new fsm & assign initial (NULL largely) values to
Xfs components, return address. dsubs is described in fs_initfsmstrct() */
X{
XFS_FSMSTRCT *fss;
X
Xfss = (FS_FSMSTRCT *) getmemory(sizeof(FS_FSMSTRCT),"FSM structure");
Xfs_initfsmstrct(fss,nstates,dsubs,inv);
Xreturn(fss);
X}
X
XFS_RESELT *fs_appndreselt(FS_RESELT **rlst,
X                          void *rsp)
X/* append a new value to *rlst, return address of new element */
X{
XFS_RESELT *prvp, *endp;
X
Xif (rlst != NULL)
X  {
X  prvp = endp = *rlst;
X  while (endp != NULL)
X    {
X    prvp = endp;
X    endp = endp->nxtreselt;
X    }
X  endp = (FS_RESELT *) getmemory(sizeof(FS_RESELT),"result element");
X  endp->nxtreselt = NULL;
X  endp->locatd = 0;
X  endp->action = rsp;
X  endp->nxtstate = NULL;
X  if (*rlst == NULL)
X    {
X    *rlst = endp;
X    endp->prvreselt = NULL;
X    }
X  else
X    {
X    prvp->nxtreselt = endp;
X    endp->prvreselt = prvp;
X    }
X  return(endp);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid fs_clrreslst(FS_RESELT **rlst)
X  /* Chain through *rlst, freeing all malloc()ed memory */
X{
XFS_RESELT *nxt;
X
Xwhile (*rlst != NULL)
X  {
X  nxt = (*rlst)->nxtreselt;
X  memfree(*rlst);
X  *rlst = nxt;
X  }
X}
X
XFS_STTELT *fs_appndsttelt(FS_STTELT **lstrt,
X                          int nstats)
X/* append a new element to *lstrt, and making nstats result slots for it.
X  return address of new element */
X{
XFS_STTELT *prvp,*endp;
X
Xif (lstrt != NULL)
X  {
X  prvp = endp = *lstrt;
X  while (endp != NULL)
X    {
X    prvp = endp;
X    endp = endp->nxtsttelt;
X    }
X  endp = (FS_STTELT *) getmemory(sizeof(FS_STTELT),"STT element");
X  endp->nxtsttelt = NULL;
X  endp->s_cis = NULL;
X#ifdef U_TRACK
X  endp->axcnt = 0;
X#endif
X  endp->reslts = (FS_RESELT *) getmemory(nstats*sizeof(FS_RESELT),
X                                           "result array for SST");
X  if (*lstrt == NULL)
X    *lstrt = endp;
X  else
X    prvp->nxtsttelt = endp;
X  return(endp);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid fs_initreselt(FS_RESELT *rep)
X  /* put NULL values into rep */
X{
Xrep->action = NULL;
Xrep->nxtstate = NULL;
Xrep->locatd = 0;
Xrep->nxtreselt = rep->prvreselt = NULL;
X}
X
XFS_STTELT *fs_newsttelt(FS_FSMSTRCT *fsp,
X                        char *ccis)
X  /* get a new stt element and clear it.  Return the address of the new
Xelement.  Append it to the SST list */
X{
XFS_STTELT *newelt;
Xint sp;
X
Xnewelt = fsp->laststt = fs_appndsttelt(&fsp->firststt,fsp->nstats);
Xnewelt->eltno = fsp->sttcnt++;
Xnewelt->achk = 0;
X/* fprintf(stdout,"stt:%d=%s\n",newelt->eltno,(ccis?ccis:"-")); */
Xif (ccis != NULL)
X  {
X  newelt->s_cis = bas_strdup(ccis);
X  wlu_addwrdptr(fsp->cis,ccis,(void *) newelt,NULL);  /* add to cis lu list */
X  }
Xelse
X  newelt->s_cis = NULL;
Xfor (sp = 0; sp < fsp->nstats; sp++)
X  fs_initreselt(newelt->reslts + sp);
Xreturn(newelt);
X}                        
X
Xint fs_sttonlst(FS_STTELT *plst,
X                FS_STTELT *pp)
X/* return 1 if pp is on list plst */
X{
XFS_STTELT *pt;
X
Xif (pp != NULL)
X  {
X  pt = plst;
X  while (pt != NULL)
X    if (pt == pp)
X      return(1);
X    else
X      pt = pt->nxtsttelt;
X  }
X/* fell off end, return 0 */
Xreturn(0);
X}
X
Xvoid fs_initfsmbld(FS_FSMSTRCT *fsm,
X                   int casedep)
X/* init data structures prior to building fsm */
X{
Xfsm->cis = (WRD_LUSTRCT *) getmemory(sizeof(WRD_LUSTRCT),"cis word lu struct");
Xwlu_initlustrct(fsm->cis,casedep,0);
Xfsm->null_reslt = NULL;
Xfsm->currstt = NULL;
Xfsm->strmax = (wlu_maxwrdlen(fsm->instrngs));
Xfsm->cisbuf = getmemory((fsm->strmax+2),"new cis buf");
X}
X
XWRD_LU_REC *fs_shed2lurec(FS_FSMSTRCT *fss,
X                          char *cstrng,
X                          size_t lcstr)
X/* return a pointer to the lu_rec for which cstrng matches the head.
XNULL if non-existent */
X{
XWRD_LU_REC *wrpt;
X
Xwrpt = wlu_lulst4wrd(fss->instrngs,cstrng);
Xwhile (wrpt != NULL)
X  switch (fss->instrngs->casedep)
X    {
X    case WLU_CASEIND:
X    case WLU_CASEWILD:
X      if (strncasecmp(cstrng,wrpt->wrd,lcstr) == 0)    /* found it */
X        return(wrpt->retval);
X      else
X        wrpt = wrpt->nextiwrd;
X      break;
X    case WLU_CASEDEP:
X    default:
X      if (strncmp(cstrng,wrpt->wrd,lcstr) == 0)      /* found it */
X        return(wrpt->retval);
X      else
X        wrpt = wrpt->nextiwrd;
X      break;
X    }
Xreturn(NULL);  /* not found */
X}
X
XFS_DATPRELT *fs_appnddatpr(FS_DATPRELT **dlst,
X                           char *sstr,
X                           void *sstxt,
X                           int mset)
X/* append a new value to *dlst, return address of new element.
Xsstr values are strdup()ed locally, mset notes if the sstxt quantities
Xwere malloc()ed and can thus be free()ed */
X{
XFS_DATPRELT *prvp, *endp;
X
Xif (dlst != NULL)
X  {
X  prvp = endp = *dlst;
X  while (endp != NULL)
X    {
X    prvp = endp;
X    endp = endp->nxtpelt;
X    }
X  endp = (FS_DATPRELT *) getmemory(sizeof(FS_DATPRELT),"data pair element");
X  endp->nxtpelt = NULL;
X  endp->dstrng = bas_strdup(sstr);
X  endp->ldstr = strlen(sstr);
X  endp->stxt = sstxt;
X  endp->plocat = 0;
X  endp->mallced = mset;
X  if (*dlst == NULL)
X    {
X    *dlst = endp;
X    endp->prvpelt = NULL;
X    }
X  else
X    {
X    prvp->nxtpelt = endp;
X    endp->prvpelt = prvp;
X    }
X  return(endp);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid fs_clrprlst(FS_DATPRELT **rlst)
X  /* Chain through *rlst, freeing all malloc()ed memory */
X{
XFS_DATPRELT *nxt;
X
Xwhile (*rlst != NULL)
X  {
X  nxt = (*rlst)->nxtpelt;
X  if ((*rlst)->mallced && ((*rlst)->stxt != NULL))
X    memfree((*rlst)->stxt);
X  if ((*rlst)->dstrng != NULL)
X    memfree((*rlst)->dstrng);
X  memfree(*rlst);
X  *rlst = nxt;
X  }
X}
X
Xint fs_cntdatprs(FS_DATPRELT *pp)
X  /* return the number of datalist items in *pp */
X{
Xif (pp == NULL)
X  return(0);
Xelse
X  return(fs_cntdatprs(pp->nxtpelt)+1);
X}
X
Xint fs_inprcnt(FS_DATPRELT *plst,
X               FS_DATPRELT *pp)
X/* count pair elements in plst till pp, 0 for none */
X{
XFS_DATPRELT *pt;
Xint cnt;
X
Xif (pp == NULL)
X  return(0);
Xelse
X  {
X  cnt = 1;
X  pt = plst;
X  while (pt != NULL)
X    if (pt == pp)
X      return(cnt);
X    else
X      {
X      cnt++;
X      pt = pt->nxtpelt;
X      }
X/* fell off end, return 0 */
X  return(0);
X  }
X}
X
Xvoid fs_adddatprs(FS_FSMSTRCT *fss,
X                  char *sstrng,
X                  void *lval)
X/* put a data pair (sstrng associated with lval) into fss. */
X{
Xfss->lstpr = fs_appnddatpr(&fss->prlst,sstrng,lval,0);
X}
X
Xvoid fs_addstrprs(FS_FSMSTRCT *fss,
X                  char *sstrng,
X                  char *stxt)
X/* put a data pair (sstrng associated with stxt) into fss, stxt is
Xstrdup()ed locally. */
X{
Xfss->lstpr = fs_appnddatpr(&fss->prlst,sstrng,bas_strdup(stxt),1);
X}
X
Xint fs_saycchr(FILE *fl,
X               char c)
X/* write character c to fl in "c" style, return no of chars actually used */
X{
Xif ((c < ' ') || (c > '~'))
X  {
X  fprintf(fl,"\\%03o",(int) c);
X  return(4);
X  }
Xelse
X  {
X  fputc(c,fl);
X  return(1);
X  }
X}
X
Xint fs_lstcstr(FILE *fl,
X               char *str)
X/* display characters of str to fl, converting non-printable chars to standard
XC representation, return no chars actually written */
X{
Xchar *sp;
Xint ccnt;
X
Xccnt = 0;
Xif (str != NULL)
X  {
X  sp = str;
X  while (*sp != '\0')
X    ccnt += fs_saycchr(fl,*sp++);
X  }
Xreturn(ccnt);
X}
X
Xvoid fs_lstdatpr(FILE *fl,
X                 FS_DATPRELT *pp,
X                 int cnt)
X/* recursively list *pp */
X{
Xif (pp != NULL)
X  {
X  fprintf(fl,"%d: \"",cnt);
X  (void) fs_lstcstr(fl,pp->dstrng);
X  fprintf(fl,"\" - %lx\n",pp->stxt);
X  fs_lstdatpr(fl,pp->nxtpelt,++cnt);
X  }
X}
X
Xvoid fs_showcstr(FILE *fl,
X                 void *p)
X/* let p be pointer to a char string, print it c-style */
X{
Xif (p)
X  {
X  fputc('"',fl);
X  (void) fs_lstcstr(fl,p);
X  fputc('"',fl);
X  }
Xelse
X  fputs("<NULL>",fl);
X}
X
Xvoid fs_showpval(FILE *fl,
X                 void *p)
X/* let p be an arbitrary pointer, print it */
X{
Xfprintf(fl,"%lx",p);
X}
X
Xvoid fs_lststrpr(FILE *fl,
X                 FS_DATPRELT *pp,
X                 int cnt,
X                 void (*slstfn)(FILE *bfl,
X                                void *p),
X                 void (*newlnfn)(FILE *afl))
X/* recursively list *pp */
X{
Xif (pp != NULL)
X  {
X  fprintf(fl,"%d:\"",cnt);
X  (void) fs_lstcstr(fl,pp->dstrng);
X  fputs("\"-",fl);
X  (* slstfn)(fl,(char *) pp->stxt);
X  (*newlnfn)(fl);
X  fs_lststrpr(fl,pp->nxtpelt,++cnt,slstfn,newlnfn);
X  }
X}
X
Xint fs_dprs2wlu(FS_FSMSTRCT *fss,
X                int casedep)
X  /* malloc()s storage for instrng wlu table, inits and loads data pairs
Xinto it.  Return count of included values */
X{
XFS_DATPRELT *pp;
Xint cnt;
X
Xfss->instrngs = (WRD_LUSTRCT *) getmemory(sizeof(WRD_LUSTRCT),
X                                            "in word lu struct");
Xwlu_initlustrct(fss->instrngs,casedep,0);
Xpp = fss->prlst;
Xcnt = 0;
Xwhile (pp != NULL)
X  {
X  if (pp->mallced)
X    wlu_addwrdptr(fss->instrngs,pp->dstrng,(void *) pp,pp->stxt);
X  else
X    wlu_addwrdptr(fss->instrngs,pp->dstrng,(void *) pp,NULL);
X  pp = pp->nxtpelt;
X  cnt++;
X  }
Xreturn(cnt);
X}
X
Xvoid fs_lstprwlureclst(FILE *fl,
X                       WRD_LU_REC *wp)
X/* recursively list elements of wp */
X{
Xif (wp != NULL)
X  {
X  fprintf(fl,"\"%s\" - \"%s\" %lx\n",wp->wrd,wp->helpline,wp->retval);
X  fs_lstprwlureclst(fl,wp->nextiwrd);
X  }
X}
X
Xvoid fs_lstwluprs(FILE *fl,
X                  WRD_LUSTRCT *wlus)
X/* list the contents of wlus at fl */
X{
Xint ap;
Xint ninits;
X
Xap = 0;
Xninits = wlu_no_inits(wlus->casedep);
Xwhile (ap < ninits)
X  fs_lstprwlureclst(fl,*(wlus->firstlet+ap++));
X}
X
XFS_STTELT *fs_nxtincmplt(FS_FSMSTRCT *fss,
X                         int *ii)
X/* return the address of the next incomplete element in stt.
Xii, if non-NULL will be set to the alphabetic value for the first non-completed position of this stt element.  NULL if none */
X{
XFS_STTELT *sp;
Xint ap;
X
Xif (fss->currstt == NULL)
X  fss->currstt = fss->firststt;
Xsp = fss->currstt;
Xwhile (sp != NULL)
X  {
X  ap = 0;
X  while (ap < fss->nstats)
X    if ((sp->reslts+ap)->nxtstate == NULL)
X      {
X      if (ii != NULL)
X        *ii = ap;
X      fss->currstt = sp;       /* note this state, to reduce scan time */
X      return(sp);
X      }
X    else
X      ap++;
X  sp = sp->nxtsttelt;
X  }
Xreturn(fss->currstt = NULL);
X}
X
Xsize_t fs_cislen(FS_STTELT *stt)
X  /* return the length of the current cis */
X{
Xif ((stt == NULL) || (stt->s_cis == NULL))
X  return(0);
Xelse
X  return(strlen(stt->s_cis));
X}
X
Xchar *fs_bldstat2str(FS_BLDSTATUS bs)
X  /* a string for bs */
X{
Xswitch (bs)
X  {
X  case FS_bldnoint:
X    return("FS_bldnoint");
X    break;
X  case FS_bldmatcis:
X    return("FS_bldmatcis");
X    break;
X  case FS_bldmatinpt:
X    return("FS_bldmatinpt");
X    break;
X  case FS_bldintrst:
X    return("FS_bldintrst");
X    break;
X  default:
X    return("FS_bld???");
X    break;
X  }
X}
X
Xint fs_chkinpstr(FS_FSMSTRCT *fss,
X                 FS_STTELT *sttp,
X                 int ap,
X                 char *acis)
X/* check if acis matches any input strings & if so, note them as outputs.
XEffectively implements Rule 3, return count of matching strings */
X{
XFS_RESELT *pt;
XWRD_LU_REC *wrp;
XFS_DATPRELT *dp;
Xint mcnt;
X
Xmcnt = 0;
Xwrp = wlu_wrd2lurec(fss->instrngs,acis);
Xwhile (wrp != NULL)
X  { /* it did, note this as a result */
X  mcnt++;
X  dp = (FS_DATPRELT *) wrp->retval;
X  pt = sttp->reslts + ap;
X  (void) fs_appndreselt(&pt,(void *) dp);
X  dp->plocat = 1;
X  wrp = wlu_lurec4wrd(fss->instrngs,wrp->nextiwrd,acis);
X  }
Xreturn(mcnt);
X}
X
Xint fs_chksubstrs(FS_FSMSTRCT *fss,
X                  FS_STTELT *sttp,
X                  int ap,
X                  char *acis)
X/* check if beheaded substrings of acis match any output states & if so,
Xnote them as outputs. return count of any matches */
X{
Xchar *sp;
Xint mcnt;
X
Xmcnt = 0;
Xif (*acis != '\0')
X  {
X  sp = acis + 1;
X  while (*sp != '\0')
X    {
X    mcnt += fs_chkinpstr(fss,sttp,ap,sp);
X    sp++;
X    }
X  }
Xreturn(mcnt);
X}
X
Xvoid fs_trynewcis(FS_FSMSTRCT *fss,
X                  FS_STTELT *sttp,
X                  int ap,
X                  char *nwcis,
X                  int clen,
X                  int (*chkinpstrfn)(FS_FSMSTRCT *xfss,
X                                     FS_STTELT *xsttp,
X                                     int xap,
X                                     char *xacis),
X                  WRD_LU_REC *(*shed2lurecfn)(FS_FSMSTRCT *zfss,
X                                              char *zcstrng,
X                                              size_t zlcstr))
X/* perform Rules 3,4,5 on acis, return information on the status */
X{
XFS_STTELT *cp;
Xchar *acis;            /* "start" of nwcis */
Xint chkintcis;
X
Xacis = nwcis;
Xchkintcis = 1;
X(sttp->reslts+ap)->nxtstate = fss->firststt;
Xwhile (*acis != '\0')   /* while we still have some new cis to look for */
X  {  /* rule 3: look for a match in input strings */
X  (void) (*chkinpstrfn)(fss,sttp,ap,acis);
X/* Rule 4: Does this match an existing cis?? */
X  if (chkintcis)
X    if ((cp = (FS_STTELT *) wlu_chkwrdptr(fss->cis,acis)) != NULL)
X       /* yep, note the newstate as the next state for this result */
X      {
X      (sttp->reslts+ap)->nxtstate = cp;
X      chkintcis = 0;
X      }
X/* Rule 5: is this of interest?? */
X    else
X      {
X      if ((*shed2lurecfn)(fss,acis,clen) != NULL)
X        {  /* is interesting - create new state for it */
X        fss->laststt = fs_newsttelt(fss,acis);      /* Rule 5 */
X        (sttp->reslts+ap)->nxtstate = fss->laststt;
X        chkintcis = 0;
X        }
X      }
X  acis++;
X  clen--;
X  }
X}
X
Xint fs_trycisnosub(FS_FSMSTRCT *fss,
X                   FS_STTELT *sttp,
X                   int ap,
X                   char *nwcis,
X                   int clen,
X                   int (*chkinpstrfn)(FS_FSMSTRCT *xfss,
X                                      FS_STTELT *xsttp,
X                                      int xap,
X                                      char *xacis),
X                   WRD_LU_REC *(*shed2lurecfn)(FS_FSMSTRCT *zfss,
X                                               char *zcstrng,
X                                               size_t zlcstr))
X/* perform Rules 3,4,5 on acis, return information on the status, method of
XSmith (1988), Cabios, 4, 459 */
X{
XFS_DATPRELT *dp;
XFS_STTELT *cp;
Xchar *acis;            /* "start" of nwcis */
Xint inlutmat;
Xint addcnt;
Xint cismat;
X
Xacis = nwcis;
Xaddcnt = 0;
X(sttp->reslts+ap)->nxtstate = fss->firststt;
X/* is this cis an output? if so note it - Rule 3 */
Xinlutmat = (*chkinpstrfn)(fss,sttp,ap,acis) > 0;
Xwhile (clen > 0)
X  {    /* is this cis already present as a cis? - Rule 4 */
X  if (cismat = ((cp = (FS_STTELT *) wlu_chkwrdptr(fss->cis,acis)) != NULL))
X    { /* yes, note new state as next state for this result */
X    (sttp->reslts+ap)->nxtstate = cp;
X    return(addcnt);        /* and stop looking */
X    }
X      /* does acis match start of any site - Rule 5 */
X  if ((dp = (FS_DATPRELT *) (*shed2lurecfn)(fss,acis,clen))
X         != NULL)
X    {     /* is interesting - create new state for it, if not located */
X    if (dp->plocat == 0)
X      {
X      fss->laststt = fs_newsttelt(fss,acis);      /* Rule 5 */
X      (sttp->reslts+ap)->nxtstate = fss->laststt;
X      return(++addcnt);
X      }
X    if (inlutmat || cismat)   /* bale out if matched input or cis */
X      return(addcnt);
X    }
X  acis++;
X  clen--;
X  }  
Xreturn(addcnt);
X}
X
Xint fs_bldstt4prs(FS_FSMSTRCT *fss,
X                  char (* int2chrfn)(int ci),
X                  int (*chkinpstrfn)(FS_FSMSTRCT *xfss,
X                                     FS_STTELT *xsttp,
X                                     int xap,
X                                     char *xacis),
X                  WRD_LU_REC *(*shed2lurecfn)(FS_FSMSTRCT *zfss,
X                                              char *zcstrng,
X                                              size_t zlcstr))
X/* go thru logic for building stt for loaded data, return no of states
Xrequired.  (*int2chrfn)() is used to convert an alpha pointer to a char */
X{
Xint ap;
XFS_STTELT *nxtinc;      /* next incomplete element */
Xsize_t clen;
Xchar *sp;
X
Xfss->laststt = fs_newsttelt(fss,NULL);      /* Rule 1 */
Xwhile ((nxtinc = fs_nxtincmplt(fss,&ap)) != NULL)
X  {
X  clen = fs_cislen(nxtinc);  /* make the new cis: Rule 2 */
X  if (clen > fss->strmax)
X    {
X    fprintf(stderr,"Cis length (%d) exceeds buffer\n",clen);
X    exit(1);
X    }
X  *fss->cisbuf = '\0';
X  if (nxtinc->s_cis != NULL)
X    strncat(fss->cisbuf,nxtinc->s_cis,clen);
X  sp = fss->cisbuf + clen;
X  *sp++ = (*int2chrfn)(ap);
X  *sp = '\0';
X               /* is this interesting?? */
X  if (fss->dosubs)
X    fs_trynewcis(fss,nxtinc,ap,fss->cisbuf,(int)(clen+1),chkinpstrfn,
X                   shed2lurecfn);
X  else
X    (void) fs_trycisnosub(fss,nxtinc,ap,fss->cisbuf,(int)(clen+1),chkinpstrfn,
X                            shed2lurecfn);
X  }
Xreturn(fss->sttcnt);
X}
X
Xvoid fs_purgecis(FS_FSMSTRCT *fss)
X  /* remove cis storage from fss */
X{
XFS_STTELT *sp;
X
Xsp = fss->firststt;
Xwhile (sp != NULL)
X  {
X  if (sp->s_cis != NULL)
X    {
X    memfree(sp->s_cis);
X    sp->s_cis = NULL;
X    }
X  sp = sp->nxtsttelt;
X  }
X}
X
Xvoid fs_purgelustrct(FS_FSMSTRCT *fss)
X  /* remove lookup structures and cis buffer from fss */
X{
Xwlu_clrlustrct(fss->cis);
Xfss->cis = NULL;
Xwlu_clrlustrct(fss->instrngs);
Xfss->instrngs = NULL;
Xif (fss->cisbuf != NULL)   /* make sure OK for possible repeat purges */
X  memfree(fss->cisbuf);
Xfss->cisbuf = NULL;
X}
X
Xvoid fs_purgefsm(FS_FSMSTRCT *fss)
X  /* remove unnecessary storage from fss */
X{
Xfs_purgecis(fss);
Xfs_purgelustrct(fss);
X}
X
Xvoid fs_clrfsm(FS_FSMSTRCT *fss)
X  /* clear storage from fss, leave basic fss structure, but denude it of 
Xany malloc()ed stuff */
X{
XFS_STTELT *sp;
XFS_STTELT *nxt;
XFS_RESELT *rp;
Xint ap;
X
Xfs_purgefsm(fss);
Xsp = fss->firststt;
Xwhile (sp != NULL)      /* for each stt table entry */
X  {   /*  interate thru each reslt, clearing any results */
X  for (ap = 0; ap < fss->nstats; ap++)
X    {
X    rp = (sp->reslts+ap)->nxtreselt;
X    fs_clrreslst(&rp);
X    }
X  memfree(sp->reslts);    /* de_malloc basic reslts array */
X  nxt = sp->nxtsttelt;   /* check nxt element */
X  memfree(sp);           /* kill this element */
X  sp = nxt;
X  }
Xfss->firststt = fss->laststt = NULL;
Xfs_clrprlst(&fss->prlst);
Xfss->lstpr = NULL;
X}
X
Xvoid fs_killfsm(FS_FSMSTRCT **fss)
X  /* completely free() *fss storage, base fss structure included */
X{
Xif (*fss != NULL)
X  {
X  fs_clrfsm(*fss);
X  memfree(*fss);
X  *fss = NULL;
X  }
X}
X
Xint fs_chkfsm(FS_FSMSTRCT *fss,
X              int erprt,
X              char (*int2chr)(int ic))
X/* check fss to ensure:
X  1: all data pairs are located
X  2: all states are valid & exist
X  3: all stt entries will be accessed, somehow (except state 0)
X  4: anything else I think of
Xreturn 1 if OK.  erprt controls error reporting: 0 means say nothing, nonzero
Xmention each error */
X{
XFS_DATPRELT *dp;
Xint icnt;
Xint pcnt;
Xint stat;
XFS_STTELT *sp;
Xint ap;
XFS_STTELT *np;
X
X/* Test 1: all input states are located */
Xstat = 1;
Xpcnt = icnt = 0;
Xdp = fss->prlst;
Xif (fss->dosubs)
X  {
X  while (dp != NULL)
X    {
X    pcnt++;
X    if (!dp->plocat)
X      {
X      icnt++;
X      if (erprt)
X        {
X        fprintf(stderr,"string %d \"",fs_inprcnt(fss->prlst,dp));
X        (void) fs_lstcstr(stderr,dp->dstrng);
X        fputs("\" not located\r\n",stderr);
X        }
X      }
X    dp = dp->nxtpelt;
X    }
X  if ((pcnt > 0) && (icnt > 0))
X    stat = 0;
X  }
X/* tests 2 & 3: all stt pointers are valid and all stt states are accessible */
Xsp = fss->firststt;
Xwhile (sp != NULL)
X  {
X  for (ap = 0; ap < fss->nstats; ap++)
X    {
X    np = (sp->reslts+ap)->nxtstate;
X    if (!fs_sttonlst(fss->firststt,np))
X      {
X      stat = 0;
X      if (erprt)
X        fprintf(stderr,"STT state %d has invalid nextstate (%lx) for '%c'\n",
X                  sp->eltno,(sp->reslts+ap)->nxtstate,(*int2chr)(ap));
X      }
X    else   /* test 3 - mark next state as accessible */
X      np->achk = 1;
X    }
X  sp = sp->nxtsttelt;
X  }
Xsp = fss->firststt;
Xwhile (sp != NULL)
X  {
X  if ((!sp->achk) && (sp->eltno > 0))   /* state 0 may not be addressed */
X    {
X    stat = 0;
X    if (erprt)
X      fprintf(stderr,"STT state %d inaccessible\n",sp->eltno);
X    }    
X  sp = sp->nxtsttelt;
X  }
Xreturn(stat);
X}
X
Xint fs_bldfsm(FS_FSMSTRCT *fss,
X              int casedep,
X              int errpt,
X              int purge,
X              char (*int2chr)(int ic),
X              int (*chkinpstrfn)(FS_FSMSTRCT *xfss,
X                                 FS_STTELT *xsttp,
X                                 int xap,
X                                 char *xacis),
X              WRD_LU_REC *(*shed2lurecfn)(FS_FSMSTRCT *zfss,
X                                          char *zcstrng,
X                                          size_t zlcstr))
X/* combine a series of fsm building steps, return no of states if checks OK,
Xelse -1.  errpt controls error reporting: 1 = mention each error, 0 = don't,
X  -1 = check, but ignore result  */
X{
Xint nstate;
X
Xif (fs_dprs2wlu(fss,casedep) > 0)
X  {
X  fs_initfsmbld(fss,casedep);
X  if ((nstate = fs_bldstt4prs(fss,int2chr,chkinpstrfn,shed2lurecfn)) > 0)
X    {
X    if (purge)
X      fs_purgefsm(fss);
X    if ((fs_chkfsm(fss,errpt,int2chr)) || (errpt == -1))
X      return(nstate);
X    }
X  }
Xreturn(-1);
X}
X
Xvoid fs_initrun(FS_FSMSTRCT *fss)
X/* initialise the fsm for running */
X{
Xfss->currstt = fss->firststt;
X}
X
XFS_RESELT *fs_procchr(FS_FSMSTRCT *fss,
X                      char nc,
X                      int (*chr2int)(char c))
X/* feed nc into fsm and return any result list.  if nc is invalid, behavior
Xis determined by fss->invact. The returned value is the heading to a linked 
Xlist of results */
X{
Xint ap;
XFS_STTELT *sp;
XFS_RESELT *rtp;
X
Xif (((ap = (*chr2int)(nc)) < 0) || (ap >= fss->nstats))
X  {
X  switch (fss->invact)
X    {
X    case FS_inv_ressay:
X      fputs("Invalid char '",stderr);
X      (void) fs_saycchr(stderr,nc);
X      fputs("' - FSM is reset\n",stderr);
X    case FS_inv_reset:
X      fs_initrun(fss);
X      break;
X    case FS_inv_ignsay:
X      fputs("Invalid char '",stderr);
X      (void) fs_saycchr(stderr,nc);
X      fputs("' - FSM not reset\n",stderr);
X    case FS_inv_ignor:
X    default:
X      break;
X    }
X  return(NULL);
X  }
Xelse
X  {
X  rtp = (fss->currstt->reslts+ap)->nxtreselt;
X  sp = (fss->currstt->reslts+ap)->nxtstate;
X#ifdef U_TRACK
X  sp->axcnt++;
X#endif
X  fss->currstt = sp;
X  return(rtp);
X  }
X}
X
Xint fs_sttsmatch(FS_FSMSTRCT *ffst,
X                 FS_STTELT *stt1,
X                 FS_STTELT *stt2)
X/* return 1 if stt1 and stt2 match: same nextstate for all positions and
XNULL action */
X{
Xint ep;
XFS_RESELT *rs1;
XFS_RESELT *rs2;
X
Xif ((stt1 == NULL) || (stt2 == NULL))  /* one/both doesn't exist, ret 0 */
X  return(0);
Xelse
X  {
X  for (ep = 0; ep < ffst->nstats; ep++)
X    {
X    rs1 = stt1->reslts + ep;
X    rs2 = stt2->reslts + ep;
X    if (rs1->nxtstate != rs2->nxtstate)
X      return(0);
X    else
X      if (!((rs1->nxtreselt == NULL) && (rs2->nxtreselt == NULL)))
X        return(0);
X    }
X/* fell off end: match - return 1 */
X  return(1);
X  }
X}
X
Xint fs_modnxtsttelts(FS_FSMSTRCT *ffst,
X                     FS_STTELT *oldstt,
X                     FS_STTELT *newstt)
X/* traverse all of stt in ffst, replacing every reference to oldstt with
Xone to newstt.  Return the number so modified */
X{
XFS_STTELT *stp;
Xint ep;
Xint mdcnt;
XFS_RESELT *rp;
X
Xstp = ffst->firststt;
Xmdcnt = 0;
Xwhile (stp != NULL)
X  {
X  for (ep = 0; ep < ffst->nstats; ep++)
X    {
X    rp = stp->reslts + ep;
X    if (rp->nxtstate == oldstt)
X      {
X      rp->nxtstate = newstt;
X      mdcnt++;
X      }
X    }
X  stp = stp->nxtsttelt;
X  }
Xreturn(mdcnt);
X}
X
Xint fs_rmdupstts(FS_FSMSTRCT *ffst)
X  /* scan stts, looking for duplicates which have no actions: combine into
Xfirst occurrence, and delete the duplicate.  Return number of dups so
Xremoved */
X{
XFS_STTELT *sp1;
XFS_STTELT *sp2;
Xint kcnt;
XFS_STTELT *prvs;
Xint ep;
XFS_RESELT *rp;
X
Xkcnt = 0;
Xsp1 = ffst->firststt;
Xwhile (sp1 != NULL)
X  {
X  prvs = sp1;
X  sp2 = sp1->nxtsttelt;
X  while (sp2 != NULL)
X    {
X    if (fs_sttsmatch(ffst,sp1,sp2))
X      {
X      kcnt++;
X      if (fs_modnxtsttelts(ffst,sp2,sp1) > 0)
X        {
X        for (ep = 0; ep < ffst->nstats; ep++)
X          {
X          rp = (sp2->reslts+ep)->nxtreselt;
X          fs_clrreslst(&rp);
X          }
X        memfree(sp2->reslts);
X        prvs->nxtsttelt = sp2->nxtsttelt;
X        memfree(sp2);
X        }
X      sp2 = prvs->nxtsttelt;
X      }
X    prvs = sp2;
X    if (sp2 != NULL)
X      sp2 = sp2->nxtsttelt;
X    }
X  sp1 = sp1->nxtsttelt;
X  }
Xreturn(kcnt++);
X}
X
Xvoid fs_lststtelt(FILE *fl,
X                  FS_FSMSTRCT *fss,
X                  FS_STTELT *stp)
X/* tell fl about stp */
X{
Xint ap;
XFS_RESELT *nxt;
XFS_STTELT *snx;
XFS_RESELT *dp;
X
Xfprintf(fl,"%d:%s",stp->eltno,(stp->s_cis?stp->s_cis:"-"));
Xfor (ap = 0; ap < fss->nstats; ap++)
X  {
X  nxt = stp->reslts+ap;
X  if (nxt == NULL)
X    fputs(" ?/?",fl);
X  else
X    if ((snx = (FS_STTELT *) nxt->nxtstate) == NULL)
X      fprintf(fl," Null/*");
X    else
X      {
X      fprintf(fl," %d",snx->eltno);
X      if (nxt->nxtreselt == NULL)
X        fputs("/-",fl);
X      else
X        {
X        dp = (FS_RESELT *) nxt->nxtreselt;
X        while (dp != NULL)
X          {
X          fprintf(fl,"/%d",fs_inprcnt(fss->prlst,dp->action));
X          dp = dp->nxtreselt;
X          }
X        }
X      }
X  }
Xfputc('\n',fl);
Xfflush(fl);
X}
X
Xvoid fs_lststttbl(FILE *fl,
X                  FS_FSMSTRCT *fss)
X/* list info in fss */
X{
XFS_STTELT *stp;
X
Xstp = fss->firststt;
Xwhile (stp != NULL)
X  {
X  fs_lststtelt(fl,fss,stp);
X  stp = stp->nxtsttelt;
X  }
X}
X
Xvoid fs_tellusage(FILE *fl,
X                  FS_FSMSTRCT *fss)
X/* tell fl about the usage of each state of fss */
X{
X#ifdef U_TRACK
X
XFS_STTELT *sp;
Xint cttl;
Xint scnt;
Xint ocnt;
X
Xocnt = scnt = cttl = 0;
Xsp = fss->firststt;
Xwhile (sp != NULL)
X  {
X  fprintf(fl,"%d\t%d\t%s\n",sp->eltno,sp->axcnt,(sp->s_cis?sp->s_cis:""));
X  scnt++;
X  cttl += sp->axcnt;
X  if (sp->axcnt > 0)
X    ocnt++;
X  sp = sp->nxtsttelt;
X  }
Xfprintf(fl,"\n%d States (%d used) with total %d counts\n",scnt,ocnt,cttl);
X
X#else
X
Xfputs("STT usage is not enabled: compile with -DU_TRACK\n",fl);
X
X#endif
X}
END-of-meth_progs_dist/src/fsm_ops.c
echo x - meth_progs_dist/src/illum2fasta.awk
sed 's/^X//' >meth_progs_dist/src/illum2fasta.awk << 'END-of-meth_progs_dist/src/illum2fasta.awk'
X# illum2fasta.awk: read illumina text files and convert header & seq lines to fasta format.
X#  shorten headers.
X#
X# to run: awk -f illum2fasta.awk s1_trim75.txt > s1_trim75.fa
X#
XBEGIN { if (hdrstr=="") hdrstr = "s1"; ecnt=0; prvishdr=0; }
X
X/^@/ { split($0,colonsep,":");
X  split(colonsep[5],chatchsep,"#");
X  printf(">%s_%s_%s_%s\n",hdrstr,colonsep[3],colonsep[4],chatchsep[1]); \
X  prvishdr = 1; \
X  }
X/^[^@]/ { if (prvishdr)
X  {
X  printf("%s\n",$0);
X  prvishdr=0;
X  ecnt++;
X  }
X}
END-of-meth_progs_dist/src/illum2fasta.awk
echo x - meth_progs_dist/src/Makefile
sed 's/^X//' >meth_progs_dist/src/Makefile << 'END-of-meth_progs_dist/src/Makefile'
X# make file for cpgis
X#
X# Configure the following to suit your setup..
X#
X# edit these to reflect actual library and include locations..
XHDRLOC = ../include/
X
X#
X# define compile and load commands here.
XCFLGS =
XCC = cc
XCCLDFLGS =
XCINCLUDES = -I../include
XCCLIBS = -lm
XCCMP = $(CC) -c $(CFLGS) -o $@ $(CINCLUDES) $*.c
XCCLD = $(CC) $(CCLDFLGS) -o $@ $@.o $(CCLIBS) $(SYSLIBS)
XOBJS = bas_fns.o sqfl_fns.o sqmat_fns.o wlu_fns.o rbs_fns.o mrg_fns.o
XC_OBJS = cpgis.o $(OBJS)
XFSMOBJS = $(OBJS) fsm_ops.o
X
X# dependency rules
X
XEXES = rmapbsbed2cpg bin_cnts mkrrgenome scan_cpg_depth cleanadaptors
X
Xall: $(EXES)
X
Xrmapbsbed2cpg: rmapbsbed2cpg.o $(OBJS)
X	       $(CCLD) $(OBJS)
X
Xrmapbsbed2cpg.o: rmapbsbed2cpg.c rmapbsbed2cpg.h mrg_fns.h rbs_fns.h
X		 $(CCMP)	       
X
Xbin_cnts: bin_cnts.o $(FSMOBJS)
X	  $(CCLD) $(FSMOBJS)
X
Xbin_cnts.o: bin_cnts.c bin_cnts.h
X	    $(CCMP)
X
Xmkrrgenome: mkrrgenome.o $(FSMOBJS)
X	    $(CCLD) $(FSMOBJS)
X
Xmkrrgenome.o: mkrrgenome.c bin_cnts.h rmapbsbed2cpg.h
X	      $(CCMP)
X
Xscan_cpg_depth: scan_cpg_depth.o $(FSMOBJS)
X		$(CCLD) $(FSMOBJS)
X
Xscan_cpg_depth.o: scan_cpg_depth.c
X		  $(CCMP)
X
Xcleanadaptors: cleanadaptors.o $(FSMOBJS)
X	  $(CCLD) $(FSMOBJS)
X
Xcleanadaptors.o: cleanadaptors.c
X	    $(CCMP)
X
Xbas_fns.o: bas_fns.c $(HDRLOC)bas_fns.h
X	$(CCMP)
X
Xsqfl_fns.o: sqfl_fns.c $(HDRLOC)sqfl_fns.h
X	$(CCMP)
X
Xwlu_fns.o: wlu_fns.c $(HDRLOC)wlu_fns.h
X	$(CCMP)
X
Xsqmat_fns.o: sqmat_fns.c $(HDRLOC)sqmat_fns.h
X	$(CCMP)
X
Xfsm_ops.o: fsm_ops.c $(HDRLOC)fsm_ops.h
X	$(CCMP)
X
Xrbs_fns.o: rbs_fns.c rbs_fns.h
X	$(CCMP)
X
Xmrg_fns.o: mrg_fns.c mrg_fns.h
X	$(CCMP)
X
Xclean:
X	-rm *.o
X
XCLEAN: clean
X	-rm $(EXES)
X
Xdebug:
X	$(MAKE) all CFLGS=-g
X
Xmallocdebug: clean
X	$(MAKE) all CFLGS="-g -DMALLOCDBG"
END-of-meth_progs_dist/src/Makefile
echo x - meth_progs_dist/src/mk4to1lines.awk
sed 's/^X//' >meth_progs_dist/src/mk4to1lines.awk << 'END-of-meth_progs_dist/src/mk4to1lines.awk'
X# mk4to1lines.awk: take standard in and write out each 4 lines concated
X# into 1, with catchar (defaults to ";") separating each concatted line
XBEGIN { if (catchar == "") catchar = ";"; lcnt=1 }
X{if (lcnt <= 3)
X  {
X  printf("%s%s",$0,catchar);
X  lcnt++;
X  }
Xelse
X  {
X  printf("%s\n",$0);
X  lcnt = 1;
X  }
X}
XEND { if (lcnt > 1) printf("\n"); }
END-of-meth_progs_dist/src/mk4to1lines.awk
echo x - meth_progs_dist/src/mkrrgenome.c
sed 's/^X//' >meth_progs_dist/src/mkrrgenome.c << 'END-of-meth_progs_dist/src/mkrrgenome.c'
X/* mkrrgenome: to generate reduced representation genome files for all
Xor selected chromosomes */
X
X#include <stdlib.h>
X#include <string.h>
X#include <stdarg.h>
X#include <stdio.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "sqfl_fns.h"
X#include "sqmat_fns.h"
X#include "rmapbsbed2cpg.h"
X#include "rbs_fns.h"
X#include "mrg_fns.h"
X#include "bin_cnts.h"
X#include "fsm_ops.h"
X
X/* Local defines */
X/* version: first OK version: 1-Apr-2011 */
X/* #define PROG_VERSION 1.0 */
X/* generate CpG position list: Nov-2011 */
X#define PROG_VERSION 1.1
X
X#define MRG_DEFMIN 40
X#define MRG_DEFMAX 220
X
Xtypedef enum MRG_outstyle
X  {
X  MRG_out_rrgenomes = 0,  /* usual mode: generate RR genome files */
X  MRG_out_rrlist,         /* tabbed list of valid RR fragment positions */
X  MRG_out_cpginrng,       /* tabbed list of CpGs in valid RR fragments */
X  MRG_out_allcpg          /* tabbed list of all CpGs */
X  }
XMRG_OUTSTYLE;
X
X/* global debug & out style variables, for simplicity of access */
XRBC_DBG debuglevel;
XMRG_OUTSTYLE ostyle;
Xint glblreadlen;          /* global value for readlength */
X
Xint err_msg(char *fmt,
X            ...)
X/* write user error message.  Return 0 for err return status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xreturn(0);
X}
X
Xvoid err_msg_die(char *fmt,
X                 ...)
X/* write user error message then exit with error status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xexit(1);
X}
X
Xvoid say_usage(FILE *fl,
X               char *pnam)
X{
Xfprintf(fl,"%s (v%.2f): generate reduced representation genome files for MspI digests\n",
X          pnam,PROG_VERSION);
Xfputs("Options:\n",fl);
Xfputs("     -g <genomehead> dir and file string to locate genomic seq files by adding n.fa\n",fl);
Xfputs("     -c <C_no> restrict activity to chromosome C_no (1..22,X,Y), def = all\n",fl);
Xfprintf(fl,"     -M <j,k> scan for restricted rep fragment sizes between j & k residues. (def=%d..%d)\n",
X          MRG_DEFMIN,MRG_DEFMAX);
Xfputs("     -m <j,k>   ditto, produce tab delimited list of positions to stdout\n",fl);
Xfputs("     -p <j,k> generate tabbed list of CpG positions for j-k fragments\n",fl);
Xfputs("     -P generate tabbed list of all CpG positions\n",fl);
Xfputs("     -G <desthead> dir & file string for output genome files (-M), completed with n.fa\n",fl);
X}
X
Xchar tr_int2nares(int iv)
X  /* return a nucleic acid residue for iv */
X{
Xswitch (iv)
X  {
X  case 0:
X    return('a');
X    break;
X  case 1:
X    return('c');
X    break;
X  case 2:
X    return('g');
X    break;
X  case 3:
X    return('t');
X    break;
X  default:
X    return('?');
X    break;
X  }
X}
X
Xint tr_nares2int(char res)
X  /* return an int value 0..3 for res, -1 for unknown */
X{
Xswitch (toupper(res))
X  {
X  case 'A':
X    return(0);
X    break;
X  case 'C':
X    return(1);
X    break;
X  case 'G':
X    return(2);
X    break;
X  case 'T':
X  case 'U':
X    return(3);
X    break;
X  default:
X    return(-1);
X    break;
X  }
X}
X
Xint bc_fragsizeok(int fragmin,
X                  int fragmax,
X                  int fragsize)
X/* return if fragsize fragment is acceptable,
Xnoting that zero limits will always return true. */
X{
Xif ((fragmin != 0) && (fragmax != 0))
X  return(rbc_intinrng(fragmin,fragsize,fragmax));
Xelse
X  return(1);
X}
X
Xint rbc_getnscangenomesqs(MRG_OUTSTYLE ostyle,
X                          char *hdrstr,
X                          FS_FSMSTRCT *cpgfsmp,
X                          char *seqsarr[],
X                          int seqlens[],
X                          MRG_REGN_ELT *rrfrags[],
X                          int chrmax,
X                          int uchrno,
X                          int minfrag,
X                          int maxfrag)
X/* use hdrstr to create a series of file names, one
Xfor each chromosome, open each as a Fasta sequence
Xfile and create a buffer for each.  Return the
Xnumber of chromosomes processed */
X{
Xchar *sqfnam;
Xint chno;
Xint nblen;
XSQFL_STRCT *chsqfl;
Xint rcnt;
Xchar nsc;
Xint cpos;
XFS_RESELT *frp;
XFS_DATPRELT *dpep;
Xint prevmat;
XMRG_REGN_ELT *lstend;
Xint thismat;
Xint cpgcnt;
XMRG_REGN_ELT *cpglstp;
XMRG_REGN_ELT *cpglstend;
XMRG_REGN_ELT *cp;
X
Xrcnt = 0;
Xsqfnam = (char *) getmemory((nblen = strlen(hdrstr) + 16),"Sq file name buf");
Xfor (chno = 1; chno <= chrmax; chno++)
X  if ((uchrno == 0) || (uchrno == chno))
X    {
X    snprintf(sqfnam,nblen-1,"%s%s.fa",hdrstr,rbc_chrno2str((RBC_CHRNO) chno,1));
X    if ((chsqfl = sqfl_opnsqstrct(sqfnam,SFMT_fasta,"r")) != NULL)
X      {
X      seqlens[chno-1] = readsrcsq(chsqfl,NULL);
X      if (debuglevel > RBC_dbg_on)
X        {
X        fprintf(stdout,"%s: %d res,",sqfnam,seqlens[chno-1]);
X        fflush(stdout);
X        }
X      if (ostyle == MRG_out_rrgenomes)
X        seqsarr[chno-1] = (char *) getmemory(seqlens[chno-1]+1,"Chr Buff");
X      sqfl_rewind(chsqfl);
X      cpos = 0;
X      prevmat = 1;
X      lstend = NULL;
X      fs_initrun(cpgfsmp);
X      cpgcnt = 0;
X      (void) sqfl_skipsqflhdr(chsqfl);
X      cpglstp = cpglstend = NULL;
X      while ((nsc = sqfl_getnxtres(chsqfl)) != '\0')
X        {
X        if ((frp = fs_procchr(cpgfsmp,nsc,tr_nares2int)) != NULL)   /* have a match */
X          {
X          dpep = (FS_DATPRELT *) frp->action;
X          switch (dpep->ldstr)
X            {
X            case 2:        /* CpG */
X              cpgcnt++;
X              switch (ostyle)
X                {
X                case MRG_out_allcpg:
X                  fprintf(stdout,"%s\t%d\n",rbc_chrno2str(chno,1),cpos);
X                  break;
X                case MRG_out_cpginrng:
X                  cpglstend = mrg_appndrgnelt(&cpglstend,cpos,cpos,1);
X                  if (cpglstp == NULL)
X                    cpglstp = cpglstend;
X                  break;
X                default:
X                  break;
X                }
X              break;
X            case 4:       /* CCGG */
X              thismat = cpos - dpep->ldstr + 2;
X/*          if (debuglevel > RBC_dbg_none)
X            fprintf(stdout,"CCGG@%d, Frag=%d\n",thismat,thismat-prevmat+1); */
X              if (bc_fragsizeok(minfrag,maxfrag,thismat - prevmat + 1))
X                {
X                switch (ostyle)
X                  {
X                  case MRG_out_cpginrng:
X                    cp = cpglstp;
X                    while (cp != NULL)
X                      {
X                      fprintf(stdout,"%s\t%d\n",rbc_chrno2str(chno,1),cp->rstart);
X                      cp = cp->nxtregn;
X                      }
X                    break;
X                  case MRG_out_rrgenomes:
X                  case MRG_out_rrlist:
X                    lstend = mrg_appndrgnelt(&lstend,prevmat,thismat,cpgcnt);
X                    if (rrfrags[chno-1] == NULL)
X                      rrfrags[chno-1] = lstend;
X                    break;
X                  default:
X                    break;
X                  }
X                }
X              mrg_clrallregnelts(&cpglstp);
X              cpglstp = cpglstend = NULL;
X              prevmat = thismat + 1;
X              cpgcnt = 1;       /* is a cpg in CCGG */
X              break;
X            }
X          }
X        if (ostyle == MRG_out_rrgenomes)
X          {
X          *(seqsarr[chno-1] + cpos) = nsc;
X          *(seqsarr[chno-1] + cpos + 1) = '\0';
X          }
X        cpos++;
X        }
X      if (bc_fragsizeok(minfrag,maxfrag,cpos - prevmat + 1))
X        (void) mrg_appndrgnelt(&lstend,prevmat,cpos,cpgcnt);
X      sqfl_clssqstrct(chsqfl);
X      if ((debuglevel > RBC_dbg_on) && (ostyle == MRG_out_rrgenomes))
X        {
X        fprintf(stdout,"'%.10s...'\n",seqsarr[chno-1]);
X        fflush(stdout);
X        }
X      rcnt++;
X      mrg_clrallregnelts(&cpglstp);
X      }
X    else
X      {
X      err_msg("Can't open chromosome file %s\n",sqfnam);
X      seqlens[chno-1] = 0;
X      }
X    }
Xmemfree(sqfnam);
Xreturn(rcnt);
X}
X
Xvoid mrg_putreducedrepseq(char *hdrstr,
X                          char *seqbuf,
X                          int chrlen,
X                          MRG_REGN_ELT *rrfragp,
X                          int chno,
X                          int minfrag,
X                          int maxfrag)
X/* use hdrstr to create a file name for thisp
Xchromosome, open as a Fasta output sequence
Xfile and write regions in rrfragp list there to. */
X{
Xchar *sqfnam;
Xint nblen;
XSQFL_STRCT *chsqfl;
Xint cpos;
XMRG_REGN_ELT *rrfp;
Xint rc;
Xint lcnt;
X
Xsqfnam = (char *) getmemory((nblen = strlen(hdrstr) + 16),"Sq dest file name buf");
Xsnprintf(sqfnam,nblen-1,"%s%s.fa",hdrstr,rbc_chrno2str((RBC_CHRNO) chno,1));
Xif ((chsqfl = sqfl_opnsqstrct(sqfnam,SFMT_fasta,"w")) != NULL)
X  {
X  rrfp = rrfragp;
X  fprintf(chsqfl->sfl,">%srr reduced repr %d..%d for MspI digest Chr%s %d/%dbp CpG: %d\n",
X            rbc_chrno2str((RBC_CHRNO) chno,1),minfrag,maxfrag,
X            rbc_chrno2str((RBC_CHRNO) chno,1),mrg_sumregnelts(rrfragp),chrlen,
X            mrg_sumcpgregnelts(rrfragp));
X  rc = lcnt = 0;
X  while (rrfp != NULL)
X    {
X    cpos = rrfp->rstart;
X    while (cpos <= rrfp->rstop)
X      {
X      sqfl_putres(chsqfl,*(seqbuf + cpos - 1),rc,&lcnt);
X      cpos++;
X      }
X    rrfp = rrfp->nxtregn;
X    }
X  sqfl_termsqfl(chsqfl,"",&lcnt);
X  sqfl_clssqstrct(chsqfl);
X  }
Xmemfree(sqfnam);
X}
X
Xvoid bc_commalst2ints(char *str,
X                      int *v1,
X                      int *v2)
X/* expect str to contain two base10 integers separated by a comma.
Xattempt to read these and return as v1 & v2.  zero return on
Xfailures */
X{
Xchar *ep;
Xchar *fp;
X
X*v1 = *v2 = 0;
X*v1 = (int) strtol(str,&ep,10);
Xif (ep != str)
X  *v2 = strtol(ep+1,&fp,10);
X}
X
Xint main(int argc,
X         char *argv[])
X{
Xint ap;
Xchar op;
XSQFL_STRCT *srcsq;
Xint ecnts;
Xint modcnt;
Xchar *chromoseq[ChrY + 1];   /* sequences of each chromosome */
Xint chrlens[ChrY + 1];       /* their lengths */
Xchar *genomsqhdrstr;         /* header string for genomic sequences */
Xchar *destsqhdrstr;          /* header string for destination seq files */
Xint chrcnt;
Xint minfrag;
Xint maxfrag;
XFS_FSMSTRCT *cpgfsmp;    /* ptr to CpG searching fsm */
Xint uchrno;
XRBC_CHRNO chrp;
XMRG_REGN_ELT *rrregions[ChrY + 1];
XMRG_REGN_ELT *rlstp;
X
Xdebuglevel = RBC_dbg_none;
Xostyle = MRG_out_rrgenomes;
Xmodcnt = ecnts = 0;
Xdestsqhdrstr = genomsqhdrstr = NULL;
Xminfrag = MRG_DEFMIN;
Xmaxfrag = MRG_DEFMAX;
Xcpgfsmp = NULL;
Xuchrno = 0;
Xfor (chrp = Chr1; chrp <= ChrY; chrp++)
X  {
X  chromoseq[chrp-1] = NULL;
X  chrlens[chrp-1] = 0;
X  rrregions[chrp-1] = NULL;  
X  }
Xfor (ap = 1; ap < argc; ap++)
X  if (*argv[ap] == '-')   /* an option */
X    switch (op = *(argv[ap]+1))
X      {
X      case 'c':   /* a chromosome */
X        if (++ap > argc)
X          err_msg_die("-%c needs a chromosome identifier (1..20,X,Y)\n",op);
X        else
X          if ((uchrno = rbc_str2chrno(argv[ap])) == Chr_unk)
X            err_msg_die("Can't determine Chromosome '%s'\n",argv[ap]);
X        break;
X      case 'g':
X        if (++ap > argc)
X          err_msg_die("-%c needs header string\n",op);
X        else
X          genomsqhdrstr = bas_strdup(argv[ap]);
X        break;
X      case 'G':
X        if (++ap > argc)
X          err_msg_die("-%c needs header string\n",op);
X        else
X          destsqhdrstr = bas_strdup(argv[ap]);
X        break;
X      case 'M':
X      case 'm':
X      case 'p':
X        switch (op)
X          {
X          case 'p':
X            ostyle = MRG_out_cpginrng;
X            break;
X          case 'm':
X            ostyle = MRG_out_rrlist;
X            break;
X          case 'M':
X          default:
X            ostyle = MRG_out_rrgenomes;
X            break;
X          }
X        if (++ap < argc)
X          if (*argv[ap] != '-')
X            bc_commalst2ints(argv[ap],&minfrag,&maxfrag);
X          else
X            ap--;
X        cpgfsmp = fs_initnewfsm(4,1,FS_inv_ignor);
X        fs_adddatprs(cpgfsmp,"CCGG","CCGG");
X        fs_adddatprs(cpgfsmp,"CG","CG");
X        (void) fs_bldfsm(cpgfsmp,WLU_CASEIND,0,0,tr_int2nares,fs_chkinpstr,fs_shed2lurec);
X        break;
X      case 'P':   /* all CpG list */
X        ostyle = MRG_out_allcpg;
X        cpgfsmp = fs_initnewfsm(4,1,FS_inv_ignor);
X        fs_adddatprs(cpgfsmp,"CG","CG");
X        (void) fs_bldfsm(cpgfsmp,WLU_CASEIND,0,0,tr_int2nares,fs_chkinpstr,fs_shed2lurec);
X        break;
X      case 'd':   /* debug on */
X        debuglevel = RBC_dbg_on;
X        break;
X      case 'D':   /* debug^2 on */
X        debuglevel = RBC_dbg_serious;
X        break;
X      case 'h':
X        say_usage(stdout,argv[0]);
X        exit(0);
X        break;
X      default:
X        err_msg("Unknown Option: '%s\n",argv[ap]);
X        say_usage(stderr,argv[0]);
X        exit(1);
X        break;
X      }
X/* should be ready to go now */
Xif ((genomsqhdrstr != NULL) && (cpgfsmp != NULL))
X  {
X  chrcnt = rbc_getnscangenomesqs(ostyle,genomsqhdrstr,cpgfsmp,&chromoseq[0],&chrlens[0],
X                                   &rrregions[0],(int) ChrY,uchrno,minfrag,maxfrag);
X  if (debuglevel > RBC_dbg_none)
X    fprintf(stdout,"%d chromosomes read\n",chrcnt);
X  for (chrp = Chr1; chrp <= ChrY; chrp++)
X    if ((uchrno == 0) || (uchrno == chrp))
X      {
X      rlstp = rrregions[chrp-1];
X      switch (ostyle)
X        {
X        case MRG_out_rrlist:
X          while (rlstp != NULL)
X            {
X            fprintf(stdout,"%s\t%d..%d (%d bp) CpG: %d\n",rbc_chrno2str(chrp,1),rlstp->rstart,
X                      rlstp->rstop,(rlstp->rstop - rlstp->rstart + 1),rlstp->cpgcnt);
X            rlstp = rlstp->nxtregn;
X            }
X          break;
X        case MRG_out_rrgenomes:
X          if (destsqhdrstr == NULL)
X            (void) err_msg_die("Need -G <destinationheader>\n");
X          else
X            mrg_putreducedrepseq(destsqhdrstr,chromoseq[chrp-1],chrlens[chrp-1],
X                                   rlstp,chrp,minfrag,maxfrag);
X          break;
X        default:
X          break;
X        }
X      }
X  }
Xelse
X  {
X  if (genomsqhdrstr == NULL)
X    (void) err_msg("No genome file header string (-g option) used\n");
X  if (cpgfsmp == NULL)
X    (void) err_msg("No fragment size range specified (-M or -m options)\n");
X  exit(1);
X  }
Xexit(0);
X}
END-of-meth_progs_dist/src/mkrrgenome.c
echo x - meth_progs_dist/src/mrg_fns.c
sed 's/^X//' >meth_progs_dist/src/mrg_fns.c << 'END-of-meth_progs_dist/src/mrg_fns.c'
X/* mrg_fns.c: some routines to support mkrrgenome and related
Xprograms */
X
X#include <stdlib.h>
X#include <string.h>
X#include <stdio.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "sqfl_fns.h"
X#include "sqmat_fns.h"
X#include "rmapbsbed2cpg.h"
X#include "mrg_fns.h"
X
XMRG_REGN_ELT *mrg_appndrgnelt(MRG_REGN_ELT **lstrt,
X                             int rgstart,
X                             int rgstop,
X                             int cpgs)
X/* create and append a new element to *lstrt,
X Return address of new element */
X{
XMRG_REGN_ELT *prev, *end_ptr;
X
Xif (lstrt != NULL)
X  {
X  prev = end_ptr = *lstrt;
X  while (end_ptr != NULL)
X    {
X    prev = end_ptr;
X    end_ptr = end_ptr->nxtregn;
X    }
X  end_ptr = (MRG_REGN_ELT *) getmemory(sizeof(MRG_REGN_ELT),"region elt");
X  end_ptr->nxtregn = NULL;
X  end_ptr->rstart = rgstart;
X  end_ptr->rstop = rgstop;
X  end_ptr->cpgcnt = cpgs;
X  if (*lstrt == NULL)
X    {
X    *lstrt = end_ptr;
X    end_ptr->prvregn = NULL;
X    }
X  else
X    {
X    prev->nxtregn = end_ptr;
X    end_ptr->prvregn = prev;
X    }
X  return(end_ptr);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid mrg_delregnelt(MRG_REGN_ELT *ep,
X                    MRG_REGN_ELT **lstrt)
X/* delete ep from list *lstrt */
X{
XMRG_REGN_ELT *pt;
X
Xif (ep != NULL)
X  {
X  if ((pt = ep->prvregn) == NULL)
X    *lstrt = ep->nxtregn;
X  else
X    pt->nxtregn = ep->nxtregn;
X  if ((pt = ep->nxtregn) != NULL)
X    pt->prvregn = ep->prvregn;
X  memfree(ep);
X  }
X}
X
Xvoid mrg_clrallregnelts(MRG_REGN_ELT **lstrt)
X  /* iteratively delete all of lstrt */
X{
Xwhile (*lstrt != NULL)
X  mrg_delregnelt(*lstrt,lstrt);
X}
X
Xint mrg_cntregnelts(MRG_REGN_ELT *clst)
X  /* recursively count list elements */
X{
Xif (clst == NULL)
X  return(0);
Xelse
X  return(mrg_cntregnelts(clst->nxtregn) + 1);
X}
X
Xint mrg_sumregnelts(MRG_REGN_ELT *rlst)
X  /* recursively sum lengths of elements */
X{
Xif (rlst == NULL)
X  return(0);
Xelse
X  return(mrg_sumregnelts(rlst->nxtregn) + rlst->rstop - rlst->rstart + 1);
X}
X
Xint mrg_sumcpgregnelts(MRG_REGN_ELT *rlst)
X  /* recursively ... */
X{
Xif (rlst == NULL)
X  return(0);
Xelse
X  return(mrg_sumcpgregnelts(rlst->nxtregn) + rlst->cpgcnt);
X}
X
XMRG_REGN_ELT *mrg_regnelt4pos(MRG_REGN_ELT *rlst,
X                            int pos)
X/* return the region element corresponding to pos, if any */
X{
XMRG_REGN_ELT *rp;
X
Xrp = rlst;
Xwhile (rp != NULL)
X  if (rbc_intinrng(rp->rstart,pos,rp->rstop))
X    return(rp);
X  else
X    rp = rp->nxtregn;
X/* fell off end, reurn NULL */
Xreturn(NULL);
X}
X
END-of-meth_progs_dist/src/mrg_fns.c
echo x - meth_progs_dist/src/mrg_fns.h
sed 's/^X//' >meth_progs_dist/src/mrg_fns.h << 'END-of-meth_progs_dist/src/mrg_fns.h'
Xtypedef struct MRG_regn_elt   /* for linked list of regions */
X  {
X  int rstart;                /* start this region */
X  int rstop;                 /* end this region (inclusive) */
X  int cpgcnt;                  /* count of CpGs this frag */
X  struct MRG_regn_elt *nxtregn; /* forward link */
X  struct MRG_regn_elt *prvregn; /* back link */
X  }
XMRG_REGN_ELT;
X
XMRG_REGN_ELT *mrg_appndrgnelt(MRG_REGN_ELT **lstrt,
X                             int rgstart,
X                             int rgstop,
X                             int cpgs);
X/* create and append a new element to *lstrt,
X Return address of new element */
X
Xvoid mrg_delregnelt(MRG_REGN_ELT *ep,
X                    MRG_REGN_ELT **lstrt);
X/* delete ep from list *lstrt */
X
Xvoid rbc_clrallregnelts(MRG_REGN_ELT **lstrt);
X  /* iteratively delete all of lstrt */
X
Xint mrg_cntregnelts(MRG_REGN_ELT *clst);
X  /* recursively count list elements */
X
Xint mrg_sumregnelts(MRG_REGN_ELT *rlst);
X  /* recursively sum lengths of elements */
X
Xint mrg_sumcpgregnelts(MRG_REGN_ELT *rlst);
X  /* recursively ... */
X
XMRG_REGN_ELT *mrg_regnelt4pos(MRG_REGN_ELT *rlst,
X			      int pos);
X/* return the region element corresponding to pos, if any */
END-of-meth_progs_dist/src/mrg_fns.h
echo x - meth_progs_dist/src/rbs_fns.c
sed 's/^X//' >meth_progs_dist/src/rbs_fns.c << 'END-of-meth_progs_dist/src/rbs_fns.c'
X/* rbs_fns.c: set of routines common to a number
Xof the bisulphite sequence programs: made into a 
Xseparate file to simplify maintenance
X
XPeter Stockwell 26-Sep-2010 */
X
X#include <stdlib.h>
X#include <string.h>
X#include <stdarg.h>
X#include <stdio.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "sqfl_fns.h"
X#include "sqmat_fns.h"
X#include "rmapbsbed2cpg.h"
X#include "rbs_fns.h"
X
Xchar *rbc_chrno2str(RBC_CHRNO cno,
X                    int terse)
X{
Xif (terse)
X  switch (cno)
X    {
X    case Chr1:
X      return("1");
X      break;
X    case Chr2:
X      return("2");
X      break;
X    case Chr3:
X      return("3");
X      break;
X    case Chr4:
X      return("4");
X      break;
X    case Chr5:
X      return("5");
X      break;
X    case Chr6:
X      return("6");
X      break;
X    case Chr7:
X      return("7");
X      break;
X    case Chr8:
X      return("8");
X      break;
X    case Chr9:
X      return("9");
X      break;
X    case Chr10:
X      return("10");
X      break;
X    case Chr11:
X      return("11");
X      break;
X    case Chr12:
X      return("12");
X      break;
X    case Chr13:
X      return("13");
X      break;
X    case Chr14:
X      return("14");
X      break;
X    case Chr15:
X      return("15");
X      break;
X    case Chr16:
X      return("16");
X      break;
X    case Chr17:
X      return("17");
X      break;
X    case Chr18:
X      return("18");
X      break;
X    case Chr19:
X      return("19");
X      break;
X    case Chr20:
X      return("20");
X      break;
X    case Chr21:
X      return("21");
X      break;
X    case Chr22:
X      return("22");
X      break;
X    case ChrX:
X      return("X");
X      break;
X    case ChrY:
X      return("Y");
X      break;
X    case Chr_unk:
X    default:
X      return("0");
X      break;
X    }
Xelse
X  switch (cno)
X    {
X    case Chr1:
X      return("Chr1");
X      break;
X    case Chr2:
X      return("Chr2");
X      break;
X    case Chr3:
X      return("Chr3");
X      break;
X    case Chr4:
X      return("Chr4");
X      break;
X    case Chr5:
X      return("Chr5");
X      break;
X    case Chr6:
X      return("Chr6");
X      break;
X    case Chr7:
X      return("Chr7");
X      break;
X    case Chr8:
X      return("Chr8");
X      break;
X    case Chr9:
X      return("Chr9");
X      break;
X    case Chr10:
X      return("Chr10");
X      break;
X    case Chr11:
X      return("Chr11");
X      break;
X    case Chr12:
X      return("Chr12");
X      break;
X    case Chr13:
X      return("Chr13");
X      break;
X    case Chr14:
X      return("Chr14");
X      break;
X    case Chr15:
X      return("Chr15");
X      break;
X    case Chr16:
X      return("Chr16");
X      break;
X    case Chr17:
X      return("Chr17");
X      break;
X    case Chr18:
X      return("Chr18");
X      break;
X    case Chr19:
X      return("Chr19");
X      break;
X    case Chr20:
X      return("Chr20");
X      break;
X    case Chr21:
X      return("Chr21");
X      break;
X    case Chr22:
X      return("Chr22");
X      break;
X    case ChrX:
X      return("ChrX");
X      break;
X    case ChrY:
X      return("ChrY");
X      break;
X    case Chr_unk:
X    default:
X      return("Chr??");
X      break;
X    }
X}
X
XRBC_CHRNO rbc_str2chrno(char *cstr)
X  /* return the most appropriate chromosome No for cstr */
X{
Xchar *ep;
Xint cno;
X
Xcno = (int) strtol(cstr,&ep,10);
Xif ((ep != cstr) && (cno != 0))
X  return((RBC_CHRNO) cno);
Xelse  /* couldn't read any of string as integer */
X  switch (toupper(*cstr))
X    {
X    case 'X':
X      return(ChrX);
X      break;
X    case 'Y':
X      return(ChrY);
X      break;
X    default:
X      return(Chr_unk);
X      break;
X    }
X}
X
Xint rbc_remaptileno(RBC_FLOWCELLVERSN fcv,
X                    int fastqtileno)
X/* remap flowcell V3 tiles to 1..24.  V2 just returns
Xthe value */
X{
Xint surface;  /* 1,2 */
Xint swath;  /* 1,2,3 */
Xint tdiv;
X
Xswitch (fcv)
X  {
X  case RBC_fcv_3_2:
X    surface = (int) fastqtileno/1000;
X    fastqtileno %= 1000;
X    swath = (int) fastqtileno/100;
X    tdiv = fastqtileno%100;
X    return(16*(surface-1)+8*(swath-1)+tdiv);
X    break;
X  case RBC_fcv_3_3:
X    surface = (int) fastqtileno/1000;
X    fastqtileno %= 1000;
X    swath = (int) fastqtileno/100;
X    tdiv = fastqtileno%100;
X    return(24*(surface-1)+8*(swath-1)+tdiv);
X    break;
X  case RBC_fcv_2:
X  default:
X    return(fastqtileno);
X    break;
X  }
X}
X
Xint rbc_intinrng(int b1,
X                 int i,
X                 int b2)
X/* 1 if b1 <= i <= b2 or b2 <= i <= b1 */
X{
Xif (b1 <= b2)
X  return((b1 <= i) && (i <= b2));
Xelse
X  return(rbc_intinrng(b2,i,b1));
X}
X
Xint rbc_modnwithn(int base,
X                  int i)
X/* return 1,2,...n, on a base of n */
X{
Xint rtv;
X
Xif (base <= 0)
X  return(0);
Xelse
X  if ((rtv = (i % base)) == 0)
X    return(base);
X  else
X    return(rtv);
X}
X
Xint rbc_invrtremaptileno(RBC_FLOWCELLVERSN fcv,
X                         int tno)
X/* tno is a tile number in range 1..120.  reverse the
Xremapping back to the original number.  Check that
Xtno is in appropriate range and return 0 if not */
X{
Xint surface;
Xint swath;
Xint wosurf;
X
Xswitch (fcv)
X  {
X  case RBC_fcv_3_2:
X    if (rbc_intinrng(1,tno,32))
X      {
X      surface = (int) (tno - 1)/(8*2);
X      wosurf = tno % 16;
X      swath = (int)(wosurf + 7)/8;
X      return(surface*1000 + swath*100 + rbc_modnwithn(8,tno));
X      }
X    else
X      return(0);
X    break;
X  case RBC_fcv_3_3:
X    if (rbc_intinrng(1,tno,48))
X      {
X      surface = (int) (tno - 1)/(8*3);
X      wosurf = tno % 24;
X      swath = (int)(wosurf + 7)/8;
X      return(surface*1000 + swath*100 + rbc_modnwithn(8,tno));
X      }
X    else
X      return(0);
X    break;
X  case RBC_fcv_2:
X  default:
X    if (rbc_intinrng(1,tno,MAXTILENO))
X      return(tno);
X    else
X      return(0);
X    break;
X  }
X}
X
Xint rbc_cntflds(char *buf,
X                char fldsep)
X/* scan buff for fldsep, return No of distinct fields
Xdelimited by fldsep.  Note that leading or terminal 
Xoccurrences are not considered */
X{
Xchar *bp;
Xint fcnt;
Xchar prv;
X
Xbp = buf;
Xprv = '\0';
Xif (*bp == fldsep)
X  fcnt = 0;
Xelse
X  fcnt = 1;
Xwhile ((prv = *bp) != '\0')
X  {
X  if (*bp == fldsep)
X    fcnt++;
X  bp++;
X  }
Xif (prv == fldsep)
X  fcnt--;
Xreturn(fcnt);
X}
X
Xchar *rbc_skiptofld(char *buf,
X                    char fldsep,
X                    int fldno)
X/* jump to field no fldno in buf, based on
Xoccurrences of fldsep.  return the point immediately
Xfollowing the preceding delimiter, so if two successive
Xdelimiters exist, the next will be found.
Xreturn NULL if the field doesn't exist */
X{
Xint fcnt;
Xchar *bp;
X
Xbp = buf;
Xif (*bp == fldsep)
X  bp++;
Xfcnt = 1;
Xwhile (*bp != '\0')
X  if (fcnt == fldno)
X    return(bp);
X  else
X    {
X    if (*bp == fldsep)
X      fcnt++;
X    bp++;
X    }
Xreturn(NULL);
X}
X
Xint rbc_hdrstr2tile(RBC_RUNPARS *rpp,
X                    char *hstr,
X                    int *xpx,
X                    int *ypx)
X/* decompose hstr to tile, xpixel,ypixel values and
Xreturn tile no if successful, else 0.  If xpx,ypx are non-NULL,
Xput the pixel positions to them. */
X{
Xint xp;
Xint yp;
Xint tno;
Xchar *sp;
Xchar *ep;
Xint lno;
Xint fldcnt;
X
Xswitch (rpp->readflform)
X  {
X  case RBC_readflfm_fasta:
X    sp = hstr;
X    if (*sp == '\0')    /* empty */
X      return(0);
X    else
X      {
X      if (*sp == '>')
X        sp++;
X      sp++;
X      lno = (int) strtol(sp,&ep,10);
X      if (ep == sp)
X        return(0);
X      else
X        {
X        sp = ep + 1;;
X        tno = (int) strtol(sp,&ep,10);
X        if (ep == sp)
X          return(0);
X        else
X          {
X          sp = ep + 1;
X          xp = (int) strtol(sp,&ep,10);
X          if (sp == ep)
X            return(0);
X          else
X            {
X            sp= ep + 1;
X            yp = (int) strtol(sp,&ep,10);
X            if (sp == ep)
X              return(0);
X            else
X              {
X              if (xpx != NULL)
X                *xpx = xp;
X              if (ypx != NULL)
X                *ypx = yp;
X              return(tno);
X              }
X            }
X          }
X        }
X      }
X    break;
X  case RBC_readflfm_fastq:
X    fldcnt = rbc_cntflds(hstr,':');
X    if ((sp = rbc_skiptofld(hstr,':',(fldcnt-2))) != NULL)
X      {
X      tno = (int) strtol(sp,&ep,10);
X      if (ep == sp)
X        return(0);
X      else
X        {
X        if ((sp = rbc_skiptofld(hstr,':',(fldcnt-1))) != NULL)
X          {
X          xp = (int) strtol(sp,&ep,10);
X          if (ep == sp)
X            return(0);
X          else
X            {
X            if (xpx != NULL)
X              *xpx = xp;
X            if ((sp = rbc_skiptofld(hstr,':',fldcnt)) != NULL)
X              {
X              yp = (int) strtol(sp,&ep,10);
X              if (ep == sp)
X                return(0);
X              else
X                {
X                if (ypx != NULL)
X                  *ypx = yp;
X                return(tno);
X                }
X              }
X            else
X              return(0);
X            }
X          }
X        else
X          return(0);
X        }
X      }
X    else
X      return(0);
X    break;
X  }         
X}
X
Xint rbc_readlntobuf(FILE *sfl,
X                    char *buf,
X                    int buflen)
X/* read chars from sfl up to end of line, if not '\0' or
XEOF, put into buf if it is not null up to buflen,
Xreturn no chars read */
X{
Xint nc;
Xchar *dp;
Xint rlen;
X
Xrlen = 0;
Xif ((dp = buf) != NULL)
X  *dp = '\0';
Xwhile (((nc = fgetc(sfl)) != (int) '\n') && (nc != EOF))
X  {
X  if ((buf != NULL) && (rlen < buflen))
X    {
X    *dp = (char) nc;
X    dp++;
X    *dp = '\0';
X    }
X  rlen++;
X  }
Xreturn(rlen);
X}
X
END-of-meth_progs_dist/src/rbs_fns.c
echo x - meth_progs_dist/src/rbs_fns.h
sed 's/^X//' >meth_progs_dist/src/rbs_fns.h << 'END-of-meth_progs_dist/src/rbs_fns.h'
X/* rbs_fns.h: function headers for bisulphite programs
Xcommon routines */
X
Xchar *rbc_chrno2str(RBC_CHRNO cno,
X                    int terse);
X
XRBC_CHRNO rbc_str2chrno(char *cstr);
X  /* return the most appropriate chromosome No for cstr */
X
Xint rbc_remaptileno(RBC_FLOWCELLVERSN fcv,
X                    int fastqtileno);
X/* remap flowcell V3 tiles to 1..24.  V2 just returns
Xthe value */
X
Xint rbc_intinrng(int b1,
X                 int i,
X                 int b2);
X/* 1 if b1 <= i <= b2 or b2 <= i <= b1 */
X
Xint rbc_modnwithn(int base,
X                  int i);
X/* return 1,2,...n, on a base of n */
X
Xint rbc_invrtremaptileno(RBC_FLOWCELLVERSN fcv,
X                         int tno);
X/* tno is a tile number in range 1..120.  reverse the
Xremapping back to the original number.  Check that
Xtno is in appropriate range and return 0 if not */
X
Xint rbc_cntflds(char *buf,
X                char fldsep);
X/* scan buff for fldsep, return No of distinct fields
Xdelimited by fldsep.  Note that leading or terminal 
Xoccurrences are not considered */
X
Xchar *rbc_skiptofld(char *buf,
X                    char fldsep,
X                    int fldno);
X/* jump to field no fldno in buf, based on
Xoccurrences of fldsep.  return the point immediately
Xfollowing the preceding delimiter, so if two successive
Xdelimiters exist, the next will be found.
Xreturn NULL if the field doesn't exist */
X
Xint rbc_hdrstr2tile(RBC_RUNPARS *rpp,
X                    char *hstr,
X                    int *xpx,
X                    int *ypx);
X/* decompose hstr to tile, xpixel,ypixel values and
Xreturn tile no if successful, else 0.  If xpx,ypx are non-NULL,
Xput the pixel positions to them. */
X
Xint rbc_readlntobuf(FILE *sfl,
X                    char *buf,
X                    int buflen);
X/* read chars from sfl up to end of line, if not '\0' or
XEOF, put into buf if it is not null up to buflen,
Xreturn no chars read */
END-of-meth_progs_dist/src/rbs_fns.h
echo x - meth_progs_dist/src/rmapbsbed2cpg.c
sed 's/^X//' >meth_progs_dist/src/rmapbsbed2cpg.c << 'END-of-meth_progs_dist/src/rmapbsbed2cpg.c'
X/* rmapbsbed2cpg: to take rmapbs output and generate a list of
X  individual CpG positions therefrom.
X
XProcess requires reading entire human genome, chromosome by chromosome
Xand complete reads (fasta & fastq format in PROG_VERSION 2.0).
XSo have linked list of reads, for each tile...
X
X*/
X
X#include <stdlib.h>
X#include <string.h>
X#include <stdarg.h>
X#include <stdio.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "sqfl_fns.h"
X#include "sqmat_fns.h"
X#include "rmapbsbed2cpg.h"
X#include "rbs_fns.h"
X#include "mrg_fns.h"
X
X/*#define PROG_VERSION 0.00 *//* Nov-2010 */
X/* corrected out-by-one errors rmapbs: 1-Apr-2011 */
X/* #define PROG_VERSION 1.0 */
X/* modify to support HiSeq V2 & V3 headers */
X/* #define PROG_VERSION 2.0 */
X/* corrections for bsmap out-by-1 and truncated read info: Oct-2011 */
X/* #define PROG_VERSION 2.1 */
X/* incorporate code to check read mapping positions wrt RR genome positions: Oct-2011 */
X/* #define PROG_VERSION 2.2 */
X/* Allow for bsmap v1.2 output */
X/* #define PROG_VERSION 2.3 */
X/* don't run with no chromosomes: Oct-2011 */
X#define PROG_VERSION 2.31
X
X/* global debug & out style variables, for simplicity of access */
XRBC_DBG debuglevel;
X
Xint err_msg(char *fmt,
X            ...)
X/* write user error message.  Return 0 for err return status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xreturn(0);
X}
X
Xvoid err_msg_die(char *fmt,
X                 ...)
X/* write user error message then exit with error status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xexit(1);
X}
X
Xvoid say_usage(FILE *fl,
X               char *pnam)
X{
Xfprintf(fl,"%s (v%.2f): generate list of CpG positions from rmapbs BED file\n",
X          pnam,PROG_VERSION);
Xfputs("Options:\n",fl);
Xfputs("     -r <readfile> reads from Fasta fmt. <readfile>\n",fl);
Xfputs("     -R <readfile> reads from fastq <readfile>\n",fl);
Xfputs("     -v HiSeq V3 flowcell, V2 chemistry (def V2 GAII flowcell)\n",fl);
Xfputs("     -V HiSeq V3 flowcell, V3 chemistry (def V2 GAII flowcell)\n",fl);
Xfputs("     -b <bedfile> read match information from <bedfile> (rmapbs bed format)\n",fl);
Xfputs("     -B <bsmapfile> read match information from <bsmapfile> (bsmap V1.02 output format)\n",fl);
Xfputs("     -A <bsmapfile> read match information from <bsmapfile> (bsmap V1.2 output format)\n",fl);
Xfputs("     -p <posfile> read RR sections (mkrrgenome -m output) from <posfile>, count hits/misses\n",fl);
Xfputs("     -g <genomehead> dir and file string to locate genomic seq files by adding n.fa\n",fl);
X}
X
XRBC_READ_ELT *rbc_appndelt(RBC_READ_ELT **lstrt,
X                           int xpx,
X                           int ypx,
X                           char *sq)
X/* create and append a new element to *lstrt,
Xthe seq is assumed to pre-exist and
Xis not created here. start, stop & sense values are
Xnot set here, merely initialised. Return address of
Xnew element */
X{
XRBC_READ_ELT *prev, *end_ptr;
X
Xif (lstrt != NULL)
X  {
X  prev = end_ptr = *lstrt;
X  while (end_ptr != NULL)
X    {
X    prev = end_ptr;
X    end_ptr = end_ptr->nxtrdelt;
X    }
X  end_ptr = (RBC_READ_ELT *) getmemory(sizeof(RBC_READ_ELT),"Read element");
X  end_ptr->nxtrdelt = NULL;
X  end_ptr->xpix = xpx;
X  end_ptr->ypix = ypx;
X  end_ptr->pstart = end_ptr->pstop = 0;
X  end_ptr->readfwd = 1;
X  end_ptr->chrno = Chr_unk;
X  end_ptr->readseq = sq;
X  if (*lstrt == NULL)
X    {
X    *lstrt = end_ptr;
X    end_ptr->prvrdelt = NULL;
X    }
X  else
X    {
X    prev->nxtrdelt = end_ptr;
X    end_ptr->prvrdelt = prev;
X    }
X  return(end_ptr);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid rbc_delrdelt(RBC_READ_ELT *ep,
X                  RBC_READ_ELT **lstrt,
X                  int clrseq)
X/* delete ep from list *lstrt, if
Xclrseq then free that storage also */
X{
XRBC_READ_ELT *pt;
X
Xif (ep != NULL)
X  {
X  if ((pt = ep->prvrdelt) == NULL)
X    *lstrt = ep->nxtrdelt;
X  else
X    pt->nxtrdelt = ep->nxtrdelt;
X  if ((pt = ep->nxtrdelt) != NULL)
X    pt->prvrdelt = ep->prvrdelt;
X  if (clrseq && (ep->readseq != NULL))
X    memfree(ep->readseq);
X  memfree(ep);
X  }
X}
X
Xvoid rbc_clrallrdelts(RBC_READ_ELT **lstrt,
X                      int clrseq)
X  /* iteratively delete all of lstrt */
X{
Xwhile (*lstrt != NULL)
X  rbc_delrdelt(*lstrt,lstrt,clrseq);
X}
X
Xint rbc_cntrdelts(RBC_READ_ELT *clst)
X  /* recursively read list elements */
X{
Xif (clst == NULL)
X  return(0);
Xelse
X  return(rbc_cntrdelts(clst->nxtrdelt) + 1);
X}
X
Xint rbc_cntmodrdelts(RBC_READ_ELT *clst)
X  /* recursively count modified read list elements */
X{
Xif (clst == NULL)
X  return(0);
Xelse
X  if ((clst->chrno != Chr_unk) && (clst->pstart > 0) &&
X       (clst->pstop > 0))
X    return(rbc_cntmodrdelts(clst->nxtrdelt) + 1);
X  else
X    return(rbc_cntmodrdelts(clst->nxtrdelt));
X}
X
XRBC_READ_ELT *cpg_lastelt(RBC_READ_ELT *clst)
X  /* iterate thru clst, returning
Xlast element, NULL if none */
X{
XRBC_READ_ELT *ep;
X
Xif ((ep = clst) == NULL)
X  return(NULL);
Xelse
X  {
X  while (ep->nxtrdelt != NULL)
X    ep = ep->nxtrdelt;
X  return(ep);
X  }
X}
X
XRBC_READ_ELT *rbc_elt4xypix(RBC_READ_ELT *rlst,
X                            int xp,
X                            int yp)
X/* iterate thru rlst, returning the first element which
Xmatches xp,yp */
X{
XRBC_READ_ELT *rp;
X
Xrp = rlst;
Xwhile (rp != NULL)
X  if ((rp->xpix == xp) && (rp->ypix == yp))
X    return(rp);
X  else
X    rp = rp->nxtrdelt;
Xreturn(NULL);
X}
X
Xint rbc_readfqread(FILE *sfl,
X                   char *hdrbuf,
X                   int hbuflen,
X                   char *sqbuf,
X                   char *qulbuf,
X                   int buflen)
X/* assume sfl is at start of @ header line, read the header then
Xget the sequence, returning its length.  Skip quality lines, leaving
Xsfl on next @ header.  Write header to hdrbuf, seq to sqbuf &
Xqual to qulbuf if nonNULL */
X{
Xint slen;
X
X(void) rbc_readlntobuf(sfl,hdrbuf,hbuflen);
Xslen = rbc_readlntobuf(sfl,sqbuf,buflen);
X(void) rbc_readlntobuf(sfl,NULL,0);
X(void) rbc_readlntobuf(sfl,qulbuf,buflen);
Xreturn(slen);
X}
X
Xint rbc_readnstorreads(RBC_RUNPARS *rpp,
X                       SQFL_STRCT *sqf,
X                       RBC_READ_ELT *rdlsts[])
X/* rdlsts is the address of an array of MAXTILENO 
Xindividual lists.  use the header line of sqf (fasta file,
Xalready open)
Xto add the new read to the appropriate tile list. scan
Xthe first 10 reads to check the read length, then
Xrewind the file and do the reads.
Xreturn the no of reads */
X{
Xchar *sqbuf;
Xint sno;
Xint tno;
Xint xpx;
Xint ypx;
Xint newlen;
XRBC_READ_ELT *rdlstends[MAXTILENO+1];
Xchar *hbuf;
X
Xrpp->srcreadlen = 0;
Xnewlen = 1;
Xfor (sno = 1; ((sno <= 10000) && (newlen > 0)); sno++)
X  switch (rpp->readflform)
X    {
X    case RBC_readflfm_fastq:
X      rpp->srcreadlen = imax((newlen = rbc_readfqread(sqf->sfl,NULL,0,NULL,NULL,0)),
X                              rpp->srcreadlen);
X      break;
X    case RBC_readflfm_fasta:
X    default:
X      rpp->srcreadlen = imax((newlen = readsrcsq(sqf,NULL)),rpp->srcreadlen);
X      break;
X    }
Xif (rpp->srcreadlen <= 0)
X  return(0);
Xelse
X  {
X  for (tno = 0; tno < MAXTILENO; tno++)
X    rdlstends[tno] = rdlsts[tno];
X  sqbuf = (char *) getmemory(rpp->srcreadlen+1,"Sq buffer");
X  sno = 0;
X  switch (rpp->readflform)
X    {
X    case RBC_readflfm_fastq:
X      rewind(sqf->sfl);
X      hbuf = (char *) getmemory(128,"fastq hdr buf");
X      while (rbc_readfqread(sqf->sfl,hbuf,128,sqbuf,NULL,rpp->srcreadlen) > 0)
X        if ((tno = rbc_remaptileno(rpp->fcversion,rbc_hdrstr2tile(rpp,hbuf,&xpx,&ypx))) > 0)
X          {
X          sno++;
X          rdlstends[tno-1] = rbc_appndelt(&rdlstends[tno-1],xpx,ypx,bas_strdup(sqbuf));
X          if (rdlsts[tno-1] == NULL)
X            rdlsts[tno-1] = rdlstends[tno-1];
X          }
X      break;
X    case RBC_readflfm_fasta:
X    default:
X      sqfl_rewind(sqf);
X      while ((newlen = readsrcsq(sqf,sqbuf)) > 0)
X        {
X        if ((tno = rbc_remaptileno(rpp->fcversion,rbc_hdrstr2tile(rpp,sqf->seqnam,&xpx,&ypx))) > 0)
X          {
X          sno++;
X          rdlstends[tno-1] = rbc_appndelt(&rdlstends[tno-1],xpx,ypx,bas_strdup(sqbuf));
X          if (rdlsts[tno-1] == NULL)
X            rdlsts[tno-1] = rdlstends[tno-1];
X          }
X        }
X      break;
X    }
X  return(sno);
X  }
X}
X
Xint rbc_readsrcfl(RBC_RUNPARS *rpp,
X                  RBC_READ_ELT *rdlsts[],
X                  FILE *sfl)
X/* use fscanf to read successive lines from sfl.
Xfor each, try to identify the header in rdlsts
Xand modify the values therein in accordance with
Xthe sfl read.
XNote: that bsmap may truncate reads, so need
Xto allow for variant positions/lengths for them.
XThis requires re-doing the read */
X{
Xchar chrstr[5];
Xint startpos;
Xint stoppos;
Xchar hdrstr[65];
Xint something;
Xchar sensestr[5];
Xint matcnt;
Xint tilno;
Xint xpx;
Xint ypx;
XRBC_READ_ELT *rep;
Xint scnt;
Xchar *readsq;
Xchar rqual[5];
Xint qval;
Xchar mmstr[129];
Xchar *posstr;
Xint readsqlen;
Xchar *qulstr;
Xchar *othersq;
Xint ival;
X
Xmatcnt = 0;
Xreadsq = NULL;
Xswitch (rpp->srcstyle)
X  {
X  case RBC_src_bsmap102:
X    readsq = (char *) getmemory(rpp->srcreadlen+1,"bsmap sq read");
X/* position string can be very long, esp for run of C's... */
X    posstr = (char *) getmemory((rpp->srcreadlen*10),"pos string");
X    while ((scnt = fscanf(sfl,"%s %s %s %s %d %s %d %s %s",&hdrstr[0],readsq,
X                            &rqual[0],&chrstr[0],&startpos,&sensestr[0],
X                            &qval,&mmstr[0],posstr)) != EOF)
X      if ((scnt == 9) &&
X           ((tilno = rbc_remaptileno(rpp->fcversion,rbc_hdrstr2tile(rpp,&hdrstr[0],&xpx,&ypx))) > 0)
X           && ((rep = rbc_elt4xypix(rdlsts[tilno-1],xpx,ypx)) != NULL))
X        {
X        rep->readfwd = sensestr[0] == '+';
X        rep->pstart = startpos;
X        readsqlen = strlen(readsq);
X        rep->pstop = startpos + readsqlen - 1;
X        rep->chrno = rbc_str2chrno(&chrstr[0]);
X        if (readsqlen != strlen(rep->readseq))
X          {
X          memfree(rep->readseq);
X          rep->readseq = bas_strdup(readsq);
X          }
X        matcnt++;
X        }
X    memfree(readsq);
X    memfree(posstr);
X    break;
X  case RBC_src_bsmap12:  /* has quality line included */
X    readsq = (char *) getmemory(rpp->srcreadlen+1,"bsmap sq read");
X/* position string can be very long, esp for run of C's... */
X    qulstr = (char *) getmemory(rpp->srcreadlen+1,"bsmap 1.2 qual");
X    othersq = (char *) getmemory(rpp->srcreadlen+1,"bsmap 1.2 ??");
X    while ((scnt = fscanf(sfl,"%s %s %s %s %s %d %s %d %s %d %s",&hdrstr[0],readsq,
X                            qulstr,&rqual[0],&chrstr[0],&startpos,&sensestr[0],
X                            &qval,othersq,&ival,&mmstr[0])) != EOF)
X      if ((scnt == 11) &&
X           ((tilno = rbc_remaptileno(rpp->fcversion,rbc_hdrstr2tile(rpp,&hdrstr[0],&xpx,&ypx))) > 0)
X           && ((rep = rbc_elt4xypix(rdlsts[tilno-1],xpx,ypx)) != NULL))
X        {
X        rep->readfwd = sensestr[0] == '+';
X        rep->pstart = startpos;
X        readsqlen = strlen(readsq);
X        rep->pstop = startpos + readsqlen - 1;
X        rep->chrno = rbc_str2chrno(&chrstr[0]);
X        if (readsqlen != strlen(rep->readseq))
X          {
X          memfree(rep->readseq);
X          rep->readseq = bas_strdup(readsq);
X          }
X        matcnt++;
X        }
X    memfree(readsq);
X    memfree(qulstr);
X    memfree(othersq);
X    break;
X  case RBC_src_rmapbs:
X  default:
X    bzero(&chrstr[0],5);
X    while ((scnt = fscanf(sfl,"%s %d %d %s %d %s",&chrstr[0],
X                            &startpos,&stoppos,&hdrstr[0],
X                            &something,&sensestr[0])) != EOF)
X      if ((scnt == 6) &&
X           ((tilno = rbc_remaptileno(rpp->fcversion,rbc_hdrstr2tile(rpp,&hdrstr[0],&xpx,&ypx))) > 0)
X           && ((rep = rbc_elt4xypix(rdlsts[tilno-1],xpx,ypx)) != NULL))
X        {
X        rep->pstart = startpos;
X        rep->pstop = stoppos;
X        rep->readfwd = sensestr[0] == '+';
X        rep->chrno = rbc_str2chrno(&chrstr[0]);
X        matcnt++;
X        }
X    break;
X  }
Xreturn(matcnt);
X}
X
Xint rbc_getgenomesqs(char *hdrstr,
X                     char *seqsarr[],
X                     int seqlens[],
X                     int chrmax)
X/* use hdrstr to create a series of file names, one
Xfor each chromosome, open each as a Fasta sequence
Xfile and create a buffer for each.  Return the
Xnumber of chromosomes processed */
X{
Xchar *sqfnam;
Xint chno;
Xint nblen;
XSQFL_STRCT *chsqfl;
Xint rcnt;
X
Xrcnt = 0;
Xsqfnam = (char *) getmemory((nblen = strlen(hdrstr) + 16),"Sq file name buf");
Xfor (chno = 1; chno <= chrmax; chno++)
X  {
X  snprintf(sqfnam,nblen-1,"%s%s.fa",hdrstr,rbc_chrno2str((RBC_CHRNO) chno,1));
X  if ((chsqfl = sqfl_opnsqstrct(sqfnam,SFMT_fasta,"r")) != NULL)
X    {
X    seqlens[chno-1] = readsrcsq(chsqfl,NULL);
X    if (debuglevel > RBC_dbg_on)
X      {
X      fprintf(stdout,"%s: %d res,",sqfnam,seqlens[chno-1]);
X      fflush(stdout);
X      }
X    seqsarr[chno-1] = (char *) getmemory(seqlens[chno-1]+1,"Chr Buff");
X    sqfl_rewind(chsqfl);
X    (void) readsrcsq(chsqfl,seqsarr[chno-1]);
X    sqfl_clssqstrct(chsqfl);
X    if (debuglevel > RBC_dbg_on)
X      {
X      fprintf(stdout,"'%.10s...'\n",seqsarr[chno-1]);
X      fflush(stdout);
X      }
X    rcnt++;
X    }
X  else
X    {
X    err_msg("Can't open chromosome file %s\n",sqfnam);
X    seqlens[chno-1] = 0;
X    }
X  }
Xreturn(rcnt);
X}
X
Xvoid rbc_rptchrout(FILE *ofl,
X                   char c,
X                   int ccnt)
X/* put c out ccnt times to ofl */
X{
Xwhile (ccnt-- > 0)
X  fputc(c,ofl);
X}
X
Xchar *rbc_rrreadform2str(RBC_RRREAD_FORM rrdfm)
X{
Xswitch (rrdfm)
X  {
X  case RBC_rrread_onjoin:
X    return("on join");
X    break;
X  case RBC_rrread_5p:
X    return("5' end");
X    break;
X  case RBC_rrread_3p:
X    return("3' end");
X    break;
X  case RBC_rrread_internal:
X    return("within RR fragment");
X    break;
X  case RBC_rrread_nomap:
X  default:
X    return("unmapped");
X    break;
X  }
X}
X
Xvoid rbc_prthdr4readelt(FILE *ofl,
X                        int lno,
X                        int tno,
X                        RBC_READ_ELT *rlp)
X/* generate a hdr type line at ofl for lane No lno, 
Xtileno tno & *rlp */
X{
Xif (rlp != NULL)
X  fprintf(ofl,"s%d_%d_%d_%d",lno,tno,rlp->xpix,rlp->ypix);
X}
X
Xint rbc_methmismatchcnt(char *readsq,
X                        char *genmsq,
X                        int slen)
X/* compare each residue in readsq with genmsq, returning
Xnumber of positions which mismatch, allowing for
XC->T conversions */
X{
Xchar *rp;
Xchar *gp;
Xchar rbas;
Xint mmcnt;
X
Xmmcnt = 0;
Xrp = readsq;
Xgp = genmsq;
Xwhile (slen > 0)
X  {
X  if (toupper(rbas = *rp) == 'T')
X    rbas = 'Y';
X  if (!ssd_basmatch(rbas,*gp,BAS_iub))
X    mmcnt++;
X  rp++;
X  gp++;
X  slen--;
X  }
Xreturn(mmcnt);
X}
X
Xvoid rbc_nprtstr(FILE *fl,
X                 char *str,
X                 int nchrs)
X/* put nchrs of str to fl,  any non-printable chars replaced by '*' */
X{
Xchar *sp;
X
Xsp = str;
Xwhile (nchrs > 0)
X  {
X  if (isprint(*sp))
X    fputc(*sp,fl);
X  else
X    fputc('*',fl);
X  sp++;
X  nchrs--;
X  }
X}
X
Xvoid rbc_chkbedvsgenomseq(RBC_RUNPARS *rpp,
X                          FILE *ofl,
X                          int tileno,
X                          RBC_READ_ELT *rdlst,
X                          char *chrseqs[],
X                          int chrlens[],
X                          int maxcno)
X/* taking each read that has valid, modified positions,
Xcompare the read & genomic sequence to find methylated
Xand unmethylated CpGs. */
X{
XRBC_READ_ELT *rlp;
Xint rdlen;
Xchar *lclchrbuf;
Xint lcblen;
Xchar tchar;
Xchar *lop;
Xchar *hip;
Xint chrcnt;
Xint bcnt;
Xint sqpos;
Xint mmcnt;
X
Xrlp = rdlst;
Xlcblen = 0;
Xlclchrbuf = NULL;
Xwhile (rlp != NULL)
X  {
X  if ((rlp->chrno != Chr_unk) && (rlp->pstart > 0)
X        && (rlp->pstop > 0))
X    {
X    rdlen = strlen(rlp->readseq);
X    if (rdlen > lcblen)
X      {
X      if (lclchrbuf != NULL)
X        memfree(lclchrbuf);
X      lclchrbuf = (char *) getmemory(rdlen + 2,"lcl chr sq buf");
X      lcblen = rdlen + 1;
X      }
X    if (debuglevel > RBC_dbg_on)
X      {
X      fprintf(ofl,"Chr%s: ",rbc_chrno2str(rlp->chrno,1));
X      rbc_prthdr4readelt(ofl,1,tileno,rlp);
X      fprintf(ofl,"\t%c\n",(rlp->readfwd?'+':'-'));
X      rbc_rptchrout(ofl,' ',13);
X      fprintf(ofl,"%.*s\n",rdlen,rlp->readseq);
X      if (rpp->srcstyle == RBC_src_rmapbs)
X        strncpy(lclchrbuf,(chrseqs[rlp->chrno-1] + rlp->pstart),rdlen);
X      else
X        strncpy(lclchrbuf,(chrseqs[rlp->chrno-1] + rlp->pstart - 1),rdlen);
X      if (!rlp->readfwd)
X        complmnt_seq(lclchrbuf,rdlen,BAS_exact);
X      bcnt = 13;
X      lop = rlp->readseq;
X      hip = lclchrbuf;
X      chrcnt = rdlen;
X      while (chrcnt-- > 0)
X        if (toupper(*lop++) == toupper(*hip++))
X          bcnt++;
X        else
X          {
X          rbc_rptchrout(ofl,' ',bcnt);
X          bcnt = 0;
X          fputc('*',ofl);
X          }
X      fputc('\n',ofl);
X      if (rlp->readfwd)
X        {
X        sqpos = rlp->pstart;
X        if (rpp->srcstyle == RBC_src_rmapbs)
X          fprintf(ofl,"%10d:  %.*s :%d\n",rlp->pstart,rdlen,lclchrbuf,
X                    (rlp->pstop-1));
X        else
X          fprintf(ofl,"%10d:  %.*s :%d\n",rlp->pstart,rdlen,lclchrbuf,
X                    rlp->pstop);
X        }
X      else
X        {
X        sqpos = rlp->pstop - 1;
X        if (rpp->srcstyle == RBC_src_rmapbs)
X          fprintf(ofl,"%10d:  %.*s :%d\n",(rlp->pstop-1),rdlen,lclchrbuf,
X                    rlp->pstart);
X        else
X          fprintf(ofl,"%10d:  %.*s :%d\n",rlp->pstop,rdlen,lclchrbuf,
X                    rlp->pstart);
X        }
X      lop = rlp->readseq;
X      hip = lclchrbuf;
X      chrcnt = rdlen;
X      while (chrcnt-- > 0)
X        {
X        if (toupper(*lop) != toupper(*hip))
X          fprintf(ofl,"%c%c\t%d\n",toupper(*hip),toupper(*lop),sqpos);
X        lop++;
X        hip++;
X        if (rlp->readfwd)
X          sqpos++;
X        else
X          sqpos--;
X        }
X      rbc_rptchrout(ofl,'-',10);
X      fputc('\n',ofl);
X      }
X    switch (rpp->ostyle)
X      {
X      case RBC_out_cpg:
X      default:
X        if (rpp->srcstyle == RBC_src_rmapbs) 
X          if (rlp->readfwd)
X            strncpy(lclchrbuf,(chrseqs[rlp->chrno-1] + rlp->pstart),rdlen+1);  /* need 1 more for CpG */
X          else
X            strncpy(lclchrbuf,(chrseqs[rlp->chrno-1] + rlp->pstart -1),rdlen+1);
X        else
X          strncpy(lclchrbuf,(chrseqs[rlp->chrno-1] + rlp->pstart - 1),rdlen+1);  /* need 1 more for CpG */
X       *(lclchrbuf + rdlen + 1) = '\0';
X       if (!rlp->readfwd)
X          {
X          lop = lclchrbuf;
X          hip = lclchrbuf + rdlen-1;
X          while (lop <= hip)
X            {
X            tchar = *lop;
X            *lop = ssd_bascmplmnt(*hip,BAS_exact);
X            *hip = ssd_bascmplmnt(tchar,BAS_exact);
X            lop++;
X            hip--;
X            }
X          }
X        lop = rlp->readseq;
X        hip = lclchrbuf;
X        chrcnt = rdlen;
X        if (rlp->readfwd)
X          sqpos = rlp->pstart + 1;
X        else
X          sqpos = rlp->pstop - 1;
X        if ((rpp->sqcheck >= 0) &&
X             ((mmcnt = rbc_methmismatchcnt(rlp->readseq,lclchrbuf,rdlen)) > rpp->sqcheck))
X          {
X          fprintf(stderr,"SQ/Read %d mismatch ",mmcnt);
X          rbc_prthdr4readelt(stderr,1,tileno,rlp);
X          fprintf(stderr," %s mapped Chr %s at %d..%d\n",(rlp->readfwd?"+":"-"),
X                    rbc_chrno2str(rlp->chrno,1),rlp->pstart,rlp->pstop);
X          rbc_nprtstr(stderr,rlp->readseq,rdlen);
X          fputc('\n',stderr);
X          rbc_nprtstr(stderr,lclchrbuf,rdlen);
X          fputc('\n',stderr);
X          fputs("------\n",stderr);
X          }
X        while ((chrcnt-- > 0) && (*hip != '\0'))
X          {
X          if ((toupper(*hip) == 'C') && (toupper(*(hip+1)) == 'G'))  /* is CpG */
X            {
X            fprintf(ofl,"%s\t",rbc_chrno2str(rlp->chrno,1));
X            if (debuglevel > RBC_dbg_none)
X              {
X              rbc_prthdr4readelt(ofl,1,tileno,rlp);
X              fputc('\t',ofl);
X              }
X            if (rpp->srcstyle== RBC_src_rmapbs)
X              fprintf(ofl,"%d\t%c\n",sqpos,((toupper(*lop)=='C')?'+':'-'));
X            else
X              if (rlp->readfwd)
X                fprintf(ofl,"%d\t%c\n",sqpos-1,((toupper(*lop)=='C')?'+':'-'));
X              else
X                fprintf(ofl,"%d\t%c\n",sqpos+1,((toupper(*lop)=='C')?'+':'-'));
X            }
X          lop++;
X          hip++;
X          if (rlp->readfwd)
X            sqpos++;
X          else
X            sqpos--;
X          }
X        break;
X      }
X    }
X  rlp = rlp->nxtrdelt;
X  }
X}
X
Xint rbc_readmkrrgenposns(FILE *pfl,
X                         MRG_REGN_ELT *rrposns[],
X                         RBC_CHRNO chrlimit)
X/* read a series of lines of form
XChrno\t<start>..<stop>\t(<len> bp) CpG: <cpgcnt>\n
Xfrom pfl, store relevant stuff in rrposns for appropriate
Xchromosome. return total No positions read */
X{
XMRG_REGN_ELT *rrposends[ChrY+1];
XRBC_CHRNO cno;
Xint scnt;
Xchar pbuf[33];
Xchar *scp;
Xchar dbuf1[17];
Xchar dbuf2[17];
Xchar dbuf3[5];
Xint cpgcnt;
Xchar chrstr[5];
X
Xscnt = 0;
Xfor (cno = Chr_unk; cno <= chrlimit; cno++)
X  rrposends[cno] = NULL;
Xwhile (fscanf(pfl,"%s\t%s %s %s %s %d",&chrstr[0],&pbuf[0],&dbuf1[0],
X                &dbuf2[0],&dbuf3[0],&cpgcnt) != EOF)
X  {
X  cno = rbc_str2chrno(&chrstr[0]);
X  scp = &pbuf[0];
X  while ((*scp != '.') && (*scp != '\0'))
X    scp++;
X  if ((scp - &pbuf[0]) < 30)
X    {
X    *scp = '\0';
X    scp +=2;
X    }
X  rrposends[cno] = mrg_appndrgnelt(&rrposns[cno],(int) strtol(&pbuf[0],NULL,10),
X                                     (int) strtol(scp,NULL,10),cpgcnt);
X  if (rrposns[cno] == NULL)
X    rrposns[cno] = rrposends[cno];
X  scnt++;
X  }
Xreturn(scnt);
X}
X
XRBC_RRREAD_FORM rbc_classfyreadvsrrbsfrag(RBC_READ_ELT *rdp,
X                                          MRG_REGN_ELT *rep)
X/* compare rdp with rep, return a read form value
Xfor it */
X{
Xif (rdp->pstart > rep->rstop)
X  return(RBC_rrread_is3pto);
Xelse
X  if (rdp->pstop < rep->rstart)
X    return(RBC_rrread_is5pto);
X  else
X    if (rdp->pstart == rep->rstart)
X      return(RBC_rrread_5p);
X    else
X      if ((rdp->readfwd && (rdp->pstop == rep->rstop)) ||
X        (!rdp->readfwd && (rdp->pstop == (rep->rstop+2))))  /* allow for C^CGG overhang */
X        return(RBC_rrread_3p);
X      else
X        if (rbc_intinrng(rep->rstart+1,rdp->pstart,rep->rstop-1) &&
X             rbc_intinrng(rep->rstart+1,rdp->pstop,rep->rstop-1))
X          return(RBC_rrread_internal);
X        else
X          if (rbc_intinrng(rdp->pstart+1,rep->rstart,rdp->pstop-1) ||
X               rbc_intinrng(rdp->pstart+1,rep->rstop,rdp->pstop-1))
X            return(RBC_rrread_onjoin);
X          else
X            return(RBC_rrread_nomap);
X}
X
Xvoid rbc_cmpmapposrrstrct(RBC_CHRNO maxchr,
X                          MRG_REGN_ELT *rrposlsts[],
X                          RBC_READ_ELT *rdlst,
X                          int rrrcnts[])
X/* scan rdlst and compare positions with rrposlsts
X(these assumed to be in increasing order for each
Xchromosome) and count status information into
Xrrrcnts[] */
X{
XMRG_REGN_ELT *rep;
XRBC_READ_ELT *rdlp;
XRBC_RRREAD_FORM rfm;
X
Xrdlp = rdlst;
Xwhile (rdlp != NULL)
X  {
X  if ((rdlp->chrno >= Chr_unk) && (rdlp->chrno <= maxchr))
X    {
X    rep = rrposlsts[rdlp->chrno];
X    while (rep != NULL)
X      switch (rfm = rbc_classfyreadvsrrbsfrag(rdlp,rep))
X        {
X        case RBC_rrread_5p:
X        case RBC_rrread_3p:
X        case RBC_rrread_internal:
X        case RBC_rrread_onjoin:
X          rrrcnts[rfm]++;
X          rep = NULL;
X          break;
X        case RBC_rrread_is3pto:
X          rep = rep->nxtregn;
X          break;
X        case RBC_rrread_nomap:
X        case RBC_rrread_is5pto: /* read is 5' to rrbs fragment, stop and note nomap */
X          rrrcnts[RBC_rrread_nomap]++;
X          rep = NULL;
X          break;
X      }
X    }
X  rdlp = rdlp->nxtrdelt;
X  }    
X}                          
X
Xint main(int argc,
X         char *argv[])
X{
Xint ap;
Xchar op;
XSQFL_STRCT *srcsq;
Xint ecnts;
Xint tilno;
XRBC_READ_ELT *rdlsts[MAXTILENO+1];
XFILE *srcfl;
Xint modcnt;
Xchar *chromoseq[ChrY + 1];   /* sequences of each chromosome */
Xint chrlens[ChrY + 1];       /* their lengths */
Xchar *genomsqhdrstr;         /* header string for genomic sequences */
Xint chrcnt;
XRBC_RUNPARS rpars;
XFILE *posfile;
XMRG_REGN_ELT *rrposns[ChrY+1];
XRBC_CHRNO cno;
Xint rrcnt;
XMRG_REGN_ELT *mrp;
Xint prvend;
Xint offst;
Xint rrmapcnts[RBC_rrread_onjoin + 1];
XRBC_RRREAD_FORM rrrdpt;
X
Xdebuglevel = RBC_dbg_none;
Xrpars.ostyle = RBC_out_cpg;
Xrpars.srcstyle = RBC_src_rmapbs;
Xrpars.sqcheck = -1;
Xrpars.chkrrmaps = 0;
Xrrcnt = modcnt = ecnts = 0;
Xsrcfl = posfile = NULL;
Xgenomsqhdrstr = NULL;
Xrpars.fcversion = RBC_fcv_2;
Xrpars.readflform = RBC_readflfm_fasta;
Xfor (ap = 1; ap < argc; ap++)
X  if (*argv[ap] == '-')   /* an option */
X    switch (op = *(argv[ap]+1))
X      {
X      case 'b':
X        if (++ap > argc)
X          err_msg_die("-%c needs file name\n",op);
X        else
X          if ((srcfl = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open .BED file %s\n",argv[ap]);
X        rpars.srcstyle = RBC_src_rmapbs;
X        break;
X      case 'B':  /* bsmap input */
X        if (++ap > argc)
X          err_msg_die("-%c needs file name\n",op);
X        else
X          if ((srcfl = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open bsmap file %s\n",argv[ap]);
X        rpars.srcstyle = RBC_src_bsmap102;
X        break;
X      case 'A':
X        if (++ap > argc)
X          err_msg_die("-%c needs file name\n",op);
X        else
X          if ((srcfl = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open bsmap file %s\n",argv[ap]);
X        rpars.srcstyle = RBC_src_bsmap12;
X        break;
X      case 'R':
X        rpars.readflform = RBC_readflfm_fastq;
X        if (++ap > argc)
X          err_msg_die("-%c needs name of fastq file\n",op);
X        else
X          if ((srcsq = sqfl_opnsqstrct(argv[ap],SFMT_raw,"r")) == NULL)
X            err_msg_die("Can't open fastq format read file '%s'\n",argv[ap]);
X        break;	  
X      case 'r':
X        if (++ap > argc)
X          err_msg_die("-%c needs name of fasta file\n",op);
X        else
X          if ((srcsq = sqfl_opnsqstrct(argv[ap],SFMT_fasta,"r")) == NULL)
X            err_msg_die("Can't open Fasta format read file '%s'\n",argv[ap]);
X        break;	  
X      case 'g':
X        if (++ap > argc)
X          err_msg_die("-%c needs header string\n",op);
X        else
X          genomsqhdrstr = bas_strdup(argv[ap]);
X        break;
X      case 'v':   /* V3 flowcell, V2 chemistry */
X        rpars.fcversion = RBC_fcv_3_2;
X        break;
X      case 'V':   /* V3 flowcell, V3 chemistry */
X        rpars.fcversion = RBC_fcv_3_3;
X        break;
X      case 'C':   /* enable read/chrom sq check: advise mismatches to stderr */
X        if (++ap > argc)
X          err_msg_die("-%c needs int value for mismatch check\n",op);
X        else
X          rpars.sqcheck = (int) atol(argv[ap]);
X        break;
X      case 'p': /* read a positionfile */
X        if (++ap > argc)
X          err_msg_die("-%c needs name of mkrrgenome position file\n",op);
X        else
X          if ((posfile = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open position file '%s'\n",argv[ap]);
X          else
X            rpars.chkrrmaps = 1;
X        break;	  
X      case 'd':   /* debug on */
X        debuglevel = RBC_dbg_on;
X        break;
X      case 'D':   /* debug^2 on */
X        debuglevel = RBC_dbg_serious;
X        break;
X      case 'h':
X        say_usage(stdout,argv[0]);
X        exit(0);
X        break;
X      default:
X        err_msg("Unknown Option: '%s\n",argv[ap]);
X        say_usage(stderr,argv[0]);
X        exit(1);
X        break;
X      }
X/* should be ready to go now */
Xif (genomsqhdrstr != NULL)
X  {
X  chrcnt = rbc_getgenomesqs(genomsqhdrstr,chromoseq,&chrlens[0],(int) ChrY);
X  if (debuglevel > RBC_dbg_none)
X    fprintf(stdout,"%d chromosomes read\n",chrcnt);
X  }
Xif (chrcnt <= 0)
X  {
X  err_msg("No chromosomes found with %s<n>\n",genomsqhdrstr);
X  exit(1);
X  }
Xif (rpars.chkrrmaps && (posfile != NULL))
X  {
X  for (cno = Chr_unk; cno <= ChrY; cno++)
X    rrposns[cno] = NULL;
X  rrcnt = rbc_readmkrrgenposns(posfile,&rrposns[Chr_unk],ChrY);
X  for (cno = Chr_unk; cno <= ChrY; cno++)
X    {
X    mrp = rrposns[cno];
X    prvend = 0;
X    while (mrp != NULL)
X      {
X      offst = mrp->rstart - prvend - 1;
X      prvend = (mrp->rstop -= offst);
X      mrp->rstart -= offst;
X/*      if (debuglevel > RBC_dbg_none)
X        fprintf(stdout,"%s: %d..%d\n",rbc_chrno2str(cno,0),mrp->rstart,mrp->rstop); */
X      mrp = mrp->nxtregn;
X      }
X    }
X  for (rrrdpt = RBC_rrread_nomap; rrrdpt <= RBC_rrread_onjoin; rrrdpt++)
X    rrmapcnts[rrrdpt] = 0;
X  }
Xif (srcsq != NULL)
X  {
X  for (tilno = 0; tilno < MAXTILENO; tilno++)
X    rdlsts[tilno] = NULL;
X  if (debuglevel > RBC_dbg_none)
X    fprintf(stdout,"Loading reads...\n");
X  if (((ecnts = rbc_readnstorreads(&rpars,srcsq,rdlsts)) > 0) &&
X       (srcfl != NULL))
X    {
X    if (debuglevel > RBC_dbg_none)
X      fprintf(stdout,"%d reads stored\n",ecnts);
X    modcnt = rbc_readsrcfl(&rpars,rdlsts,srcfl);
X    if (debuglevel > RBC_dbg_none)
X      fprintf(stdout,"%d rmapbs matches read\n",modcnt);
X    }
X  }
Xif ((ecnts > 0) && (debuglevel > RBC_dbg_none))
X  for (tilno = 0; tilno < MAXTILENO; tilno++)
X    fprintf(stdout,"Tile %d: %d/%d reads modified\n",tilno+1,
X             rbc_cntmodrdelts(rdlsts[tilno]),
X             rbc_cntrdelts(rdlsts[tilno]));
Xif ((ecnts > 0) && (modcnt > 0))
X  {
X  for (tilno = 0; tilno < MAXTILENO; tilno++)
X    {
X    rbc_chkbedvsgenomseq(&rpars,stdout,tilno,rdlsts[tilno],chromoseq,
X                           &chrlens[0],(int) ChrY);
X    if (rrcnt > 0)   /* compare read map positions with rr genome fragment positions */
X      rbc_cmpmapposrrstrct(ChrY,&rrposns[Chr_unk],rdlsts[tilno],&rrmapcnts[RBC_rrread_nomap]);
X    }
X  if (rrcnt > 0)
X    {
X    rbc_rptchrout(stdout,'#',10);
X    fputs(" RRBS fragment hits:\n",stdout);
X    for (rrrdpt = RBC_rrread_nomap; rrrdpt <= RBC_rrread_onjoin; rrrdpt++)
X      fprintf(stdout,"#\t%d\t %s\n",rrmapcnts[rrrdpt],rbc_rrreadform2str(rrrdpt));
X    rbc_rptchrout(stdout,'#',50);
X    fputc('\n',stdout);
X    }
X  }
Xexit(0);
X}
END-of-meth_progs_dist/src/rmapbsbed2cpg.c
echo x - meth_progs_dist/src/rmapbsbed2cpg.h
sed 's/^X//' >meth_progs_dist/src/rmapbsbed2cpg.h << 'END-of-meth_progs_dist/src/rmapbsbed2cpg.h'
X/* headers for rmapbsbed2cpg: generate list of CpG positions from rmapbs BED file */
X
Xtypedef enum RBC_flowcellversn
X  {
X  RBC_fcv_2 = 0,     /* GAII */
X  RBC_fcv_3_3,       /* HiSeq V3 chemistry */
X  RBC_fcv_3_2        /* HiSeq V2 chemistry */
X  }
XRBC_FLOWCELLVERSN;
X
Xtypedef enum RBC_readflform
X  {
X  RBC_readflfm_fasta = 0, /* header is >s<laneno>_<tileno>_<xpixel>_<ypixel> */
X  RBC_readflfm_fastq      /* header is @...:<laneno>:<tileno>:<xpixel>:<ypixe> where ... may contain ':' */
X  }
XRBC_READFLFORM;
X
X#define MAXTILENO 120
X
Xtypedef enum RBC_Chrno
X  {
X  Chr_unk = 0,
X  Chr1,
X  Chr2,
X  Chr3,
X  Chr4,
X  Chr5,
X  Chr6,
X  Chr7,
X  Chr8,
X  Chr9,
X  Chr10,
X  Chr11,
X  Chr12,
X  Chr13,
X  Chr14,
X  Chr15,
X  Chr16,
X  Chr17,
X  Chr18,
X  Chr19,
X  Chr20,
X  Chr21,
X  Chr22,
X  ChrX,
X  ChrY
X  }
XRBC_CHRNO;
X
Xtypedef struct RBC_read_elt   /* element containing read info */
X  {
X  int xpix;                   /* x,y pixel positions on tile */
X  int ypix;
X  RBC_CHRNO chrno;            /* chromosome No. */
X  int pstart;                 /* start/stop positions from .BED */
X  int pstop;
X  int readfwd;                /* 1=> forward read, 0=> reverse */
X  char *readseq;              /* this read seq */
X  struct RBC_read_elt *nxtrdelt;
X  struct RBC_read_elt *prvrdelt;
X  }
XRBC_READ_ELT;
X
Xtypedef enum RBC_dbg     /* verbosity level */
X  {
X  RBC_dbg_none = 0,
X  RBC_dbg_on,
X  RBC_dbg_serious
X  }
XRBC_DBG;
X
Xtypedef enum RBC_out_style
X  {
X  RBC_out_cpg = 0
X  }
XRBC_OUT_STYLE;
X
Xtypedef enum RBC_src_style
X  {
X  RBC_src_rmapbs = 0,
X  RBC_src_bsmap102,     /* v1.02 or earlier? bsmap */
X  RBC_src_bsmap12       /* v1.2 bsmap */
X  }
XRBC_SRC_STYLE;
X
Xtypedef enum RBC_rrread_form  /* to enumerate rr read maps */
X  {
X  RBC_rrread_nomap = 0,
X  RBC_rrread_5p,             /* maps at 5' end of read */
X  RBC_rrread_3p,             /* ditto   3' */
X  RBC_rrread_internal,       /* maps in middle of rrbs fragment */
X  RBC_rrread_onjoin,         /* maps over rrbs fragment join */
X  RBC_rrread_is5pto,         /* read is 5' to rrbs fragment */
X  RBC_rrread_is3pto          /* read is 3' to rrbs fragment */
X  }
XRBC_RRREAD_FORM;
X
Xtypedef struct RBC_runpars
X  {
X  RBC_FLOWCELLVERSN fcversion;
X  RBC_READFLFORM readflform;
X  RBC_OUT_STYLE ostyle;
X  RBC_SRC_STYLE srcstyle;
X  int srcreadlen;          /* max read length of source file seqs/qualities */
X  int sqcheck;   /* if >=zero check agreement between read & chr location, advising stderr of issues */
X  int chkrrmaps; /* check mapped reads wrt RR splice boundaries, append to output */
X  }
XRBC_RUNPARS;
END-of-meth_progs_dist/src/rmapbsbed2cpg.h
echo x - meth_progs_dist/src/scan_cpg_depth.c
sed 's/^X//' >meth_progs_dist/src/scan_cpg_depth.c << 'END-of-meth_progs_dist/src/scan_cpg_depth.c'
X/* scan_cpg_depth: take appropriately-formatted input files
X(chrno, position, strand/status where strand/status = '+' or '-')
Xand count the number of +/- hits on each CpG for all or selected
Xchromosomes */
X
X#include <stdlib.h>
X#include <string.h>
X#include <stdarg.h>
X#include <stdio.h>
X#include <math.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "sqfl_fns.h"
X#include "sqmat_fns.h"
X#include "rmapbsbed2cpg.h"
X#include "rbs_fns.h"
X#include "fsm_ops.h"
X
X/* local defines */
X/* the length of sequence for each linked list cluster */
X#define CHR_CLUSTER_DEF 1000
X
Xtypedef struct SCD_cpgelt  /* element in linked list of CpGs */
X  {
X  int cpgpos;              /* position this CpG */
X  int metcnt;              /* count methylated CpGs */
X  int unmetcnt;            /* count unmethylated */
X  struct SCD_cpgelt *nxtcpgelt;    /* forward link */
X  struct SCD_cpgelt *prvcpgelt;    /* rev link */
X  }
XSCD_CPGELT;
X
Xtypedef enum SCD_datum     /* different things we can return for SCD_CPGEELT list */
X  {
X  SCD_datm_count,
X  SCD_datm_maxpos,
X  SCD_datm_metcnt,
X  SCD_datm_unmetcnt,
X  SCD_datm_totcnt,
X  SCD_datm_maxmetcnt,
X  SCD_datm_maxunmetcnt,
X  SCD_datm_maxtotcnt,
X  SCD_datm_metunmetcpgpos,
X  SCD_datm_metcpgpos,
X  SCD_datm_unmetcpgpos
X  }
XSCD_DATUM;
X
X/* global debug & out style variables, for simplicity of access */
XRBC_DBG debuglevel;
Xint allowoutby1;   /* set in order to accept out-by-one positions */
X
Xint err_msg(char *fmt,
X            ...)
X/* write user error message.  Return 0 for err return status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xreturn(0);
X}
X
Xvoid err_msg_die(char *fmt,
X                 ...)
X/* write user error message then exit with error status */
X{
Xva_list args;
X
Xva_start(args,fmt);
X(void) vfprintf(stderr,fmt,args);
Xva_end(args);
Xexit(1);
X}
X
Xvoid say_usage(FILE *fl,
X               char *pnam)
X{
Xfprintf(fl,"%s: scan for CpG read depth for all or selected chromosomes\n",pnam);
Xfputs("Options:\n",fl);
Xfputs("     -r <posfile> read <posfile> as set of chr posit strand/meth\n",fl);
Xfputs("     -g <genomehead> dir and file string to locate genomic seq files by adding n.fa\n",fl);
Xfprintf(fl,"     -C <m> use cluster size of <m> for chromosome positions, Def=%d\n",CHR_CLUSTER_DEF);
Xfputs("     -l list each CpG to stdout with counts\n",fl);
Xfputs("     -c <n> restrict to Chromosome <n> 1..22,X,Y. Def=all\n",fl);
Xfputs("     -p Permit out-by-one positions (e.g. Bismark complementary strand CpGs) def=don't\n",fl);
Xfputs("     -S generate statistics (range, mean, std deviation, etc. for counts\n",fl);
Xfputs("     -H generate histogram of counts\n",fl);
Xfputs("     -m list missed CpG lines\n",fl);
Xfputs("     -n list CpG hits (Nonmisses)\n",fl);
Xfputs("     -z omit zero count from histogram\n",fl);
X}
X
XSCD_CPGELT *scd_appndcpgelt(SCD_CPGELT **lstrt,
X                            int cposn)
X/* create and append a new element to *lstrt,
Xinit counts to 0 & set position
XReturn address of new element */
X{
XSCD_CPGELT *prev, *end_ptr;
X
Xif (lstrt != NULL)
X  {
X  prev = end_ptr = *lstrt;
X  while (end_ptr != NULL)
X    {
X    prev = end_ptr;
X    end_ptr = end_ptr->nxtcpgelt;
X    }
X  end_ptr = (SCD_CPGELT *) getmemory(sizeof(SCD_CPGELT),"CpG elt");
X  end_ptr->nxtcpgelt = NULL;
X  end_ptr->cpgpos = cposn;
X  end_ptr->metcnt = end_ptr->unmetcnt = 0;
X  if (*lstrt == NULL)
X    {
X    *lstrt = end_ptr;
X    end_ptr->prvcpgelt = NULL;
X    }
X  else
X    {
X    prev->nxtcpgelt = end_ptr;
X    end_ptr->prvcpgelt = prev;
X    }
X  return(end_ptr);
X  }
Xelse
X  return(NULL);
X}
X
Xvoid scd_delcpgelt(SCD_CPGELT *ep,
X                   SCD_CPGELT **lstrt)
X/* delete ep from list *lstrt */
X{
XSCD_CPGELT *pt;
X
Xif (ep != NULL)
X  {
X  if ((pt = ep->prvcpgelt) == NULL)
X    *lstrt = ep->nxtcpgelt;
X  else
X    pt->nxtcpgelt = ep->nxtcpgelt;
X  if ((pt = ep->nxtcpgelt) != NULL)
X    pt->prvcpgelt = ep->prvcpgelt;
X  memfree(ep);
X  }
X}
X
Xvoid scd_clrallcntbins(SCD_CPGELT **lstrt)
X  /* iteratively delete all of lstrt */
X{
Xwhile (*lstrt != NULL)
X  scd_delcpgelt(*lstrt,lstrt);
X}
X
Xint scd_iterlstscan(SCD_CPGELT *clst,
X                    SCD_DATUM datm)
X/* iteratively traverse list clst, returning the appropriate
Xcount/total */
X{
Xint retval;
XSCD_CPGELT *lp;
X
Xretval = 0;
Xlp = clst;
Xwhile (lp != NULL)
X  {
X  switch (datm)
X    {
X    case SCD_datm_count:
X      retval++;
X      break;
X    case SCD_datm_maxpos:
X      retval = imax(retval,lp->cpgpos);
X      break;
X    case SCD_datm_metcnt:
X      retval += lp->metcnt;
X      break;
X    case SCD_datm_unmetcnt:
X      retval += lp->unmetcnt;
X      break;
X    case SCD_datm_totcnt:
X      retval += lp->metcnt + lp->unmetcnt;
X      break;
X    case SCD_datm_maxmetcnt:
X      retval = imax(retval,lp->metcnt);
X      break;
X    case SCD_datm_maxunmetcnt:
X      retval = imax(retval,lp->unmetcnt);
X      break;
X    case SCD_datm_maxtotcnt:
X      retval = imax(retval,(lp->metcnt+lp->unmetcnt));
X      break;
X    case SCD_datm_metunmetcpgpos:
X      retval++;
X      break;
X    case SCD_datm_metcpgpos:
X      if (lp->metcnt > 0)
X        retval++;
X      break;
X    case SCD_datm_unmetcpgpos:
X      if (lp->unmetcnt > 0)
X        retval++;
X      break;
X    default:
X      break;
X    }
X  lp = lp->nxtcpgelt;
X  }
Xreturn(retval);
X}
X
Xint scd_datm4allchr(SCD_CPGELT *chrcpglsts[],
X                    RBC_CHRNO mxchr,
X                    SCD_DATUM datm)
X/* sum datum test to all chromosomes to mxchr */
X{
XRBC_CHRNO chno;
Xint retval;
X
Xretval = 0;
Xfor (chno = Chr1; chno <= mxchr; chno++)
X  retval += scd_iterlstscan(chrcpglsts[chno-1],datm);
Xreturn(retval);
X}
X
Xint scd_cntcpgelts(SCD_CPGELT *clst)
X  /* recursively read list elements */
X{
Xreturn(scd_iterlstscan(clst,SCD_datm_count));
X}
X
XSCD_CPGELT *scd_lastcpgelt(SCD_CPGELT *clst)
X  /* iterate thru clst, returning
Xlast element, NULL if none */
X{
XSCD_CPGELT *ep;
X
Xif ((ep = clst) == NULL)
X  return(NULL);
Xelse
X  {
X  while (ep->nxtcpgelt != NULL)
X    ep = ep->nxtcpgelt;
X  return(ep);
X  }
X}
X
Xint int_in_rng(int b1,
X               int x,
X               int b2)
X/* return 1 if b1 <= x <= b2 or
Xb2 <= x <= b1 */
X{
Xif (b1 <= b2)
X  return((b1 <= x) && (x <= b2));
Xelse
X  return(int_in_rng(b2,x,b1));
X}
X
XSCD_CPGELT *scd_cpgelt4pos(SCD_CPGELT *blst,
X                           int posn)
X/* return a pointer to the bin that contains posn.
XOnly looks on blst, doesn't attempt to look more widely.
XNULL if none */
X{
XSCD_CPGELT *bp;
X
Xbp = blst;
Xwhile (bp != NULL)
X  if ((bp->cpgpos == posn) || (allowoutby1 && (abs(bp->cpgpos-posn) == 1)))
X    return(bp);
X  else
X    bp = bp->nxtcpgelt;
X/* fell off end, return NULL */
Xreturn(NULL);
X}
X
Xint scd_pos2luindex(int clstrsiz,
X                    int spos,
X                    int widenby1)
X/* return a lookup list index for spos */
X{
Xif (clstrsiz != 0)
X  {
X  if (widenby1)
X    spos = imax(1,spos-1);
X  if ((spos % clstrsiz) == 0)
X    return(imax(1,((int)( spos/clstrsiz) - 1)));
X  else
X    return((int) spos/clstrsiz);
X  }
Xelse
X  return(0);
X}
X
XSCD_CPGELT **scd_mklookuplst(SCD_CPGELT *cpgelst,
X                            int clstrsiz)
X/* examine max position in cpgeltlst and
Xreturn a lookup list based on clstrsize to
Xfind entry positions fast.  It is assumed here that
Xcpgelst is in ascending order of position */
X{
Xint maxpos;
Xint ecnt;
XSCD_CPGELT **lulst;
XSCD_CPGELT *clp;
Xint luarrp;
X
Xif (clstrsiz == 0)
X  return(NULL);
Xelse
X  {
X  maxpos = scd_iterlstscan(cpgelst,SCD_datm_maxpos);
X  ecnt = 1 + scd_pos2luindex(clstrsiz,maxpos,0);
X  lulst = (SCD_CPGELT **) getmemory(ecnt*sizeof(SCD_CPGELT*),"List Lookup Array");
X  for (luarrp = 0; luarrp < ecnt; luarrp++)
X    *(lulst + luarrp) = NULL;
X  clp = cpgelst;
X  while (clp != NULL)
X    {
X    luarrp = scd_pos2luindex(clstrsiz,clp->cpgpos,0);
X    if (*(lulst + luarrp) == NULL)    /* haven't seen this one yet */
X      *(lulst + luarrp) = clp;
X    clp = clp->nxtcpgelt;
X    }
X  return(lulst);
X  }
X}
X
XSCD_CPGELT *scd_pos2cpgelt(int chrlen,
X                           SCD_CPGELT **clulist,
X                           int clstrsiz,
X                           int posn)
X/* cpgeltlst is an array of cpgelt pointers, one
Xfor each clstrsize positions in chrlen.  look
Xup the appropriate cpg position and return a pointer to
Xthe element for that position if it exists. NULL otherwise */
X{
XSCD_CPGELT *strtp;
Xint clstrno;
X
Xif ((posn <= chrlen) && (clstrsiz > 0))
X  {
X  strtp = *(clulist + (clstrno = scd_pos2luindex(clstrsiz,posn,allowoutby1)));
X  while (strtp != NULL)
X    if ((strtp->cpgpos == posn) ||
X          (allowoutby1 && (abs(strtp->cpgpos-posn) == 1)))
X      return(strtp);
X    else
X      if (strtp->cpgpos > posn+1) /* missed it, stop */
X        return(NULL);
X      else
X        strtp = strtp->nxtcpgelt;
X  return(NULL);
X  }
Xelse
X  return(NULL);
X}
X
Xint scd_readsrcfl(SCD_CPGELT *celsts[],
X                  int chrlens[],
X                  SCD_CPGELT **clulists[],
X                  RBC_CHRNO mxchr,
X                  int clstrsiz,
X                  FILE *sfl,
X                  RBC_CHRNO uchrno,
X                  int *miscnt,
X                  FILE *misfl,
X                  FILE *hitfl)
X/* use fscanf to read successive lines from sfl.
XIf uchrno is nonzero, then only do that chromosome.
X
Xif miscnt is non-NULL then return to it the number of
Xmissed counts */
X{
Xchar chrstr[5];
Xint sqpos;
Xchar sensestr[5];
Xint matcnt;
Xint chrno;
Xint scnt;
XSCD_CPGELT *bp;
X
Xmatcnt = 0;
Xif (miscnt != NULL)
X  *miscnt = 0;
Xwhile ((scnt = fscanf(sfl,"%s %d %s",&chrstr[0],&sqpos,&sensestr[0])) != EOF)
X  if ((scnt == 3) && ((chrno = rbc_str2chrno(&chrstr[0])) > Chr_unk) &&
X        (chrno <= mxchr) && ((uchrno == 0) || (chrno == uchrno)))
X    {
X    if ((bp = scd_pos2cpgelt(chrlens[chrno-1],clulists[chrno-1],clstrsiz,sqpos)) != NULL)
X      {
X      if (sensestr[0] == '+')
X        bp->metcnt++;
X      else
X        bp->unmetcnt++;
X      matcnt++;
X      if (hitfl != NULL)  /* tell it about this hit */
X        fprintf(hitfl,"Hit: C%s\t%d\t%c\n",rbc_chrno2str(chrno,1),sqpos,sensestr[0]);
X      }
X    else
X      {
X      if (miscnt != NULL)
X        *miscnt += 1;
X      if (misfl != NULL)
X        fprintf(misfl,"Missed: C%s\t%d\t%c\n",rbc_chrno2str(chrno,1),sqpos,sensestr[0]);
X      }
X    }
Xreturn(matcnt);
X}
X
Xint scd_chknreadsrcfl(SCD_CPGELT *celsts[],
X                      int chrlens[],
X                      SCD_CPGELT **clulists[],
X                      RBC_CHRNO mxchr,
X                      int clstrsiz,
X                      FILE *sfl,
X                      RBC_CHRNO uchrno,
X                      int *miscnt,
X                      FILE *misfl,
X                      FILE *hitfl)
X/* check sfl for openness, then call bc_readsrcfl, returning number
Xelements read */
X{
Xif (sfl == NULL) /* can't do anything */
X  return(0);
Xelse
X  return(scd_readsrcfl(celsts,chrlens,clulists,mxchr,clstrsiz,sfl,uchrno,miscnt,misfl,hitfl));
X}
X
Xchar tr_int2nares(int iv)
X  /* return a nucleic acid residue for iv */
X{
Xswitch (iv)
X  {
X  case 0:
X    return('a');
X    break;
X  case 1:
X    return('c');
X    break;
X  case 2:
X    return('g');
X    break;
X  case 3:
X    return('t');
X    break;
X  default:
X    return('?');
X    break;
X  }
X}
X
Xint tr_nares2int(char res)
X  /* return an int value 0..3 for res, -1 for unknown */
X{
Xswitch (toupper(res))
X  {
X  case 'A':
X    return(0);
X    break;
X  case 'C':
X    return(1);
X    break;
X  case 'G':
X    return(2);
X    break;
X  case 'T':
X  case 'U':
X    return(3);
X    break;
X  default:
X    return(-1);
X    break;
X  }
X}
X
Xint scd_scangenomesqs(char *hdrstr,
X                      int chrmax,
X                      RBC_CHRNO uchrno,
X                      FS_FSMSTRCT *cpgfsmp,
X                      int clstrsiz,
X                      SCD_CPGELT *chrcpglsts[],
X                      int chrlens[])
X/* use hdrstr to create a series of file names, one
Xfor each chromosome, open each as a Fasta sequence
Xfile and create a buffer for each.  Return the
Xnumber of chromosomes processed.  Generate cpglsts for each
Xchromosome scanned, adding observed CpG positions thereto */
X{
Xchar *sqfnam;
Xint chno;
Xint nblen;
XSQFL_STRCT *chsqfl;
Xint rcnt;
Xchar nxtres;
Xint cpos;
XFS_RESELT *frp;
XFS_DATPRELT *dpep;
Xint clstlen;
Xint clstp;
XSCD_CPGELT *clstep;
Xint hitpos;
Xint clstrno;
Xint slen;
Xint hcnt;
X
Xrcnt = 0;
Xsqfnam = (char *) getmemory((nblen = strlen(hdrstr) + 16),"Sq file name buf");
Xfor (chno = 1; chno <= chrmax; chno++)
X  if ((uchrno == 0) || (uchrno == chno))
X    {
X    snprintf(sqfnam,nblen-1,"%s%s.fa",hdrstr,rbc_chrno2str((RBC_CHRNO) chno,1));
X    if ((chsqfl = sqfl_opnsqstrct(sqfnam,SFMT_fasta,"r")) != NULL)
X      {
X      chrlens[chno-1] = slen = readsrcsq(chsqfl,NULL);
X      clstlen = (int) chrlens[chno-1]/clstrsiz + 1,
X/*      *chrcpglsts[chno-1] = (SCD_CPGELT *) getmemory(sizeof(SCD_CPGELT*)*clstlen,
X                                              "Chr cluster list");
X      *clstep = (SCD_CPGELT *) getmemory(sizeof(SCD_CPGELT*)*clstlen,
X                                              "Chr cluster list ends");
X      for (clstp = 0; clstp < clstlen; clstp++)
X        {
X        *(clstep + clstp) = NULL;
X        *(chrcpglsts[chno-1]+clstp) = NULL;
X        } */
X      sqfl_rewind(chsqfl);
X      (void) sqfl_skipsqflhdr(chsqfl);
X      fs_initrun(cpgfsmp);
X      cpos = 0;
X      hcnt = 0;
X      clstep = NULL;
X      while ((nxtres = sqfl_getnxtres(chsqfl)) != '\0')
X        {
X        cpos++;
X        if ((frp = fs_procchr(cpgfsmp,nxtres,tr_nares2int)) != NULL)
X          {
X          dpep = (FS_DATPRELT *) frp->action;
X          hitpos = cpos - dpep->ldstr + 1;
X/*          clstrno = (int) hitpos/clstrsiz;
X          *(clstep+clstrno) = scd_appndcpgelt(&*(clstep+clstrno),hitpos);
X          if (*(chrcpglsts[chno-1] + clstrno) == NULL)
X            *(chrcpglsts[chno-1]+clstrno) = *(clstep+clstrno); */
X          hcnt++;
X          clstep = scd_appndcpgelt(&clstep,hitpos);
X          if (chrcpglsts[chno-1] == NULL)
X            chrcpglsts[chno-1] = clstep;
X          }
X        }
X      rcnt++;
X      }
X    else
X      err_msg("Can't open chromosome file %s\n",sqfnam);
X    }
Xmemfree(sqfnam);
Xreturn(rcnt);
X}
X
Xdouble scd_medianxcntsarr(int *cnts,
X                          int maxcnt)
X/* cnts is an array of integers 0..maxcnt.  total
Xthem and work out the median. */
X{
Xint ttl;
Xint cp;
Xint medcnt;
Xint medcp1;
Xint tcnt;
Xint nxtnz;
X
Xcp = 0;
Xttl = 0;
Xwhile (cp <= maxcnt)
X  {
X  ttl += *(cnts+cp);
X  cp++;
X  }
Xmedcp1 = 0;
Xmedcnt = (int) ttl/2.0;
Xif ((ttl % 2) == 0)
X  medcp1 = medcnt + 1;
Xelse
X  medcnt++;
Xtcnt = 0;
Xcp = 0;
Xwhile (cp <= maxcnt)
X  {
X  if (tcnt >= medcnt)
X    {
X    cp--;
X    if ((medcp1 == 0) /* odd */ ||
X          (tcnt != medcnt)) /* even but don't need to look for next cnt bucket */
X      return((double) cp);
X    else             /* even, but need to look for next filled count bucket */
X      {
X      nxtnz = cp + 1;
X      while ((nxtnz <= maxcnt) && (*(cnts+nxtnz) == 0))
X        nxtnz++;
X      return((cp + imin(nxtnz,maxcnt))/2.0);
X      }
X    }
X  tcnt += *(cnts+cp);
X  cp++;
X  }
Xreturn((double) maxcnt);
X}
X
Xint scd_modexcntsarr(int *cnts,
X                     int maxcnt)
X/* cnts is an array of integers 0..maxcnt. scan
Xfor largest no and return position as the mode */
X{
Xint biggest;
Xint cp;
Xint bigp;
X
Xbiggest = 0;
Xcp = 0;
Xbigp = 0;
Xwhile (cp <= maxcnt)
X  {
X  if (*(cnts+cp) > biggest)
X    {
X    biggest = *(cnts+cp);
X    bigp = cp;
X    }
X  cp++;
X  }
Xreturn(bigp);
X}
X
Xint main(int argc,
X         char *argv[])
X{
Xint ap;
Xchar op;
Xint ecnts;
XFILE *srcfl;
XSCD_CPGELT *chrcpglsts[ChrY];  /* bin lists for each chromosome */
Xint chrlens[ChrY];       /* length each chromosome */
Xchar *genomsqhdrstr;         /* header string for genomic sequences */
Xint chrcnt;
XRBC_CHRNO chrno;
Xint uchrno;    /* user has specified a chromosome, 0=>all */
Xint cpgcnt;
XFS_FSMSTRCT *cpgfsmp;    /* ptr to CpG searching fsm */
Xint clstrsiz;            /* size of clusters */
Xint listoutput;
Xint statsoutput;
XSCD_CPGELT *cp;
Xint clstrno;
Xint clstp;
XSCD_CPGELT **clulists[ChrY];
Xint maxcount;
Xint sumx;
Xint sumx2;
Xint *distn;
Xint dptr;
Xint curcnt;
Xint mincnt;
Xint histgrmoutput;
Xint biggstcnt;
Xint nast;
Xint ndigs;
Xint zcnt;
Xint hdigs;
Xchar *srcflnam;
Xint missedincnts;
XFILE *missfl;
Xint matcnts;
Xint omitzerocnt;
XFILE *hitfl;
X
Xdebuglevel = RBC_dbg_none;
Xallowoutby1 = 0;      /* don't by default */
Xecnts = 0;
Xsrcfl = NULL;
Xgenomsqhdrstr = NULL;
Xuchrno = 0;
Xlistoutput = statsoutput = histgrmoutput = 0;
Xclstrsiz = CHR_CLUSTER_DEF;
Xcpgfsmp = fs_initnewfsm(4,1,FS_inv_ignor);
Xsrcflnam = "";
Xomitzerocnt = 0;
Xhitfl = missfl = NULL;
Xfor (ap = 1; ap < argc; ap++)
X  if (*argv[ap] == '-')   /* an option */
X    switch (op = *(argv[ap]+1))
X      {
X      case 'r':
X        if (++ap > argc)
X          err_msg_die("-%c needs file name\n",op);
X        else
X          if ((srcfl = fopen(argv[ap],"r")) == NULL)
X            err_msg_die("Can't open read position file %s\n",argv[ap]);
X          else
X            srcflnam = argv[ap];
X        break;
X      case 'g':
X        if (++ap > argc)
X          err_msg_die("-%c needs header string\n",op);
X        else
X          genomsqhdrstr = bas_strdup(argv[ap]);
X        break;
X      case 'd':   /* debug on */
X        debuglevel = RBC_dbg_on;
X        break;
X      case 'D':   /* debug^2 on */
X        debuglevel = RBC_dbg_serious;
X        break;
X      case 'c':   /* a chromosome */
X        if (++ap > argc)
X          err_msg_die("-%c needs a chromosome identifier (1..20,X,Y)\n",op);
X        else
X          if ((uchrno = rbc_str2chrno(argv[ap])) == Chr_unk)
X            err_msg_die("Can't determine Chromosome '%s'\n",argv[ap]);
X        break;
X      case 'l':         /* give listing */
X        listoutput = 1;
X        break;
X      case 'S':         /* statistics output */
X        statsoutput = 1;
X        break;
X      case 'H':         /* histogram */
X        histgrmoutput = 1;
X        break;
X      case 'm':         /* write misses to stdout */
X        missfl = stdout;
X        break;
X      case 'n':        /* write nonmisses to stdout */
X        hitfl = stdout;
X        break;
X      case 'p':        /* permit out-by-one position errors */
X        allowoutby1 = 1;
X        break;
X      case 'z':        /* omit zero count bin from histogram */
X        omitzerocnt = 1;
X        break;
X      case 'h':
X        say_usage(stdout,argv[0]);
X        exit(0);
X        break;
X      default:
X        err_msg("Unknown Option: '%s\n",argv[ap]);
X        say_usage(stderr,argv[0]);
X        exit(1);
X        break;
X      }
X/* should be ready to go now */
Xif ((genomsqhdrstr != NULL) && (listoutput || statsoutput || histgrmoutput)
X      && (clstrsiz > 0))
X  {
X  fs_adddatprs(cpgfsmp,"CG","CG");
X  (void) fs_bldfsm(cpgfsmp,WLU_CASEIND,0,0,tr_int2nares,fs_chkinpstr,fs_shed2lurec);
X  for (chrno = Chr1; chrno <= ChrY; chrno++)
X    {
X    chrcpglsts[chrno-1] = NULL;
X    chrlens[chrno-1] = 0;
X    clulists[chrno-1] = NULL;
X    }
X  (void) scd_scangenomesqs(genomsqhdrstr,ChrY,uchrno,cpgfsmp,clstrsiz,&chrcpglsts[0],&chrlens[0]);
X  if (debuglevel > RBC_dbg_none)
X    for (chrno = Chr1; chrno <= ChrY; chrno++)
X      if (chrcpglsts[chrno-1] != NULL)
X        fprintf(stdout,"C%s %d elts\n",rbc_chrno2str(chrno,1),
X                  scd_iterlstscan(chrcpglsts[chrno-1],SCD_datm_count));
X  for (chrno = Chr1; chrno <= ChrY; chrno++)
X    if (chrcpglsts[chrno-1] != NULL)
X      clulists[chrno-1] = scd_mklookuplst(chrcpglsts[chrno-1],clstrsiz);
X  if (!(matcnts = scd_chknreadsrcfl(&chrcpglsts[0],&chrlens[0],&clulists[0],ChrY,clstrsiz,srcfl,uchrno,
X                           &missedincnts,missfl,hitfl)))
X    err_msg_die("Run failed at sourcefile read\n");
X  if (listoutput)
X    {
X    fprintf(stdout,"Source:%s\nChromosomes:%s<n>.fa\nhit counts =%d, missed counts=%d, OutByOne=%s\n",
X              srcflnam,genomsqhdrstr,matcnts,missedincnts,(allowoutby1?"yes":"no"));
X    for (chrno = Chr1; chrno <= ChrY; chrno++)
X      {
X      cp = chrcpglsts[chrno-1];
X      while (cp != NULL)
X        {
X        fprintf(stdout,"C%s\t%d\t+=%d\t-=%d\tsum=%d\n",rbc_chrno2str(chrno,1),
X                  cp->cpgpos,cp->metcnt,cp->unmetcnt,(cp->metcnt+cp->unmetcnt));
X        cp = cp->nxtcpgelt;
X        }
X      }
X    }
X  if (statsoutput)
X    {
X    maxcount = 0;
X    fprintf(stdout,"Source:%s\nChromosomes:%s<n>.fa\nhit counts =%d, missed counts=%d, OutByOne=%s\n",
X              srcflnam,genomsqhdrstr,matcnts,missedincnts,(allowoutby1?"yes":"no"));
X    fprintf(stdout,"TotMethCpG=%d at %dMCpGs, TotUnMethCpG=%d at %dUnMCpGs, (CpGs Meth+UnMeth=%d)\n",
X              scd_datm4allchr(chrcpglsts,ChrY,SCD_datm_metcnt),
X              scd_datm4allchr(chrcpglsts,ChrY,SCD_datm_metcpgpos),
X              scd_datm4allchr(chrcpglsts,ChrY,SCD_datm_unmetcnt),
X              scd_datm4allchr(chrcpglsts,ChrY,SCD_datm_unmetcpgpos),
X              scd_datm4allchr(chrcpglsts,ChrY,SCD_datm_metunmetcpgpos));
X    for (chrno = Chr1; chrno <= ChrY; chrno++)
X      maxcount = imax(maxcount,scd_iterlstscan(chrcpglsts[chrno-1],SCD_datm_maxtotcnt));
X    distn = (int *) getmemory((maxcount + 1) * sizeof(int),"Distribution");
X    sumx = sumx2 = cpgcnt = 0;
X    mincnt = maxcount;
X    for (dptr = 0; dptr <= maxcount; dptr++)
X      *(distn + dptr) = 0;
X    for (chrno = Chr1; chrno <= ChrY; chrno++)
X      {
X      cp = chrcpglsts[chrno-1];
X      while (cp != NULL)
X        {
X        cpgcnt++;
X        curcnt = cp->metcnt + cp->unmetcnt;
X        sumx += curcnt;
X        sumx2 += curcnt * curcnt;
X        (*(distn+curcnt))++;
X        mincnt = imin(mincnt,curcnt);
X        cp = cp->nxtcpgelt;
X        }
X      }
X    fprintf(stdout,"Counts: min=%d max=%d mean=%.2f sdev=%.2f\n",
X              mincnt,maxcount,(double)sumx/cpgcnt,sqrt((sumx2 - sumx*sumx/cpgcnt)/(cpgcnt-1)));
X    fprintf(stdout,"Median = %.1f mode=%d\n",scd_medianxcntsarr(distn,maxcount),
X              scd_modexcntsarr(distn,maxcount));
X    }
X  if (histgrmoutput)
X    {
X    fprintf(stdout,"Source:%s\nChromosomes:%s<n>.fa\nhit counts =%d, missed counts=%d, OutByOne=%s\n",
X              srcflnam,genomsqhdrstr,matcnts,missedincnts,(allowoutby1?"yes":"no"));
X    maxcount = 0;
X    for (chrno = Chr1; chrno <= ChrY; chrno++)
X      maxcount = imax(maxcount,scd_iterlstscan(chrcpglsts[chrno-1],SCD_datm_maxtotcnt));
X    distn = (int *) getmemory((maxcount + 1) * sizeof(int),"Distribution");
X    sumx = sumx2 = cpgcnt = 0;
X    mincnt = maxcount;
X    for (dptr = 0; dptr <= maxcount; dptr++)
X      *(distn + dptr) = 0;
X    for (chrno = Chr1; chrno <= ChrY; chrno++)
X      {
X      cp = chrcpglsts[chrno-1];
X      while (cp != NULL)
X        {
X        cpgcnt++;
X        curcnt = cp->metcnt + cp->unmetcnt;
X        sumx += curcnt;
X        sumx2 += curcnt * curcnt;
X        (*(distn+curcnt))++;
X        mincnt = imin(mincnt,curcnt);
X        cp = cp->nxtcpgelt;
X        }
X      }
X    biggstcnt = 0;
X    if (omitzerocnt)
X      dptr = 1;
X    else
X      dptr = 0;
X    while (dptr <= maxcount)
X      {
X      biggstcnt = imax(*(distn+dptr),biggstcnt);
X      dptr++;
X      }
X    dptr = 0;
X    ndigs = bas_digitsin(biggstcnt);
X    hdigs = bas_digitsin(maxcount);
X    zcnt = 0;
X    while (dptr <= maxcount)
X      {
X      if (*(distn+dptr) > 0)
X        zcnt = 0;
X      else
X        zcnt++;
X      if (zcnt <= 3)
X        {
X        fprintf(stdout,"%*d %*d |",hdigs,dptr,ndigs,*(distn+dptr));
X        if (omitzerocnt && (dptr == 0))
X          nast = 50 - bas_digitsin(*(distn)) - 1;
X        else
X          nast = (int)((*(distn+dptr)*50)/ biggstcnt);
X        while (nast > 0)
X          {
X          fputc('*',stdout);
X          nast--;
X          }
X        if (omitzerocnt & (dptr == 0))
X          fprintf(stdout,">%d",*(distn));
X        fputc('\n',stdout);
X        }
X      else
X        if (zcnt == 4)
X          fputs("[...]\n",stdout);
X      dptr++;
X      }
X    }
X  }
Xexit(0);
X}
END-of-meth_progs_dist/src/scan_cpg_depth.c
echo x - meth_progs_dist/src/sqfl_fns.c
sed 's/^X//' >meth_progs_dist/src/sqfl_fns.c << 'END-of-meth_progs_dist/src/sqfl_fns.c'
X/* sqfl_fns.c: c functions for sequence file accessing */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <string.h>
X#include <strings.h>
X#include <ctype.h>
X#include <libgen.h>
X#include <sys/param.h>
X
X#include "bas_fns.h"
X#include "wlu_fns.h"
X#include "sqfl_fns.h"
X
XSFMT_TYPE sqfl_chr2fmttp(char fchr)
X  /* convert the letters s,q,f,n,u,r to corresponding file format type.
X  currently case independent */
X{
Xswitch (tolower(fchr))
X  {
X  case 's':
X    return(SFMT_staden);
X    break;
X  case 'q':
X    return(SFMT_molgen);
X    break;
X  case 'f':
X    return(SFMT_fasta);
X    break;
X  case 'n':
X    return(SFMT_nbrf);
X    break;
X  case 'u':
X    return(SFMT_gcg);
X    break;
X  case 'r':
X    return(SFMT_raw);
X    break;
X  default:
X    return(SFMT_undefined);
X    break;
X  }
X}
X
XSFMT_TYPE sqfl_getdeffmt()
X  /* use env variable SQDEFFILEFMT to establish default file type */
X{
Xchar *enm;
X
Xif ((enm = getenv("SQDEFFILEFMT")) != NULL)
X  return(sqfl_chr2fmttp(*enm));
Xelse
X  return(SFMT_undefined);
X}
X
Xchar *sqfl_fmttp2strng(SFMT_TYPE sfmt)
X  /* return the pointer to a string defining sfmt */
X{
Xswitch (sfmt)
X  {
X  case SFMT_staden:
X    return("Staden");
X    break;
X  case SFMT_molgen:
X    return("Molgen/SEQ");
X    break;
X  case SFMT_fasta:
X    return("FASTA");
X    break;
X  case SFMT_nbrf:
X    return("NBRF");
X    break;
X  case SFMT_gcg:
X    return("GCG");
X    break;
X  case SFMT_raw:
X    return("RAW");
X    break;
X  case SFMT_undefined:
X  default:
X    return("Undefined");
X    break;
X  }
X}
X
Xchar sqfl_fmttp2chr(SFMT_TYPE sfmt)
X  /* return a character sfmt */
X{
Xswitch (sfmt)
X  {
X  case SFMT_staden:
X    return('S');
X    break;
X  case SFMT_molgen:
X    return('Q');
X    break;
X  case SFMT_fasta:
X    return('F');
X    break;
X  case SFMT_nbrf:
X    return('N');
X    break;
X  case SFMT_gcg:
X    return('U');
X    break;
X  case SFMT_raw:
X    return('R');
X    break;
X  case SFMT_undefined:
X  default:
X    return('?');
X    break;
X  }
X}
X
Xchar sqfl_restype2chr(SQ_RESTYPE rt)
X  /* return the character corresponding to rt */
X{
Xswitch (rt)
X  {
X  case RES_blk:
X    return(' ');
X    break;
X  case RES_a:
X    return('A');
X    break;
X  case RES_b:
X    return('B');
X    break;
X  case RES_c:
X    return('C');
X    break;
X  case RES_g:
X    return('G');
X    break;
X  case RES_t:
X    return('T');
X    break;
X  case RES_d:     /* Asp */
X    return('D');
X    break;
X  case RES_f:
X    return('F');
X    break;
X  case RES_h:
X    return('H');
X    break;
X  case RES_i:
X    return('I');
X    break;
X  case RES_k:
X    return('K');
X    break;
X  case RES_l:
X    return('L');
X    break;
X  case RES_m:
X    return('M');
X    break;
X  case RES_n:
X    return('N');
X    break;
X  case RES_p:
X    return('P');
X    break;
X  case RES_q:
X    return('Q');
X    break;
X  case RES_e:
X    return('E');
X    break;
X  case RES_r:
X    return('R');
X    break;
X  case RES_s:
X    return('S');
X    break;
X  case RES_v:
X    return('V');
X    break;
X  case RES_w:
X    return('W');
X    break;
X  case RES_y:
X    return('Y');
X    break;
X  case RES_z:
X    return('Z');
X    break;
X  case RES_x:
X    return('-');
X    break;
X  default:
X    return('?');
X    break;
X  }
X}
X
Xchar *sqfl_restype2str(SQ_RESTYPE rt)
X  /* return the address of a string corresponding to rt */
X{
Xswitch (rt)
X  {
X  case RES_blk:
X    return("   ");
X    break;
X  case RES_a:
X    return("Ala");
X    break;
X  case RES_b:
X    return("Asx");
X    break;
X  case RES_c:
X    return("Cys");
X    break;
X  case RES_g:
X    return("Gly");
X    break;
X  case RES_t:
X    return("Thr");
X    break;
X  case RES_d:     /* Asp */
X    return("Asp");
X    break;
X  case RES_f:
X    return("Phe");
X    break;
X  case RES_h:
X    return("His");
X    break;
X  case RES_i:
X    return("Ile");
X    break;
X  case RES_k:
X    return("Lys");
X    break;
X  case RES_l:
X    return("Leu");
X    break;
X  case RES_m:
X    return("Met");
X    break;
X  case RES_n:
X    return("Asn");
X    break;
X  case RES_p:
X    return("Pro");
X    break;
X  case RES_q:
X    return("Gln");
X    break;
X  case RES_e:
X    return("Glu");
X    break;
X  case RES_r:
X    return("Arg");
X    break;
X  case RES_s:
X    return("Ser");
X    break;
X  case RES_v:
X    return("Val");
X    break;
X  case RES_w:
X    return("Trp");
X    break;
X  case RES_y:
X    return("Tyr");
X    break;
X  case RES_z:
X    return("Glx");
X    break;
X  case RES_x:
X    return("---");
X    break;
X  default:
X    return("???");
X    break;
X  }
X}
X
XSQ_RESTYPE sqfl_chr2restype(char res)
X  /* return an internal restype for this character */
X{
Xswitch (toupper(res))
X  {
X  case 'A':
X    return(RES_a);
X    break;
X  case 'B':
X    return(RES_b);
X    break;
X  case 'C':
X    return(RES_c);
X    break;
X  case 'G':
X    return(RES_g);
X    break;
X  case 'U':
X  case 'T':
X    return(RES_t);
X    break;
X  case 'D':
X    return(RES_d);
X    break;
X  case 'F':
X    return(RES_f);
X    break;
X  case 'H':
X    return(RES_h);
X    break;
X  case 'I':
X    return(RES_i);
X    break;
X  case 'K':
X    return(RES_k);
X    break;
X  case 'L':
X    return(RES_l);
X    break;
X  case 'M':
X    return(RES_m);
X    break;
X  case 'N':
X    return(RES_n);
X    break;
X  case 'P':
X    return(RES_p);
X    break;
X  case 'Q':
X    return(RES_q);
X    break;
X  case 'E':
X    return(RES_e);
X    break;
X  case 'R':
X    return(RES_r);
X    break;
X  case 'S':
X    return(RES_s);
X    break;
X  case 'V':
X    return(RES_v);
X    break;
X  case 'W':
X    return(RES_w);
X    break;
X  case 'Y':
X    return(RES_y);
X    break;
X  case 'Z':
X    return(RES_z);
X    break;
X  case ' ':
X    return(RES_blk);
X    break;
X  default:
X    return(RES_x);
X    break;
X  }
X}
X
XSQ_RESTYPE sqfl_chr2narestype(char rs)
X  /* return RES_x..RES_t only */
X{
XSQ_RESTYPE rt;
X
Xif ((rt = sqfl_chr2restype(rs)) <= RES_t)
X  return(rt);
Xelse
X  return(RES_x);
X}
X
XSQ_RESTYPE sqfl_chr2aarestype(char r)
X  /* return the corresponding restype for r, assuming it is a valid AA code,
Xelse return RES_x */
X{
Xif (toupper(r) != 'U')
X  return(sqfl_chr2restype(r));
Xelse
X  return(RES_x);
X}
X
Xint sqfl_linelength(SFMT_TYPE sfmt)
X  /* return normal linelength used by this format */
X{
Xswitch (sfmt)
X  {
X  case SFMT_molgen:
X    return(70);
X    break;
X  case SFMT_gcg:
X    return(50);
X    break;
X  case SFMT_raw:
X    return(0);
X    break;
X  case SFMT_staden:
X  case SFMT_fasta:
X  case SFMT_nbrf:
X  case SFMT_undefined:
X  default:
X    return(60);
X    break;
X  }
X}
X
Xint sqfl_gcgchkinc(int sp,
X                   char res)
X/* return the incremental addition for the GCG check algorithm for res at
X  position sp, (1..n) */
X{
Xreturn((1 + --sp % SQFL_GCGCHK)*((int) toupper(res)));
X}
X
Xint sqfl_gcgsqchksum(char *sq,
X                     int sqlen)
X/* return gcg checksum for (1..sqlen) chars of sq.  Stop at '\0'
Xif encountered ealier */
X{
Xint csum;
Xchar *sp;
Xint pt;
X
Xcsum = 0;
Xsp = sq;
Xpt = 1;
Xwhile ((pt <= sqlen) && (*sp != '\0'))
X  csum += sqfl_gcgchkinc(pt++,*sp++);
Xreturn(csum % 10000);
X}
X
XSQFL_SQTOS sqfl_scantos(char *sqbuf,
X                        int sqln)
X/* scan sqbuf, looking for evidence of NA or peptide.
X  Algorithm looks for the letters E,F,I,O,X,Z: none of which should occur in
X  DNA sequences, even using IUB or LDNA redundant base codes.  A proportion
X  1% of strangers is allowed */
X{
Xint ccnt[27];
Xchar *sp;
Xint pt;
Xint dtot;
Xchar uc;
Xint ptot;
X
Xsp = sqbuf;
Xfor (pt = 0; pt < 27; pt++)
X  ccnt[pt] = 0;
Xwhile ((*sp != '\0') && (sqln-- > 0))
X  if (((uc = toupper(*sp++)) >= 'A') && (uc <= 'Z'))
X    ccnt[((int) uc - 'A' + 1)]++;
X  else
X    ccnt[0]++;
Xdtot = ptot = 0;
Xfor (pt = 1; pt < 27; pt++)  /* ignore unknowns */
X  if (index("EFIOXZ",((char) pt + 'A' - 1)) != NULL) /* peptide residue */
X    ptot += ccnt[pt];
X  else
X    dtot += ccnt[pt];
Xif (ptot > dtot/100)
X  return(SQFL_peptide);
Xelse
X  if (ccnt[(int) ('T' - 'A' + 1)] > ccnt[(int) ('U' - 'A' + 1)])
X    return(SQFL_dna);
X  else
X    return(SQFL_rna);
X}
X
XSQFL_SQTOS sqfl_scanfltos(SQFL_STRCT *src)
X  /* scan contents of previously opened src, looking for evidence of 
XNA or peptide.  Rewind source file on completion.
X  Algorithm looks for the letters E,F,I,O,X,Z: none of which should occur in
X  DNA sequences, even using IUB or LDNA redundant base codes.  A proportion
X  1% of strangers is allowed */
X{
Xint ccnt[27];
Xchar nr;
Xint pt;
Xint dtot;
Xchar uc;
Xint ptot;
X
Xif (sqfl_skipsqflhdr(src))
X  {
X  for (pt = 0; pt < 27; pt++)
X    ccnt[pt] = 0;
X  while ((nr = sqfl_getnxtres(src)) != '\0')
X    if (((uc = toupper(nr)) >= 'A') && (uc <= 'Z'))
X      ccnt[((int) uc - 'A' + 1)]++;
X    else
X      ccnt[0]++;
X  sqfl_rewind(src);
X  dtot = ptot = 0;
X  for (pt = 1; pt < 27; pt++)  /* ignore unknowns */
X    if (index("EFIOXZ",((char) pt + 'A' - 1)) != NULL) /* peptide residue */
X      ptot += ccnt[pt];
X    else
X      dtot += ccnt[pt];
X  if (ptot > dtot/100)    /* allow 1% "foreigners" */
X    return(SQFL_peptide);
X  else
X    if (ccnt[(int) ('T' - 'A' + 1)] > ccnt[(int) ('U' - 'A' + 1)])
X      return(SQFL_dna);
X    else
X      return(SQFL_rna);
X  }
Xelse
X  return(SQFL_tosunknown);
X}
X
Xchar sqfl_tos2chr(SFMT_TYPE sfmt,
X                  SQFL_SQTOS st)
X  /* return the character for sequence st - default to D */
X{
Xswitch (sfmt)
X  {
X  case SFMT_nbrf:
X  case SFMT_fasta:
X    switch (st)
X      {
X      case SQFL_peptide:
X        return('P');
X        break;
X      case SQFL_rna:
X        return('R');
X        break;
X      case SQFL_dna:
X      case SQFL_tosunknown:
X      default:
X        return('D');
X        break;
X      }
X    break;
X  case SFMT_gcg:
X    switch (st)
X      {
X      case SQFL_peptide:
X        return('P');
X        break;
X      case SQFL_rna:
X      case SQFL_dna:
X      case SQFL_tosunknown:
X      default:
X        return('N');
X        break;
X      }
X    break;
X  case SFMT_staden:
X  case SFMT_molgen:
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    return('\0');
X    break;
X  }
Xreturn('D');
X}
X
Xvoid sqfl_settos(SQFL_STRCT *st,
X                 SQFL_SQTOS tos)
X/* set tos field of st */
X{
Xst->sqtos = tos;
X}
X
Xvoid sqfl_settopol(SQFL_STRCT *st,
X                   SQFL_SQTOPOL tpl)
X/* set topology field of st to tpl */
X{
Xst->stopol = tpl;
X}
X
Xvoid sqfl_setsqdetails(SQFL_STRCT *st,
X                       char *sqbuf,
X                       int sqlen)
X/* set as many as possible of st details by examination of sqbuf */
X{
Xif ((sqbuf != NULL) && (sqlen > 0))
X  {
X  if (st->sqtos == SQFL_tosunknown)
X    st->sqtos = sqfl_scantos(sqbuf,sqlen);
X  if (st->stopol == SQTP_unknown)
X    switch (st->sqtos)
X      {
X      case SQFL_peptide:
X        st->stopol = SQTP_linear;
X        break;
X      case SQFL_dna:
X      case SQFL_rna:
X      case SQFL_tosunknown:
X      default:
X        break;
X      }
X  }
Xelse
X  st->sqtos = SQFL_tosunknown;
Xst->slength = sqlen;
X/* if (st->flfmt == SFMT_gcg)
X  st->gcgchksum = sqfl_gcgsqchksum(sqbuf,sqlen); */
X}
X
Xvoid sqfl_headsfstr(SQFL_STRCT *sst,
X                    char *sqname,
X                    char *ann)
X/* write sequence header info to previously opened sst->sfl, using string ann
X */
X{
Xchar *qp;
X
Xswitch (sst->flfmt)
X  {
X  case SFMT_fasta:
X    if (sqname != NULL)
X      fprintf(sst->sfl,">%s - ",sqname);
X    fprintf(sst->sfl,"%s\n",((ann != NULL)?ann:""));
X    break;
X  case SFMT_nbrf:
X    if (sqname != NULL)
X      fprintf(sst->sfl,">%c%c;%s\n",sqfl_tos2chr(sst->flfmt,sst->sqtos),
X                sqfl_topol2chr(sst->flfmt,sst->stopol),sqname);
X    else
X      fprintf(sst->sfl,">DL;%s\n",((sst->filnam != NULL)?sst->filnam:"?SEQ"));
X    if (ann != NULL)
X      fprintf(sst->sfl,"%s\n",ann);
X    else
X      fputc('\n',sst->sfl);
X    break;
X  case SFMT_molgen:
X    if (sqname != NULL)
X      fprintf(sst->sfl,"; %s: ",sqname);
X    qp = ann;
X    while ((qp != NULL) && (*qp != '\0'))
X      {
X      if (*qp == '\n')
X        fprintf(sst->sfl,"\n; ");
X      else
X        fputc(*qp,sst->sfl);
X      qp++;
X      }
X    fputc('\n',sst->sfl);
X    if (sqname != NULL)
X      fprintf(sst->sfl,"%s\n",sqname);
X    break;
X  case SFMT_gcg:
X  case SFMT_staden:
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    break;
X  }
X}
X
Xvoid sqfl_headsfstrct(SQFL_STRCT *sst,
X                      char *sqname,
X                      char *maker,
X                      char *origin)
X/* write sequence header info to previously opened sst->sfl */
X{
Xchar hbuf[HDRBUF_MAX+1];
Xchar *bp;
X
Xif (sqname != NULL)
X  sst->seqnam = bas_strdup(basename(sqname));
Xelse
X  sst->seqnam = NULL;
Xswitch (sst->flfmt)
X  {
X  case SFMT_nbrf:
X  case SFMT_fasta:
X  case SFMT_molgen:
X    bp = &hbuf[0];
X    if (maker != NULL)
X      {
X      bas_appstr(&hbuf[0],&bp," Created by ",HDRBUF_MAX);
X      bas_appstr(&hbuf[0],&bp,maker,HDRBUF_MAX);
X      if (origin != NULL)
X        {
X        bas_appstr(&hbuf[0],&bp," from ",HDRBUF_MAX);
X        bas_appstr(&hbuf[0],&bp,origin,HDRBUF_MAX);
X        }
X      bas_appstr(&hbuf[0],&bp," on ",HDRBUF_MAX);
X      bas_appdate2str(&hbuf[0],&bp,HDRBUF_MAX);
X      }
X    if ((origin != NULL) && (maker == NULL))
X      bas_appstr(&hbuf[0],&bp,origin,HDRBUF_MAX);
X    if (sst->annot != NULL)
X      {
X      bas_appchr(&hbuf[0],&bp,' ',HDRBUF_MAX);
X      bas_appstr(&hbuf[0],&bp,sst->annot,HDRBUF_MAX);
X      }
X    sqfl_headsfstr(sst,sqname,&hbuf[0]);
X    break;
X  case SFMT_gcg:
X  case SFMT_staden:
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    break;
X  }
X}
X
Xvoid sqfl_headsfstrctann(SQFL_STRCT *sst,
X                         char *sqname)
X/* write sequence header info to previously opened sst->sfl. use annotation
X  if set */
X{
Xchar hbuf[HDRBUF_MAX+1];
Xchar *bp;
X
Xif (sst->annot != NULL)
X  sqfl_headsfstr(sst,sqname,sst->annot);
Xelse
X  {
X  bp = &hbuf[0];
X  bas_appstr(&hbuf[0],&bp,"Written by sqfl_fns on ",HDRBUF_MAX);
X  bas_appdate2str(&hbuf[0],&bp,HDRBUF_MAX);
X  sqfl_headsfstr(sst,sqname,&hbuf[0]);
X  }
X}
X
Xvoid sqfl_newlnstart(FILE *sfl,
X                     SFMT_TYPE sfmt,
X                     int sp)
X/* if necessary, write this number as a line start */
X{
Xswitch (sfmt)
X  {
X  case SFMT_gcg:
X      if ((sfmt == SFMT_gcg) && (sp > 0))
X    fprintf(sfl,"%8d  ",sp);
X    break;
X  case SFMT_undefined:
X  case SFMT_staden:
X  case SFMT_molgen:
X  case SFMT_nbrf:
X  case SFMT_fasta:
X  case SFMT_raw:
X  default:
X    break;
X  }
X}
X
Xvoid sqfl_sqchr2fl(FILE *fl,
X                   SFMT_TYPE sfmt,
X                   char chr,
X                   int llen,
X                   int rp,
X                   int *lcnt)
X/* guts of writing sequence chars to a stream file */
X{
Xif ((*lcnt >= llen) && (llen > 0))
X  {
X  fputc('\n',fl);
X  *lcnt = 0;
X  sqfl_newlnstart(fl,sfmt,rp);
X  }
Xif (sfmt == SFMT_gcg)
X  {
X  if (rp == 1)
X    sqfl_newlnstart(fl,SFMT_gcg,rp);
X  if ((*lcnt % 10) == 0)
X    fputc(' ',fl);
X  }
Xfputc(chr,fl);
X(*lcnt)++;
X}
X
Xvoid sqfl_putchr(SQFL_STRCT *sqs,
X                 char chr,
X                 int rp,
X                 int *lcnt)
X/* put chr out to file, ignoring validity. observe line count etc */
X{
Xsqs->scnt++;
Xif (sqs->flfmt == SFMT_gcg)
X  {
X  sqs->gcgchksum += sqfl_gcgchkinc(sqs->scnt,chr);
X  fputc(chr,sqs->gfl);
X  }
Xelse
X  sqfl_sqchr2fl(sqs->sfl,sqs->flfmt,chr,sqs->lnlen,rp,lcnt);
X}
X
Xvoid sqfl_putres(SQFL_STRCT *sqs,
X                 char res,
X                 int rp,
X                 int *lcnt)
X/* put res out to file, keeping track of valid bases, line count etc */
X{
Xif (sqs->validlut[(int) res])
X  sqfl_putchr(sqs,res,rp,lcnt);
Xelse
X  if ((sqs->flfmt == SFMT_gcg) && (res == '-'))
X    sqfl_putchr(sqs,'X',rp,lcnt);
X}
X
Xint sqfl_fgetc(FILE *fl)
X  /* return character (as int) from fl.  ignore '\r' chars totally */
X{
Xint nc;
X
Xwhile ((nc = fgetc(fl)) == '\r');
Xreturn(nc);
X}
X
Xvoid sqfl_termsqfl(SQFL_STRCT *sqs,
X                   char *pname,
X                   int *lcnt)
X/* finish off sequence if necessary */
X{
Xint sp;
Xint sc;
X
Xswitch (sqs->flfmt)
X  {
X  case SFMT_staden:
X    sqfl_putchr(sqs,'@',0,lcnt);
X    break;
X  case SFMT_molgen:
X    sqfl_putchr(sqs,sqfl_topol2chr(sqs->flfmt,sqs->stopol),0,lcnt);
X    break;
X  case SFMT_nbrf:
X    sqfl_putchr(sqs,'*',0,lcnt);
X    break;
X  case SFMT_gcg:
X    if (sqs->annot != NULL)
X      fprintf(sqs->sfl,"%s: %s",sqs->filnam,sqs->annot);
X    else
X      {
X      if (pname != NULL)
X        fprintf(sqs->sfl,"%s: Created by %s ",sqs->filnam,pname);
X      else
X        fprintf(sqs->sfl,"%s: Created ",sqs->filnam);
X      fprintf (sqs->sfl,"on ");
X      sqfl_date2file(sqs->sfl);
X      }
X    fprintf(sqs->sfl,"\n  Length: %d Type: %c Check: %d ..\n",
X              sqs->scnt,
X              sqfl_tos2chr(sqs->flfmt,sqs->sqtos),
X              (sqs->gcgchksum % 10000));
X    fflush(sqs->gfl);
X    rewind(sqs->gfl);
X    sp = 1;
X    while ((sc = sqfl_fgetc(sqs->gfl)) != EOF)
X      sqfl_sqchr2fl(sqs->sfl,SFMT_gcg,(char) sc,sqs->lnlen,sp++,lcnt);
X    break;
X  case SFMT_fasta:
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    break;
X  }
Xif (*lcnt > 0)
X  fputc('\n',sqs->sfl);
X}
X
Xint sqfl_lookforchr(FILE *sfl,
X                    char ec)
X/* scan sfl, looking for ec.  stop and return 1.  Return 0 if EOF encountered
X  before hand */
X{
Xint nc;
X
Xwhile ((nc = sqfl_fgetc(sfl)) != EOF)
X  if ((char) nc == ec)
X    return(1);
Xreturn(0);
X}
X
Xint sqfl_look4chrs(FILE *sfl,
X                   char *ecs)
X/* scan sfl, looking for anything in ecs.  stop and return that char.
X  Return EOF if not encountered by EOF */
X{
Xint nc;
X
Xwhile ((nc = sqfl_fgetc(sfl)) != EOF)
X  if (index(ecs,(char) nc) != NULL)
X    return(nc);
Xreturn(EOF);
X}
X
XSQFL_SQTOPOL sqfl_chr2topol(SFMT_TYPE sfmt,
X                            char tc)
X/* return the topology for char tc */
X{
Xswitch (sfmt)
X  {
X  case SFMT_fasta:
X  case SFMT_nbrf:
X    switch (toupper(tc))
X      {
X      case 'L':
X        return(SQTP_linear);
X        break;
X      case 'C':
X        return(SQTP_circular);
X        break;
X      default:
X        return(SQTP_unknown);
X        break;
X      }
X    break;
X  case SFMT_molgen:
X    switch (tc)
X      {
X      case '1':
X        return(SQTP_linear);
X        break;
X      case '2':
X        return(SQTP_circular);
X        break;
X      default:
X        return(SQTP_unknown);
X        break;
X      }
X    break;
X  case SFMT_staden:
X  case SFMT_gcg:
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    return(SQTP_unknown);
X    break;
X  }
Xreturn(SQTP_unknown);
X}
X
Xchar sqfl_topol2chr(SFMT_TYPE sfmt,
X                    SQFL_SQTOPOL st)
X/* return a character corresponding to st for sfmt */
X{
Xswitch (sfmt)
X  {
X  case SFMT_fasta:
X  case SFMT_nbrf:
X    switch (st)
X      {
X      case SQTP_circular:
X        return('C');
X        break;
X      case SQTP_linear:
X      case SQTP_unknown:
X      default:
X        return('L');
X        break;
X      }
X    break;
X  case SFMT_molgen:
X    switch (st)
X      {
X      case SQTP_circular:
X        return('2');
X        break;
X      case SQTP_linear:
X      case SQTP_unknown:
X      default:
X        return('1');
X        break;
X      }
X    break;
X  case SFMT_gcg:
X  case SFMT_staden:
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    return('\0');
X    break;
X  }
Xreturn('1');
X}
X
XSQFL_SQTOS sqfl_chr2tos(SFMT_TYPE sfmt,
X                        char tc)
X/* return the tos for tc - case independent */
X{
Xswitch (sfmt)
X  {
X  case SFMT_nbrf:
X  case SFMT_fasta:
X    switch (toupper(tc))
X      {
X      case 'P':
X        return(SQFL_peptide);
X        break;
X      case 'D':
X        return(SQFL_dna);
X        break;
X      case 'R':
X        return(SQFL_rna);
X        break;
X      default:
X        return(SQFL_tosunknown);
X        break;
X      }
X    break;
X  case SFMT_gcg:
X    switch (toupper(tc))
X      {
X      case 'P':
X        return(SQFL_peptide);
X        break;
X      case 'N':
X        return(SQFL_dna);
X        break;
X      default:
X        return(SQFL_tosunknown);
X        break;
X      }
X    break;
X  case SFMT_molgen:
X  case SFMT_staden:
X  case SFMT_raw:
X  default:
X    return(SQFL_tosunknown);
X    break;
X  }
X}
X
Xvoid sqfl_skipeol(SQFL_STRCT *sqs)
X  /* try to skip to end of current line - check if just seen eol already */
X{
Xif ((sqs->lstinchr != '\n') && (sqs->lstinchr != '\r'))
X  /* allow for PC-sourced files */
X  bas_skipeol(sqs->sfl,NULL);
Xsqs->lstinchr = '\n';
X}
X
Xvoid sqfl_skipeolnstor(SQFL_STRCT *sqs)
X  /* try to skip to end of current line - check if just seen eol already.
X    store skipped chars to annotation buffer if defined */
X{
Xint nc;
Xchar *bp;
X
Xbp = sqs->annot;
Xif ((sqs->lstinchr != '\n') && (sqs->lstinchr != '\r'))
X  while (((nc = fgetc(sqs->sfl)) != EOF) && ((char) nc != '\n') &&
X            ((char) nc != '\r'))   /* allow for PC-sourced files */
X    if (sqs->annot != NULL)
X      bas_appchr(sqs->annot,&bp,(char) nc,sqs->abuflen);
Xsqs->lstinchr = '\n';
X}
X
Xvoid sqfl_forceeol(SQFL_STRCT *sqs)
X  /* force skip to eol irrespective of what has been seen todate */
X{
Xsqs->lstinchr = '\0';
Xsqfl_skipeol(sqs);
X}
X
Xint sqfl_cpy2eol(SQFL_STRCT *sqs,
X                 char *buf,
X                 int bufmax,
X                 int (*ufgetc)(FILE *fl))
X/* copy to next line end to buf, up to bufmax, using ufgetc,
X  return no of chars written */
X{
Xint ccnt;
Xchar *bp;
Xint nc;
X
Xccnt = 0;
Xbp = buf;
Xwhile (((nc = (*ufgetc)(sqs->sfl)) != (char) EOF) && (nc != '\n'))
X  if ((ccnt++ < bufmax) && (buf != NULL))
X    *bp++ = (char) nc;
Xif (bp != NULL)
X  *bp = '\0';
Xsqs->lstinchr = (char) nc;
Xreturn(ccnt);
X}
X
Xint sqfl_skipsqflhdr(SQFL_STRCT *sqs)
X  /* skip file header, getting to start of sequence.  Eventually this routine
Xshould be able to extract data from the header.  Return 1 if nothing untoward
Xoccured */
X{
Xint nc;
Xchar *np;
XWRD_LUSTRCT gcglu;  /* for parsing gcg header words */
Xchar gcgwrd[MAXPATHLEN + 1];    /* use as general atom */
XWLU_CHRLUTBL toklu;  /* separators for gcg tokens */
Xint nl;
Xchar *sp;
X
Xswitch (sqs->flfmt)
X  {
X  case SFMT_fasta:    /* may or may not have nbrf-style headers.. */
X    if ((sqs->lstinchr == '>') || (sqfl_lookforchr(sqs->sfl,'>')))
X      {
X      wlu_maktoklu(&toklu[0]," \t\n\r");
X      if (wlu_gettokensep(sqs->sfl,gcgwrd,MAXPATHLEN,&toklu[0],&sqs->lstinchr) <= 0)
X        return(0);
X      else
X        {
X        if (index(gcgwrd,';') != NULL)     /* NBRF-style header */
X          {                /* next char is sequence type */
X          sp = &gcgwrd[0];
X          sqs->sqtos = sqfl_chr2tos(sqs->flfmt,*sp++);
X          if (*sp == '\0')
X            return(0);
X          else
X            {
X            sqs->stopol = sqfl_chr2topol(sqs->flfmt,*sp++);
X            sp++;
X            }
X          }         
X        else        /* not nbrf fmt, use entire string as name */
X          {
X          sqs->sqtos = SQFL_tosunknown;
X          sqs->stopol = SQTP_unknown;
X          sp = &gcgwrd[0];
X          }
X        }
X      (void) strncpy(sqs->seqnam,basename(&gcgwrd[0]),(size_t) SQNAMEMAXLEN);
X      if ((sqs->lstinchr != '\n') && (sqs->lstinchr != '\r'))
X        (void) sqfl_cpy2eol(sqs,sqs->annot,sqs->abuflen,sqfl_fgetc);
X      else
X        sqs->annot = bas_strdup("");  /* must have malloc()ed this */
X      np = sqs->annot;
X      sqs->abuflen = strlen(np);
X      sqs->annot = bas_strdup(np);
X      memfree(np);      
X/*      sqfl_skipeolnstor(sqs); */
X      return(strlen(sqs->seqnam) > 0);
X      }
X    break;
X  case SFMT_nbrf:
X    if ((sqs->lstinchr == '>') || (sqfl_lookforchr(sqs->sfl,'>')))
X      if ((nc = sqfl_fgetc(sqs->sfl)) == EOF)
X        return(0);
X      else
X        {                /* next char is sequence type */
X        sqs->lstinchr = (char) nc;
X        sqs->sqtos = sqfl_chr2tos(sqs->flfmt,(char) nc);
X        if ((nc = sqfl_fgetc(sqs->sfl)) == EOF)
X          return(0);
X        else
X          {
X          sqs->stopol = sqfl_chr2topol(sqs->flfmt,(char) nc);
X          nl = bas_fgetatm_ufn(sqs->sfl,sqs->seqnam,SQNAMEMAXLEN,";\n\r",
X                                 sqfl_fgetc);
X          (void) sqfl_cpy2eol(sqs,sqs->annot,sqs->abuflen,sqfl_fgetc);
X          np = sqs->annot;
X          sqs->abuflen = strlen(np);
X          sqs->annot = bas_strdup(np);
X          memfree(np);      
X          return(nl);
X          }
X        }
X    break;
X  case SFMT_molgen:
X    while (((nc = sqfl_fgetc(sqs->sfl)) == ';') && (nc != EOF))
X      if (sqfl_look4chrs(sqs->sfl,"\n\r") == EOF)
X        return(0);
X    if (nc == EOF)
X      return(0);
X    np = sqs->seqnam;
X    if (np == NULL)
X      return(1);
X    while ((((char) nc != '\n') && ((char) nc != '\r')) &&
X            ((np - sqs->seqnam) < SQNAMEMAXLEN))
X      {
X      *np++ = (char) nc;
X      if ((nc = sqfl_fgetc(sqs->sfl)) == EOF)
X        return(0);
X      }
X    if (((char) nc == '\n') || ((char) nc == '\r'))
X /* timed out through line terminator */
X      {
X      *np = '\0';
X      return(1);
X      }
X    else
X      if (sqfl_look4chrs(sqs->sfl,"\n\r") != EOF)
X        return(1);
X      else
X        return(0);
X    break;
X  case SFMT_gcg:              /* look for .. */
X    (void) strncpy(sqs->seqnam,sqs->filnam,SQNAMEMAXLEN);
X    wlu_initlustrct(&gcglu,WLU_CASEDEP,SQFL_gcgunknown);
X    wlu_addwrd(&gcglu,"Length:",SQFL_gcglength,NULL);
X    wlu_addwrd(&gcglu,"Type:",SQFL_gcgtype,NULL);
X    wlu_addwrd(&gcglu,"..",SQFL_gcgdots,NULL);
X    wlu_maktoklu(&toklu[0]," \t\n");
X    while (wlu_gettoken(sqs->sfl,gcgwrd,33,&toklu[0]))
X      switch (wlu_chkwrd(&gcglu,gcgwrd))
X        {
X        case SQFL_gcgdots:      /* header scan completed ... */
X          wlu_clrlustrct(&gcglu);
X          return(1);
X          break;
X        case SQFL_gcglength:
X          fscanf(sqs->sfl,"%d",&sqs->slength);
X          break;
X        case SQFL_gcgtype:
X          if (wlu_gettoken(sqs->sfl,gcgwrd,33,&toklu[0]))
X            sqs->sqtos = sqfl_chr2tos(SFMT_gcg,gcgwrd[0]);
X          break;
X        case SQFL_gcgunknown:
X        default:
X          break;
X        }
X    wlu_clrlustrct(&gcglu);
X    return(0);              /* no .. by EOF, return false */
X    break;
X  case SFMT_staden:           /* do nothing - expect no header */
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    if (sqs->seqnam != NULL)
X      memfree(sqs->seqnam);
X    sqs->seqnam = bas_strdup(basename(sqs->filnam));
X    return(1);
X    break;
X  }
Xreturn(0);
X}
X
Xchar *sqfl_valid4fmt(SFMT_TYPE fmt)
X  /* return pointer to string of valid residues for fmt type of file.
X  This is written as case-independent - uppercase only being shown */
X{
Xswitch (fmt)
X  {
X  case SFMT_fasta:
X  case SFMT_nbrf:
X  case SFMT_molgen:
X    return("ABCDEFGHIJKLMNOPQRSTUVWXYZ-");
X    break;
X  case SFMT_gcg:
X    return("ABCDEFGHIJKLMNOPQRSTUVWXYZ*");
X    break;
X  case SFMT_staden:
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    return("ABCDEFGHIJKLMNOPQRSTUVWXYZ-1234567890*");
X    break;
X  }
X}  
X
Xchar sqfl_normfillc(SFMT_TYPE sf)
X  /* return the normal fill char used for this format */
X{
Xswitch (sf)
X  {
X  case SFMT_gcg:
X    return('N');
X    break;
X  case SFMT_fasta:
X  case SFMT_nbrf:
X  case SFMT_molgen:
X  case SFMT_staden:
X  case SFMT_undefined:
X  case SFMT_raw:
X  default:
X    return('-');
X    break;
X  }
X}
X
Xchar sqfl_getnxtres(SQFL_STRCT *sqs)
X  /* return the next valid residue from sqs.  EOF or non-alphanumeric
X   return NULL.  invalid chars are skipped */
X{
Xint nc;
XSQFL_SQTOPOL tc;
X
Xif ((nc = sqfl_fgetc(sqs->sfl)) == EOF)
X  return('\0');
Xelse
X  if (sqs->validlut[nc])
X    return(sqs->lstinchr = (char) nc);
X  else
X    {  /* may be topology char for molgen file, or end of nbrf/fasta, etc... */
X    switch (sqs->flfmt)
X      {
X      case SFMT_molgen:
X        if ((tc = sqfl_chr2topol(sqs->flfmt,(char) nc)) != SQTP_unknown)
X          {
X          sqs->stopol = tc;
X          return('\0');
X          }
X        break;
X      case SFMT_nbrf:
X      case SFMT_fasta:
X        switch ((char) nc)
X          {
X          case '*':       /* EOS char - may not be present tho */
X            sqs->lstinchr = '\0';
X            return('\0');
X            break;
X          case '>':       /* next entry - must note this */
X            sqs->lstinchr = '>';
X            return('\0');
X            break;
X          default:
X            sqs->lstinchr = nc;
X            break;
X            }
X        break;
X      case SFMT_staden:
X        if ((char) nc == '@')
X          return('\0');
X        break;
X      case SFMT_raw:
X        if (nc == EOF)
X          return('\0');
X        break;
X      case SFMT_gcg:
X      case SFMT_undefined:
X      default:
X        break;
X      }
X    return(sqfl_getnxtres(sqs));
X    }
X}
X
Xint loadsrcrng(SQFL_STRCT *sqs,
X               char *seqbuf,
X               int fstrt,
X               int fstop)
X/* read successive chars from sfl, write valid bases in fstrt..fstop into
X  seqbuf if it is not NULL.  fstrt&fstop are sequence positions (1..n)
X  Don't put in terminal null char.
X  return no of chars that would be inserted (whether stored or not) */
X{
Xchar *sp;
Xchar nb;
Xint sc;
Xint icnt;
X
Xicnt = sc = 0;
Xif (sqfl_skipsqflhdr(sqs))
X  {
X  sp = seqbuf;
X  while ((nb = sqfl_getnxtres(sqs)) != '\0')
X    if (++sc > fstop)
X      return(icnt);
X    else
X      if (sc >= fstrt)
X        {
X        if (seqbuf)
X          *sp++ = nb;
X        icnt++;
X        }
X  }
Xreturn(icnt);
X}
X
Xint loadsrcsq(SQFL_STRCT *sqs,
X              char *seqbuf)
X/* read successive chars from sfl, write valid bases into seqbuf if it is 
X  not NULL.  Don't put in terminal null char.
X  return highest position read (whether stored or not) */
X{
Xchar *sp;
Xchar nb;
Xint sc;
X
Xsc = 0;
Xif (sqfl_skipsqflhdr(sqs))
X  {
X  sp = seqbuf;
X  while ((nb = sqfl_getnxtres(sqs)) != '\0')
X    {
X    sc++;
X    if (seqbuf)
X      *sp++ = nb;
X    }
X  }
Xreturn(sc);
X}
X
Xvoid sqfl_clssqstrct(SQFL_STRCT *sqs)
X  /* close this sequence data structure, freeing the allocated memory */
X{
Xif (sqs != NULL)
X  {
X  if (sqs->sfl != NULL)
X    fclose(sqs->sfl);
X  if (sqs->gfl != NULL)
X    {      /* must close aux file and delete it */
X    fclose(sqs->gfl);
X    remove(sqs->gnam);
X    memfree(sqs->gnam);
X    }
X  if (sqs->thisuse != NULL)
X    memfree(sqs->thisuse);
X  if (sqs->filnam != NULL)
X    memfree(sqs->filnam);
X  if (sqs->seqnam != NULL)
X    memfree(sqs->seqnam);
X  if (sqs->annot != NULL)
X    memfree(sqs->annot);
X  memfree(sqs);
X  }
X}
X
Xvoid sqfl_clsstrctfil(SQFL_STRCT *sqs)
X  /* close the file component of *sqs, retaining other information */
X{
Xif (sqs != NULL)
X  if (sqs->sfl != NULL)
X    {
X    fclose(sqs->sfl);
X    sqs->sfl = NULL;
X    }
X}
X
XSQFL_STRCT *sqfl_creatsqstrctann(FILE *ufl,
X                                 char *fnam,
X                                 SFMT_TYPE sfmt,
X                                 char *myuse,
X                                 char *annotat)
X/* use an open sequence file fnam, returning pointer to a new structure
X  if successful.  NULL if not.
X  annotat is pointer to annotation string (most useful for output files) to
X  be used if non-NULL.  myuse is as for fopen */
X{
XSQFL_STRCT *sqs;
Xint cp;
Xchar *vld;
X
Xif (ufl == NULL)
X  return(NULL);
Xelse
X  {
X  sqs = (SQFL_STRCT *) getmemory(sizeof(SQFL_STRCT),
X                                   "Sequence data structure");
X  sqs->sfl = ufl;
X  sqs->flfmt = sfmt;
X  if (fnam == NULL)
X    sqs->filnam = bas_strdup("Null-name");
X  else
X    sqs->filnam = bas_strdup(fnam);
X  sqs->seqnam = (char *) getmemory((SQNAMEMAXLEN+1),"Seq name buffer");
X  sqs->stopol = SQTP_unknown;
X  sqs->sqtos = SQFL_tosunknown;
X  sqs->lstinchr = '\0';
X  sqs->lnlen = sqfl_linelength(sfmt);
X  vld = sqfl_valid4fmt(sfmt);
X  sqs->validlut[0] = 0;
X  sqs->gcgchksum = sqs->scnt = 0;
X  if (annotat != NULL)
X    {
X    sqs->annot = bas_strdup(annotat);
X    sqs->abuflen = strlen(sqs->annot) + 1;;
X    }
X  else
X    {
X    sqs->annot = (char *) getmemory((MAXPATHLEN + 1),"Annotation");
X    sqs->abuflen = MAXPATHLEN + 1;
X    *sqs->annot = '\0';
X    }
X  for (cp = 1; cp < MAXSQCHRVAL; cp++)
X    sqs->validlut[cp] = (index(vld,(char) cp) != NULL) ||
X                          (index(vld,toupper((char) cp)) != NULL);
X  sqs->gfl = NULL;
X  sqs->gnam = NULL;
X  sqs->thisuse = bas_strdup(myuse);
X  switch (sfmt)
X    {
X    case SFMT_gcg:
X      if (bas_sharchrs(sqs->thisuse,"w") != NULL)
X        {
X        sqs->gnam = (char *) getmemory((strlen(sqs->filnam)+2),
X                                         "Aux seq. file name");
X        *(sqs->gnam) = '\0';
X        (void) strcat(sqs->gnam,sqs->filnam);
X        (void) strcat(sqs->gnam,"_");
X        if ((sqs->gfl = fopen(sqs->gnam,"w+")) == NULL)
X          {
X          sqfl_clssqstrct(sqs);
X          return(NULL);
X          }
X        }
X      break;
X    case SFMT_nbrf:
X    case SFMT_fasta:
X    case SFMT_molgen:
X    case SFMT_raw:
X    default:
X      break;
X    }
X  return(sqs);
X  }
X}  
X
XSQFL_STRCT *sqfl_opnsqstrctann(char *fnam,
X                               SFMT_TYPE sfmt,
X                               char *myuse,
X                               char *annotat)
X/* attempt to open a sequence file fnam, returning pointer to a new structure
X  if successful.  NULL if not.  myuse is a normal parameter to fopen, though
X  it is likely that "r" and "w" are the most useful of them,
X  annotat is pointer to annotation string (most useful for output files) to
X  be used if non-NULL */
X{
XFILE *nf;
X
Xif (fnam == NULL)
X  return(NULL);
Xelse
X  if ((nf = fopen(fnam,myuse)) == NULL)
X    return(NULL);
X  else
X    return(sqfl_creatsqstrctann(nf,fnam,sfmt,myuse,annotat));
X}
X
XSQFL_STRCT *sqfl_opnsqstrct(char *fnam,
X                            SFMT_TYPE sfmt,
X                            char *myuse)
X/* attempt to open a sequence file fnam, returning pointer to a new structure
X  if successful.  NULL if not.  myuse is a normal parameter to fopen, though
X  it is likely that "r" and "w" are the most useful of them */
X{
Xreturn(sqfl_opnsqstrctann(fnam,sfmt,myuse,NULL));
X}  
X
XSQFL_STRCT *sqfl_opntoread(char *fnam,
X                           SFMT_TYPE sfmt)
X/* attempt to open a sequence file fnam for reading, returning pointer to a 
X  new structure if successful, NULL if not.  Perform header skipping, so
X  seq can be read directly */
X{
XSQFL_STRCT *sqs;
X
Xif ((sqs = sqfl_opnsqstrct(fnam,sfmt,"r")) != NULL)
X  if (sqfl_skipsqflhdr(sqs))
X    return(sqs);
X  else   /* bombed in skipping header, clear out sqs and return NULL */
X    {
X    sqfl_clssqstrct(sqs);
X    return(NULL);
X    }
Xelse
X  return(NULL);
X}  
X
Xvoid sqfl_rewind(SQFL_STRCT *sqs)
X{
Xif ((sqs != NULL) && (sqs->sfl != NULL))
X  rewind(sqs->sfl);
X}
X
Xint readsrcsq(SQFL_STRCT *sqs,
X              char *seqbuf)
X/* read successive chars from sqs, write valid bases into seqbuf if it is 
X  not NULL.
X  return highest position read (whether stored or not) */
X{
Xint sc;
X
Xsc = loadsrcsq(sqs,seqbuf);
Xif (seqbuf)
X  *(seqbuf+sc) = '\0';
Xreturn(sc);
X}
X
Xchar *sqfl_tos2strng(SQFL_SQTOS st)
X  /* return pointer to character string defining st */
X{
Xswitch (st)
X  {
X  case SQFL_dna:
X    return("Nucleic acid: DNA");
X    break;
X  case SQFL_rna:
X    return("Nucleic acid: RNA");
X    break;
X  case SQFL_peptide:
X    return("Peptide");
X    break;
X  case SQFL_tosunknown:
X  default:
X    return("unknown");
X    break;
X  }
X}
X
XSFMT_TYPE sqfl_prmpt4sfmt(SFMT_TYPE def,
X                          SFMT_TYPE rngex,
X                          SFMT_TYPE rngto)
X/* prompt for a sequence file format, offer default def, if defined */
X{
XSFMT_TYPE ff;
Xchar ubuf[9];
X
Xfor (ff = rngex; ff <= rngto; ff++)
X  {
X  fprintf(stdout,"%c=%s",sqfl_fmttp2chr(ff),sqfl_fmttp2strng(ff));
X  if (ff < rngto)
X    fputs(", ",stdout);
X  }
Xfputs("\nFile type ",stdout);
Xif (def != SFMT_undefined)
X  fprintf(stdout,"[%c] ",sqfl_fmttp2chr(def));
Xif (bas_ugetstr(">",&ubuf[0],8) <= 0)
X  return(def);
Xelse
X  if (((ff = sqfl_chr2fmttp(ubuf[0])) >= rngex) && (ff <= rngto))
X    return(ff);
X  else
X    {
X    fprintf(stdout,"No such sequence type: '%c'\n",ubuf[0]);
X    return(sqfl_prmpt4sfmt(def,rngex,rngto));
X    }
X}
X
Xchar *sqfl_defextnsns(SFMT_TYPE sf)
X  /* return a suggested extension for type sf */
X{
Xswitch (sf)
X  {
X  case SFMT_molgen:
X    return(".seq");
X    break;
X  case SFMT_nbrf:
X    return(".nbr");
X    break;
X  case SFMT_fasta:
X    return(".fst");
X    break;
X  case SFMT_gcg:
X    return(".gcg");
X    break;
X  case SFMT_raw:
X  case SFMT_undefined:
X  case SFMT_staden:
X  default:
X    return(".dat");
X    break;
X  }
X}
X
Xvoid sqfl_sfmts2bf(char *ubuf,
X                   int blim)
X/* write sfmt details to ubuf */
X{
XSFMT_TYPE sfp;
Xchar *bp;
X
Xbp = ubuf;
Xfor (sfp = SFMT_staden; (sfp <= SFMT_gcg) && ((bp - ubuf) < blim); sfp++)
X  {
X  if (sfp > SFMT_staden)
X    {
X    *bp++ = ',';
X    *bp++ = ' ';
X    }
X  *bp++ = sqfl_fmttp2chr(sfp);
X  *bp++ = '=';
X  *bp++ = '\0';
X  strcat(ubuf,sqfl_fmttp2strng(sfp));
X  while ((*bp != '\0') & ((bp - ubuf) < blim))
X    bp++;
X  }
X}
X
Xint sqfl_wrtsq2fl(SQFL_STRCT *sfl,
X                  char *ubuf,
X                  int blen,
X                  int *lcnt)
X/* put blen chars of ubuf as sequence to sfl file.  Return res count */
X{
Xchar *bp;
Xint rc;
X
Xbp = ubuf;
Xrc = *lcnt = 0;
Xwhile (rc <= blen)
X  {
X  sqfl_putres(sfl,*bp,rc,lcnt);
X  bp++;
X  rc++;
X  }
Xreturn(rc);
X}
X
Xint sqfl_wrtsqbuf2fl(SQFL_STRCT *sfl,
X                     char *sqnam,
X                     char *maker,
X                     char *origin,
X                     char *ubuf,
X                     int blen)
X/* write ubuf up to blen out to sfl, (previously opened).  Do headers & 
Xterminators.  Don't close sfl, leave to calling routine.  Return no res
Xwritten */
X{
Xint rc;
Xint lcnt;
X
Xsqfl_headsfstrct(sfl,sqnam,maker,origin);
Xrc = sqfl_wrtsq2fl(sfl,ubuf,blen,&lcnt);
Xsqfl_termsqfl(sfl,maker,&lcnt);
Xreturn(rc);
X}
END-of-meth_progs_dist/src/sqfl_fns.c
echo x - meth_progs_dist/src/sqmat_fns.c
sed 's/^X//' >meth_progs_dist/src/sqmat_fns.c << 'END-of-meth_progs_dist/src/sqmat_fns.c'
X/* sqmat_fns.c: sequence matching functions */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <ctype.h>
X
X#include "bas_fns.h"
X#include "sqmat_fns.h"
X
Xchar case_mirror(char nc,
X                 char casepat)
X/* return nc in same case as casepat */
X{
Xif (isupper((int) casepat))
X  return((char) toupper((int) nc));
Xelse
X  if (islower((int) casepat))
X    return((char) tolower((int) nc));
X  else
X    return(nc);
X}
X
Xchar ssd_bascmplmnt(char bs,
X                    BAS_MATMODE mmod)
X/* return the complementary base to bs, depending on mmod */
X{
Xchar cb;
X
Xswitch (mmod)
X  {
X  case BAS_iub:
X    if ((cb = ssd_bascmplmnt(bs,BAS_exact)) != '-')
X      return(cb);
X    else
X      switch (tolower(bs))
X        {
X        case 'r':
X          return(case_mirror('Y',bs));
X          break;
X        case 'y':
X          return(case_mirror('r',bs));
X          break;
X        case 'm':
X          return(case_mirror('k',bs));
X          break;
X        case 'k':
X          return(case_mirror('m',bs));
X          break;
X        case 'n':
X        case 's':
X        case 'w':
X        case '-':
X          return(bs);
X          break;
X        case 'h':
X          return(case_mirror('d',bs));
X        case 'b':
X          return(case_mirror('v',bs));
X        case 'v':
X          return(case_mirror('b',bs));
X        case 'd':
X          return(case_mirror('h',bs));
X        default:
X          return('-');
X        }
X    break;
X  case BAS_ldna:
X    if ((cb = ssd_bascmplmnt(bs,BAS_exact)) != '-')
X      return(cb);
X    else
X      switch (tolower(bs))
X        {
X        case 'r':
X          return(case_mirror('Y',bs));
X          break;
X        case 'y':
X          return(case_mirror('r',bs));
X          break;
X        case 'h':
X          return(case_mirror('q',bs));
X          break;
X        case 'q':
X          return(case_mirror('h',bs));
X          break;
X        case 'p':
X        case 's':
X        case '-':
X          return(bs);
X          break;
X        case 'k':
X          return(case_mirror('l',bs));
X          break;
X        case 'l':
X          return(case_mirror('k',bs));
X          break;
X        case 'm':
X          return(case_mirror('j',bs));
X          break;
X        case 'j':
X          return(case_mirror('m',bs));
X          break;
X        default:
X          return('-');
X          break;
X        }
X    break;
X  case BAS_exact:
X  default:
X    switch (tolower(bs))
X      {
X      case 'a':
X        return(case_mirror('T',bs));
X        break;
X      case 'c':
X        return(case_mirror('G',bs));
X        break;
X      case 'g':
X        return(case_mirror('C',bs));
X        break;
X      case 't':
X      case 'u':
X        return(case_mirror('A',bs));
X        break;
X      default:
X        return('-');
X        break;
X      }
X    break;
X  }
X}
X
Xchar same_residue(char bas,
X                  BAS_MATMODE dummy)
X/* return bas */
X{
Xreturn(bas);
X}
X
Xvoid reverse_seq(char *sq,
X                 int sqlen,
X                 char (* cmpfun)(char xres,
X                                 BAS_MATMODE xmod),
X                 BAS_MATMODE mmod)
X/* reverse sq character order, apply
Xcmpfun to each transfer */
X{
Xchar *hipt;
Xchar *lopt;
Xchar schr;
X
Xlopt = sq;
Xhipt = sq + sqlen - 1;
Xwhile (hipt >= lopt)
X  {
X  schr = *hipt;
X  *hipt-- = (* cmpfun)(*lopt,mmod);
X  *lopt++ = (* cmpfun)(schr,mmod);
X  }
X}
X
Xvoid complmnt_seq(char *sq,
X                  int sqlen,
X                  BAS_MATMODE mmod)
X/* reverse&complement the contents of sq, depending on mmod */
X{
Xreverse_seq(sq,sqlen,ssd_bascmplmnt,mmod);
X}
X
Xint ssd_bas2bit(char bas)
X/* return a bit map representing bas with A=bit 1, C=2, G=3 & T=4,
X otherwise 0 */
X{
Xswitch ((char) tolower((int) bas))
X  {
X  case 'a':
X    return(1);
X    break;
X  case 'c':
X    return(2);
X    break;
X  case 'g':
X    return(4);
X    break;
X  case 't':
X  case 'u':
X    return(8);
X    break;
X  default:
X    return(0);
X    break;
X  }
X}
X
Xint ssd_bits4basechr(char bas,
X                     BAS_MATMODE mmod)
X/* return a bit map representing bas with A=bit 1, C=2, G=3 & T=4 and
X  bits set for redundant specs, as for mmod */
X{
Xint bret;
X
Xif (bret = ssd_bas2bit(bas))  /* if A,C,G,T/U return value right away */
X  return(bret);
Xelse
X  switch (mmod)               /* not A,C,B,T/U - combine bits */
X    {
X    case BAS_exact:
X      return(0);
X      break;
X    case BAS_iub:
X      switch (toupper(bas))
X        {
X        case 'R':
X          return(ssd_bas2bit('a') | ssd_bas2bit('g'));
X          break;
X        case 'Y':
X          return(ssd_bas2bit('c') | ssd_bas2bit('t'));
X          break;
X        case 'M':
X          return(ssd_bas2bit('a') | ssd_bas2bit('c'));
X          break;
X        case 'K':
X          return(ssd_bas2bit('g') | ssd_bas2bit('t'));
X          break;
X        case 'S':
X          return(ssd_bas2bit('c') | ssd_bas2bit('g'));
X          break;
X        case 'W':
X          return(ssd_bas2bit('a') | ssd_bas2bit('t'));
X          break;
X        case 'H':
X          return(ssd_bas2bit('a') | ssd_bas2bit('c') | ssd_bas2bit('t'));
X          break;
X        case 'B':
X          return(ssd_bas2bit('c') | ssd_bas2bit('g') | ssd_bas2bit('t'));
X          break;
X        case 'V':
X          return(ssd_bas2bit('a') | ssd_bas2bit('c') | ssd_bas2bit('g'));
X          break;
X        case 'D':
X          return(ssd_bas2bit('a') | ssd_bas2bit('g') | ssd_bas2bit('t'));
X          break;
X        case 'N':
X        case '-':
X          return(ssd_bas2bit('a') | ssd_bas2bit('g') | ssd_bas2bit('t') |
X                   ssd_bas2bit('c'));
X          break;
X        default:
X          return(0);
X          break;
X        }
X      break;
X    case BAS_ldna:
X      switch (toupper(bas))
X        {
X        case 'R':
X          return(ssd_bas2bit('a') | ssd_bas2bit('g'));
X          break;
X        case 'Y':
X          return(ssd_bas2bit('c') | ssd_bas2bit('t'));
X          break;
X        case 'S':
X          return(ssd_bas2bit('a') | ssd_bas2bit('c'));
X          break;
X        case 'H':
X          return(ssd_bas2bit('g') | ssd_bas2bit('t'));
X          break;
X        case 'Q':
X          return(ssd_bas2bit('c') | ssd_bas2bit('g'));
X          break;
X        case 'P':
X          return(ssd_bas2bit('a') | ssd_bas2bit('t'));
X          break;
X        case 'L':
X          return(ssd_bas2bit('a') | ssd_bas2bit('c') | ssd_bas2bit('t'));
X          break;
X        case 'J':
X          return(ssd_bas2bit('c') | ssd_bas2bit('g') | ssd_bas2bit('t'));
X          break;
X        case 'M':
X          return(ssd_bas2bit('a') | ssd_bas2bit('c') | ssd_bas2bit('g'));
X          break;
X        case 'K':
X          return(ssd_bas2bit('a') | ssd_bas2bit('g') | ssd_bas2bit('t'));
X          break;
X        case 'N':
X        case '-':
X          return(ssd_bas2bit('a') | ssd_bas2bit('g') | ssd_bas2bit('t') |
X                   ssd_bas2bit('c'));
X          break;
X        default:
X          return(0);
X          break;
X        }
X      break;
X    default:
X      return(0);
X      break;
X    }
X}
X
Xint ssd_basmatch(char b1,
X                 char b2,
X                 BAS_MATMODE mmod)
X/* return 1 if b1 matches b2, given match strategy mmod. case-independent */
X{
Xchar lb1;
Xchar lb2;
X
Xif ((lb1 = (char) tolower((int) b1)) == (lb2 = (char) tolower((int) b2)))
X  return(1);
Xelse
X  switch (mmod)
X    {
X    case BAS_iub:
X    case BAS_ldna:
X      return((ssd_bits4basechr(lb1,mmod) & ssd_bits4basechr(lb2,mmod)) != 0);
X      break;
X    case BAS_exact:
X    default:
X      return(0);
X      break;
X    }
X}
X
Xchar *ssd_nxtbasmatch(char *seq,
X                      char bas,
X                      BAS_MATMODE mmod)
X/* return a pointer to the next occurrence of bas in seq.  NULL if none */
X{
Xchar *sp;
X
Xif (sp = seq)
X  {
X  while (*sp != '\0')
X    if (ssd_basmatch(*sp,bas,mmod))
X      return(sp);
X    else
X      sp++;
X  return(NULL);
X  }
Xelse
X  return(NULL);
X}
X
Xchar *ssd_prvbasmatch(char *seq,
X                      char *spos,
X                      char bas,
X                      BAS_MATMODE mmod)
X/* return a pointer to the previous occurrence of bas in seq, starting 
Xfrom spos.  NULL if none */
X{
Xchar *sp;
X
Xif (sp = spos)
X  {
X  while (sp >= seq)
X    if (ssd_basmatch(*sp,bas,mmod))
X      return(sp);
X    else
X      sp--;
X  return(NULL);
X  }
Xelse
X  return(NULL);
X}
X
Xchar *ssd_nxtstrmatch(char *seq,
X                      char *pat,
X                      BAS_MATMODE mmod)
X/* return the position of the next match of pat in seq. NULL if not found */
X{
Xchar *sp;
Xchar *pp;
Xchar *s;
Xchar *sstr;
X
Xpp = pat;
Xsp = seq;
Xwhile (sstr = s = ssd_nxtbasmatch(sp,*pp++,mmod))
X  {
X  s++;
X  while ((*pp != '\0') && (*s != '\0') && (ssd_basmatch(*s,*pp,mmod)))
X    {
X    pp++;
X    s++;
X    }
X  if (*pp == '\0') /* found a match, return sp */
X    return(sstr);
X  else
X    if (*s == '\0') /* ran out of seq, return NULL */
X      return(NULL);
X    else            /* base mismatch, reset and continue */
X      {
X      sp = sstr + 1;
X      pp = pat;
X      }
X  }
Xreturn(NULL);  /* no match if got here, return NULL */
X}
X
Xchar *ssd_prvstrmatch(char *seq,
X                      int sqlen,
X                      int startpos,
X                      char *pat,
X                      BAS_MATMODE mmod)
X/* return the position of the next match of pat in seq. NULL if not found */
X{
Xchar *sp;
Xchar *pp;
Xchar *s;
Xchar *sstr;
X
Xpp = pat;
Xsp = seq + startpos - 1;
Xwhile (sstr = s = ssd_prvbasmatch(seq,sp,*pp++,mmod))
X  {
X  s++;
X  while ((*pp != '\0') && (*s != '\0') && (ssd_basmatch(*s,*pp,mmod)))
X    {
X    pp++;
X    s++;
X    }
X  if (*pp == '\0') /* found a match, return sp */
X    return(sstr);
X  else
X    if (*s == '\0') /* ran out of seq, reset and continue, if start in seq */
X      if (s >= seq)
X        {
X        sp = sstr - 1;
X        pp = pat;
X        }
X      else
X        return(NULL);
X    else            /* base mismatch, reset and continue */
X      {
X      sp = sstr - 1;
X      if (sp < seq)
X        return(NULL);
X      pp = pat;
X      }
X  }
Xreturn(NULL);  /* no match if got here, return NULL */
X}
X
Xint ssd_nxtmatchpos(char *seq,
X                    int sqlen,
X                    int curpos,
X                    char *pat,
X                    BAS_MATMODE mmod,
X                    int srchfwd)
X/* return the sequence position of next match after curpos of pat in seq.
X  0 if not found.  If string starts with '#' then try to read rest of
Xstring as an integer value and return that */
X{
Xchar *nxt;
Xint npos;
X
Xif (curpos <= sqlen)
X  {
X  if (*pat == '#')   /* numerical argument, decode it and return if valid */
X    {
X    npos = atoi(pat+1);
X    if ((npos <= sqlen) && (npos > 0))
X      return(npos);
X    else
X      return(0);
X    }
X  else
X    {
X    if (srchfwd)
X      nxt = ssd_nxtstrmatch((seq+curpos-1),pat,mmod);
X    else
X      nxt = ssd_prvstrmatch(seq,sqlen,curpos,pat,mmod);
X    if (nxt)
X      if (((npos = (int) (nxt - seq + 1)) <= sqlen) && (npos > 0))
X        return(npos);
X      else
X        return(0);      /* spurious match outside seq */
X    else
X      return(0);
X    }
X  }
Xelse
X  return(0);
X}
X
Xint ssd_bitcnt4bas(char ares,
X                   BAS_MATMODE mmod)
X/* count up the bits set for ares (i.e. no bases it represents) */
X{
Xint bv;
Xint ccnt;
Xint msk;
Xint bc;
X
Xbv = ssd_bits4basechr(ares,mmod);
Xccnt = 0;
Xmsk = 1;
Xbc = 0;
Xwhile (bc <= 3)
X  {
X  if (bv & msk)
X    ccnt++;
X  msk = msk << 1;
X  bc++;
X  }
Xreturn(ccnt);
X}
END-of-meth_progs_dist/src/sqmat_fns.c
echo x - meth_progs_dist/src/tidyrrnams.awk
sed 's/^X//' >meth_progs_dist/src/tidyrrnams.awk << 'END-of-meth_progs_dist/src/tidyrrnams.awk'
X# tidyrrnams.awk: script to correct chromosome names for rmap bed files
X# and other files with similar issues
X#
X# use:
X# awk -f <path>tidyrrnams.awk splitfield=<n> <src_file>
X#
X# splitfield def = 1
X#
XBEGIN { splitpos=1; splitfield=1; \
X#  if (FILENAME=="") \
X#    { \
X#    printf("use:\n"); \
X#    printf("awk splitfield=<n> -f <path>tidyrrnams.awk <src_file>\n"); \
X#    printf("  where splitfield is the field to process, def = 1\n"); \
X#    } \
X  }
X{ \
Xsplit($splitfield,cnam,"r"); \
X  for (i=1; i<= NF; i++) \
X    if (i==splitfield) \
X      printf("%s%s",((i==1)?"":"\t"),cnam[splitpos]); \
X    else \
X      printf("%s%s",((i==1)?"":"\t"),$i); \
Xprintf("\n"); \
X}
X
X
END-of-meth_progs_dist/src/tidyrrnams.awk
echo x - meth_progs_dist/src/wlu_fns.c
sed 's/^X//' >meth_progs_dist/src/wlu_fns.c << 'END-of-meth_progs_dist/src/wlu_fns.c'
X/* wlu_fns.c: fast word lookup functions for various purposes */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X#include "bas_fns.h"
X#include "sqfl_fns.h"
X#include "wlu_fns.h"
X
Xint wlu_init2offst(int cased,
X                   char initc)
X/* return a numerical offset for initc, depending on
X cased:  0 => case depend, 1 case independ, -1 wild card */
X{
Xswitch (cased)
X  {
X  case WLU_CASEIND:
X  case WLU_CASEWILD:
X    if (islower(initc))         /* lowercase, upcase it */
X      return(wlu_init2offst(cased,(char) toupper(initc)));
X    else
X       if (isupper(initc))
X         return((int) initc - 'A' + 1);
X       else   /* other */
X         return(0);
X    break;
X  case WLU_CASEDEP:       /* 0,A..Z,a..z counted */
X  default:
X    if (isalpha(initc))
X      if (isupper(initc))
X        return((int) initc - 'A' + 1);
X      else
X        return(wlu_init2offst(cased,(char) toupper(initc)) +
X                 wlu_init2offst(cased,'Z'));
X    else
X      return(0);
X    break;
X  }
X}
X
Xint wlu_no_inits(int cased)
X  /* return the number of initials for
X  cased: 0 => case depend, 1 case independ, -1 wild card */
X{
Xreturn(wlu_init2offst(cased,'z')+1);
X}
X
Xvoid wlu_initlustrct(WRD_LUSTRCT *wlus,
X                     int cased,
X                     int failval)
X/*  init wlus values prior to loading words
X  cased: 0 => case depend, 1 case independ, -1 wild card */
X{
Xint ninits;
Xint wp;
XWRD_LU_REC **lp;
XWRD_LU_REC **fp;
X
Xwlus->casedep = cased;
Xwlus->failret = failval;
Xninits = wlu_no_inits(cased);
Xfp = wlus->firstlet = (WRD_LU_REC **)
X                           getmemory(((ninits+1)*sizeof(WRD_LU_REC *)),
X                                       "Word first letter look up table");
Xlp = wlus->lastlet = (WRD_LU_REC **)
X                           getmemory(((ninits+1)*sizeof(WRD_LU_REC *)),
X                                       "Word last letter look up table");
Xfor (wp = 0; wp < ninits; wp++)
X  {
X  *(fp++) = NULL;
X  *(lp++) = NULL;
X  }
X}
X
Xvoid wlu_killwelt(WRD_LU_REC *rp)
X  /* kill this element, lose storage associated with it.  This does not
Xchange forward links - that must be handled by calling routine */
X{
Xmemfree(rp->wrd);
Xif (rp->helpline != NULL)
X  memfree(rp->helpline);
Xmemfree(rp);
X}
X
Xvoid wlu_clrlustrct(WRD_LUSTRCT *wlu)
X  /* relinquish malloced memory for wlu lists */
X{
Xint lp;
Xint lmax;
XWRD_LU_REC *rp;
XWRD_LU_REC *np;
X
Xif (wlu != NULL)
X  {                   /* free all allocated word records */
X  lmax = wlu_no_inits(wlu->casedep);
X  for (lp = 0; lp < lmax; lp++)
X    {
X    rp = *(wlu->firstlet+lp);
X    while (rp != NULL)
X      {
X      np = rp->nextiwrd;
X      wlu_killwelt(rp);
X      rp = np;
X      }
X    }
X  memfree(wlu->firstlet);       /* free arrays of starts */
X  wlu->firstlet = NULL;
X  memfree(wlu->lastlet);        /* free arrays of stops */
X  wlu->lastlet = NULL;
X  }
X}
X
Xvoid wlu_clralllustrct(WRD_LUSTRCT *wlu)
X  /* relinquish malloced memory for wlu lists and wlu itself */
X{
Xif (wlu != NULL)
X  {                   /* free all allocated word records */
X  wlu_clrlustrct(wlu);
X  memfree(wlu);                 /* free the thing itself - late change!! */
X  }
X}
X
Xvoid wlu_addwrdptr(WRD_LUSTRCT *wlus,
X                   char *newwrd,
X                   void *newval,
X                   char *hlpline)
X/* add newwrd to lookup structure.  No check is performed for multiple
X  insertions */
X{
Xint offst;
XWRD_LU_REC *newrec;
X
Xoffst = wlu_init2offst(wlus->casedep,*newwrd);
Xnewrec = (WRD_LU_REC *) getmemory(sizeof(WRD_LU_REC),
X                                    "New word lookup element");
Xnewrec->wrd = bas_strdup(newwrd);
Xnewrec->retval = newval;
Xnewrec->nextiwrd = NULL;
Xif (hlpline != NULL)
X  newrec->helpline = bas_strdup(hlpline);
Xelse
X  newrec->helpline = NULL;
Xif ((*(wlus->lastlet+offst)) == NULL) /* haven't seen this one before */
X  (*(wlus->firstlet+offst)) = (*(wlus->lastlet+offst)) = newrec;
Xelse
X  {
X  (*(wlus->lastlet+offst))->nextiwrd = newrec;
X  *(wlus->lastlet+offst) = newrec;
X  }
X}
X
Xvoid wlu_addwrd(WRD_LUSTRCT *wlus,
X                char *newwrd,
X                int newval,
X                char *hlpline)
X/* add newwrd to lookup structure.  No check is performed for multiple
X  insertions */
X{
Xwlu_addwrdptr(wlus,newwrd,(void *) ((long) newval),hlpline);
X}
X
Xvoid wlu_addintgrs(WRD_LUSTRCT *wlus,
X                   int newint,
X                   int newval,
X                   char *hlpline)
X/* add newint as a string to lookup structure, returning newval.
X  No check is performed for multiple insertions */
X{
Xchar nbuf[33];
X
Xsprintf(&nbuf[0],"%d",newint);
Xwlu_addwrd(wlus,&nbuf[0],newval,hlpline);
X}
X
Xvoid wlu_addintgr(WRD_LUSTRCT *wlus,
X                  int newval,
X                  char *hlpline)
X/* add newval as a string to lookup structure, returning newval.
X  No check is performed for multiple insertions */
X{
Xwlu_addintgrs(wlus,newval,newval,hlpline);
X}
X
Xint wlu_cntwldmats(WRD_LU_REC *wrpt,
X                   char *uwrd,
X                   int wlen)
X/* return count of words which match this one upto wlen chars in linked
X  list wrpt */
X{
Xint wc;
X
Xwc = 0;
Xwhile (wrpt != NULL)
X  {
X  if (strncasecmp(uwrd,wrpt->wrd,(size_t) wlen) == 0)
X    wc++;
X  wrpt = wrpt->nextiwrd;
X  }
Xreturn(wc);
X}
X
XWRD_LU_REC *wlu_lulst4wrd(WRD_LUSTRCT *wlus,
X                          char *uwrd)
X/* return the start of the list containing this word */
X{
Xreturn(*(wlus->firstlet+wlu_init2offst(wlus->casedep,*uwrd)));
X}
X
XWRD_LU_REC *wlu_lurec4wrd(WRD_LUSTRCT *wlus,
X                          WRD_LU_REC *wlst,
X                          char *uwrd)
X/* scan wlst for uwrd, return the first match found, NULL if not */
X{
XWRD_LU_REC *wp;
Xint ulen;
X
Xwp = wlst;
Xif (wlus->casedep == WLU_CASEWILD)
X  ulen = strlen(uwrd);
Xwhile (wp != NULL)
X  {
X  switch (wlus->casedep)
X    {
X    case WLU_CASEIND:
X      if (strcasecmp(uwrd,wp->wrd) == 0)    /* found it */
X        return(wp);
X      break;
X    case WLU_CASEWILD:         /* wild - check if unique */
X      if (strncasecmp(uwrd,wp->wrd,(size_t) ulen) == 0)
X        if (wlu_cntwldmats(wp,uwrd,ulen) > 1)
X          return(NULL);
X        else
X          return(wp);
X      break;        
X    case WLU_CASEDEP:
X    default:
X      if (strcmp(uwrd,wp->wrd) == 0)      /* found it */
X        return(wp);
X      break;
X    }
X  wp = wp->nextiwrd;
X  }
Xreturn(NULL);
X}
X
XWRD_LU_REC *wlu_wrd2lurec(WRD_LUSTRCT *wlus,
X                          char *uwrd)
X/* return the pointer to the lu_rec for uwrd, NULL if non-existent */
X{
Xreturn(wlu_lurec4wrd(wlus,wlu_lulst4wrd(wlus,uwrd),uwrd));
X}
X
Xvoid *wlu_chkwrdptr(WRD_LUSTRCT *wlus,
X                    char *uwrd)
X/* check for uwrd in wlus word look up structure.  if not found return NULL
Xvalue else return the set parameter.  word comparisons are based on case
X  dependency setting */
X{
XWRD_LU_REC *wrpt;
X
Xif ((wrpt = wlu_wrd2lurec(wlus,uwrd)) != NULL)
X  return(wrpt->retval);
Xelse
X  return(NULL);  /* not found */
X}
X
Xint wlu_chkwrd(WRD_LUSTRCT *wlus,
X               char *uwrd)
X/* check for uwrd in wlus word look up structure.  if not found return failret
Xvalue else return the set parameter.  word comparisons are based on case
X  dependency setting */
X{
XWRD_LU_REC *wrpt;
X
Xif ((wrpt = wlu_wrd2lurec(wlus,uwrd)) != NULL)
X  return((int)((long) wrpt->retval));
Xelse
X  return(wlus->failret);  /* not found */
X}
X
Xint wlu_chkint(WRD_LUSTRCT *wlus,
X               int uvl)
X/* check for uvl in wlus word look up structure. */
X{
Xchar nbuf[33];
X
Xsprintf(&nbuf[0],"%d",uvl);
Xreturn(wlu_chkwrd(wlus,&nbuf[0]));
X}
X
Xvoid wlu_maktoklu(WLU_CHRLUTBL utbl,
X                  char *luchrs)
X  /* allocate and create a character look up table (7 bit ascii only),
X with chars in luchrs */
X{
Xint cp;
X
Xfor (cp = 0; cp <= MAXASCIIVAL; cp++)
X  utbl[cp] = (index(luchrs,(char) cp) != NULL);
X}
X
Xvoid wlu_makcmptoklu(WLU_CHRLUTBL utbl,
X                     char *luchrs)
X/* create a character look up table (7 bit ascii only),
Xfor chars NOT in luchrs */
X{
Xint cp;
X
Xwlu_maktoklu(utbl,luchrs);
Xfor (cp = 0; cp <= MAXASCIIVAL; cp++)
X  utbl[cp] = !utbl[cp];
X}
X
Xint wlu_gettokensep(FILE *fl,
X                    char *ubuf,
X                    int blen,
X                    WLU_CHRLUTBL stbl,
X                    char *schr)
X/* pull next token from fl, write into ubuf, upto blen.  sbtl is a 
Xtable of ascii values of token separators. if *schr non-NULL, then set it
Xto the separating char */
X{
Xint nc;
Xchar *tp;
Xint bl;
X
Xtp = ubuf;
Xwhile ((nc = fgetc(fl)) != EOF)
X  if (stbl[nc])     /* have a token separator */
X    {
X    if ((bl = (int) (tp - ubuf)) > 0)    /* does separate something */
X      {
X      if (bl < blen)
X        *tp = '\0';         /* room for null, put it in */
X      if (schr != NULL)
X        *schr = (char) nc;
X      return(bl);
X      }
X    }
X  else                      /* wasn't separator, try to fit it in */
X    if ((bl = (int)(tp - ubuf)) >= blen)  /* full, return anyway */
X      {
X      if (schr != NULL)
X        *schr = '\0';
X      return(bl);
X      }
X    else
X      *tp++ = (char) nc;
Xif ((bl = (int)(tp - ubuf)) < blen)
X  *tp = '\0';
Xif (schr != NULL)
X  *schr = '\0';
Xreturn(bl);
X}
X
Xint wlu_gettoken(FILE *fl,
X                 char *ubuf,
X                 int blen,
X                 WLU_CHRLUTBL stbl)
X/* pull next token from fl, write into ubuf, upto blen.  sbtl is a 
Xtable of ascii values of token separators */
X{
Xreturn(wlu_gettokensep(fl,ubuf,blen,stbl,NULL));
X}
X
Xint wlu_sgettokensep(char *src,
X                     int *sp,
X                     char *ubuf,
X                     int blen,
X                     WLU_CHRLUTBL stbl,
X                     char *schr)
X/* pull next token from src at *sp, write into ubuf, upto blen.  *sp is
Xincremented.  sbtl is a 
Xtable of ascii values of token separators. if *schr non-NULL, then set it
Xto the separating char */
X{
Xchar nc;
Xchar *tp;
Xint bl;
X
Xtp = ubuf;
Xwhile ((nc = *(src+*sp)) != '\0')
X  {
X  (*sp)++;
X  if (stbl[(int) nc])     /* have a token separator */
X    {
X    if ((bl = (int)(tp - ubuf)) > 0)    /* does separate something */
X      {
X      if (bl < blen)
X        *tp = '\0';         /* room for null, put it in */
X      if (schr != NULL)
X        *schr = nc;
X      return(bl);
X      }
X    }
X  else                      /* wasn't separator, try to fit it in */
X    if ((bl = (int)(tp - ubuf)) >= blen)  /* full, return anyway */
X      {
X      if (schr != NULL)
X        *schr = '\0';
X      return(bl);
X      }
X    else
X      *tp++ = nc;
X  }
Xif ((bl = (int)(tp - ubuf)) < blen)
X  *tp = '\0';
Xif (schr != NULL)
X  *schr = '\0';
Xreturn(bl);
X}
X
Xint wlu_sgettoken(char *src,
X                  int *sp,
X                  char *ubuf,
X                  int blen,
X                  WLU_CHRLUTBL stbl)
X/* pull next token from src at *sp (incremented), write into ubuf, 
X  upto blen.  sbtl is a 
X  table of ascii values of token separators */
X{
Xreturn(wlu_sgettokensep(src,sp,ubuf,blen,stbl,NULL));
X}
X
Xint wlu_newstrng(WRD_LUSTRCT *wlus,
X                 char *swrd,
X                 char *newlin)
X/* insert newlin in place of existing (if any) text line for swrd.  Return
X1 if OK, 0 if swrd is not in wlus */
X{
XWRD_LU_REC *wrpt;
X
Xif ((wrpt = wlu_wrd2lurec(wlus,swrd)) == NULL)
X  return(0);
Xelse
X  {
X  if (wrpt->helpline != NULL)
X    memfree(wrpt->helpline);
X  wrpt->helpline = bas_strdup(newlin);
X  return(1);
X  }
X}
X
Xint wlu_newstr4int(WRD_LUSTRCT *wlus,
X                   int sint,
X                   char *newlin)
X/* insert newlin in place of existing (if any) text line for sint.  Return
X1 if OK, 0 if swrd is not in wlus */
X{
Xchar is[33];
X
Xsprintf(&is[0],"%d",sint);
Xreturn(wlu_newstrng(wlus,&is[0],newlin));
X}
X
Xint wlu_delwrd(WRD_LUSTRCT *wlus,
X               char *swrd)
X/* delete the first entry related to swrd from *wlus, return 1 if found &
Xdeleted */
X{
XWRD_LU_REC *wrpt;
XWRD_LU_REC *prvp;
XWRD_LU_REC *lpt;
X
Xif ((wrpt = wlu_wrd2lurec(wlus,swrd)) == NULL)
X  return(0);
Xelse
X  {
X  lpt = wlu_lulst4wrd(wlus,swrd);
X  if (wrpt == lpt)              /* is first element */
X    {
X    if ((*(wlus->firstlet+wlu_init2offst(wlus->casedep,*swrd)) =
X                                              wrpt->nextiwrd) == NULL)
X      *(wlus->lastlet+wlu_init2offst(wlus->casedep,*swrd)) = NULL;
X    wlu_killwelt(wrpt);
X    return(1);
X    }
X  else
X    {
X    prvp = lpt;
X    while (prvp != NULL)
X      if (prvp->nextiwrd == wrpt)         /* have prv */
X        {
X        if ((prvp->nextiwrd = wrpt->nextiwrd) == NULL)  /* is last elt */
X          *(wlus->lastlet+wlu_init2offst(wlus->casedep,*swrd)) = prvp;
X        wlu_killwelt(wrpt);
X        return(1);
X        }
X      else
X        prvp = prvp->nextiwrd;
X    return(0);            /* got to end of list without finding previous!! */
X    }  
X  }
X}
X
Xint wlu_delint(WRD_LUSTRCT *wlus,
X               int di)
X/* delete the first entry related to int di from *wlus, return 1 if found &
Xdeleted */
X{
Xchar nbuf[33];
X
Xsprintf(&nbuf[0],"%d",di);
Xreturn(wlu_delwrd(wlus,&nbuf[0]));
X}
X
XWRD_LUSTRCT *wlu_getmnthwrds()
X  /* return a wlu table that will convert 3 letter month names into
Xcorresponding integers in case-independent manner */
X{
XWRD_LUSTRCT *ws;
Xint mpt;
X
Xws = (WRD_LUSTRCT *) getmemory(sizeof(WRD_LUSTRCT),"Month word lu struct");
Xwlu_initlustrct(ws,WLU_CASEIND,0);
Xfor (mpt = 1; mpt <= 12; mpt++)
X  wlu_addwrd(ws,bas_int2strmnth(mpt,1),1,NULL);
Xreturn(ws);
X}
X
Xvoid wlu_dsplymenu(FILE *fl,
X                   WRD_LUSTRCT *menu)
X/* display the existing contents of *menu */
X{
Xint ap;  /* alpha pointer */
XWRD_LU_REC *wlpt;
Xint ninits;
X
Xap = 0;
Xninits = wlu_no_inits(menu->casedep);
Xwhile (ap < ninits)
X  {
X  wlpt = *(menu->firstlet+ap);
X  while (wlpt != NULL)
X    {
X    if (wlpt->helpline != NULL)
X      fprintf(fl,"    %s - %s\n",wlpt->wrd,wlpt->helpline);
X    wlpt = wlpt->nextiwrd;
X    }
X  ap++;
X  }
X}
X
Xvoid wlu_dbgwlustrct(FILE *fl,
X                     WRD_LUSTRCT *menu,
X                     char *msg)
X/* tell fl about contents of *menu for diagnostic purposes */
X{
Xint ap;  /* alpha pointer */
XWRD_LU_REC *wlpt;
Xint ninits;
X
Xap = 0;
Xfprintf(fl,"%s:@%lx:",(msg==NULL?"":msg),(long) menu);
Xfflush(fl);
Xninits = wlu_no_inits(menu->casedep);
Xfprintf(fl,"casedep=%d,fail=%d,initials=%d\n",menu->casedep,menu->failret,
X          ninits);
Xfflush(fl);
Xwhile (ap < ninits)
X  {
X  wlpt = *(menu->firstlet+ap);
X  fprintf(fl,"ap=%d:@%lx:",ap,(long) wlpt);
X  fflush(fl);
X  while (wlpt != NULL)
X    {
X    fprintf(fl,"@%lx:",(long) wlpt);
X    fflush(fl);
X    fprintf(fl,"%lx\"%s\"",(long) wlpt->wrd,(wlpt->wrd==NULL?"<NULL>":wlpt->wrd));
X    fflush(fl);
X    if (wlpt->helpline != NULL);
X      fputs("...",fl);
X    if ((wlpt = wlpt->nextiwrd) != NULL)
X      fputc(',',fl);
X    fflush(fl);
X    }
X  ap++;
X  fputc('\n',fl);
X  fflush(fl);
X  }
X}
X
Xint wlu_maxwrdlen(WRD_LUSTRCT *wlus)
X  /* return the length of the longest string in wlus */
X{
Xint mxlen;
Xint ap;
Xint ninits;
XWRD_LU_REC *wp;
Xint slen;
X
Xmxlen = 0;
Xap = 0;
Xninits = wlu_no_inits(wlus->casedep);
Xwhile (ap < ninits)
X  {
X  wp = *(wlus->firstlet+ap++);
X  while (wp != NULL)
X    {
X    if ((slen = strlen(wp->wrd)) > mxlen)
X      mxlen = slen;
X    wp = wp->nextiwrd;
X    }
X  }
Xreturn(mxlen);
X}
X
Xint wlu_initwrdscan(WRD_LUSTRCT *wls,
X                    int *ap,
X                    WRD_LU_REC **rp)
X/* set initial values of ap & *rp, return true if it worked */
X{
Xif (wls != NULL)
X  {
X  *ap = 0;
X  while (*ap < wlu_no_inits(wls->casedep))
X    if ((*rp = *(wls->firstlet + *ap)) != NULL)
X      return(1);
X    else
X      (*ap)++;  /* try next init */
X/* fell right off end, */
X  return(0);
X  }
Xelse
X  return(0);
X}
X
XWRD_LU_REC *wlu_nxtwrd(WRD_LUSTRCT *wls,
X                       int *ap,
X                       WRD_LU_REC *rprv)
X/* given a pointer rprv, return the next element, if necessary, *ap is
Xincremented and the element taken from there.  NULL for no more */
X{
Xif (rprv != NULL)
X  rprv = rprv->nextiwrd;
Xif (rprv != NULL)
X  return(rprv);
Xelse
X  {
X  while (*ap < wlu_no_inits(wls->casedep))
X    {
X    (*ap)++;
X    if ((rprv = *(wls->firstlet + *ap)) != NULL)
X      return(rprv);
X    }
X  return(NULL);
X  }
X}
END-of-meth_progs_dist/src/wlu_fns.c
exit

